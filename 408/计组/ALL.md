  计算机组成和计算机体系结构的区别：计算机体系结构是指机器语言或汇编语言程序员所看得到的传统机器的属性，包括指令集、数据类型、存储器寻址技术等，大都属于抽象的属性
  计算机组成是指如何实现计算机体系结构所体现的属性，它包含许多对程序员来说透明的硬件细节。例如，指令系统属于结构的问题，但指令的实现即如何取指令、分析指令、取操作数、如何运算等都属于组成的问题。因此，当两台机器指令系统相同时，只能认为它们具有相同的结构，至于这两台机器如何实现其指令，完全可以不同，即可认为它们的组成方式是不同的。例如，一台机器是否具备乘法指令是一个结构的问题，但实现乘法指令采用什么方式则是一个组成的问题。许多厂商提供一系列体系结构相同的计算机，但它们的组成却有相当大的区别。
  计算机组成原理的内容包括：基本部件的结构和组织方式、基本运算的操作原理、基本部件和单元的设计思想等

## 1.计算机系统概述

### 1.2 计算机系统层次结构

####  1.2.1 计算机系统的组成

  **硬件系统**和**软件系统**共同构成一个完整的计算机系统。

- `硬件系统`：计算机的实体，如主机、外设等
- 软件系统：由具有各类特殊功能的信息（程序）组成

> 硬件是指有形的物理设备，是计算机系统中实际物理装置的总称。
>
> 软件是指在硬件上运行的程序和相关的数据及文档。

​		对某一功能来说，其既可以用软件实现，又可以用硬件实现，则称为**软硬件在逻辑上是等效**的。

- 在计算机系统中，许多功能既能由硬件直接实现，又可在硬件的配合下由软件实现。
  - （例如，乘法运算既可用专门的乘法器实现，也可由乘法程序实现）
- 在设计计算机系统时，要进行软/硬件的功能分配。一个功能若使用较为频繁且用硬件实现的成本较为理想，则使用硬件解决可以提高效率。而用软件实现可以提高灵活性，但效率往往不如硬件实现高

------

 `例题`：下列叙述中，正确的是（）
  A.寄存器的设置对汇编语言是透明的
  B.实际应用程序的测试结果能全面代表计算机的性能
  C.系列机的基本特性是指令系统向后兼容
  D.软件和硬件在逻辑上是等价的

  答案：C；向后兼容又称向下兼容（Backwards compatibility），指的是时间上向后兼容，即新机器兼容使用以前机器的指令系统，例如较高档的计算机可以运行较为低档计算机所开发的程序。对于B，全面代表计算机性能的是实际软件的运行情况。对于D，软件和硬件在逻辑上是等效的，但不是等价的

------

####  1.2.2 计算机硬件的基本组成

#####   1.早期的冯诺依曼机

  以存储程序为基础的各类计算机通称为冯诺依曼机，其特点为：

- （1）计算机硬件系统由**运算器、存储器、控制器、输入设备和输出设备**5大部件组成
- （2）**指令和数据**以同等地位存储在存储器中，并可按地址寻访
- （3**）指令和数据**均用**二进制代码**表示
- （4）指令由**操作码和地址码**组成，操作码用来表示操作的性质，地址码用来表示操作数在存储器中的位置
- （5）指令在存储器内按顺序存放（通常，指令是顺序执行的，在特定条件下可根据运算结果或设定的条件改变执行顺序）
- （6）早期的冯诺依曼机以运算器为中心，输入/输出设备通过运算器与存储器传送数据

------

> 存储程序的概念是指将指令以代码形式事先输入计算机的主存储器，然后按其在存储器中的首地址执行程序的第一条指令，以后就按程序的规定顺序执行其他指令，直至程序执行结束

------

  典型的冯诺依曼计算机结构：（**虚线为控制线和反馈线，实线为数据线**）
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638936510252.png)

------

 `例题`：冯诺依曼机的基本工作方式是：
==A.控制流驱动方式==  B.多指令多数据流方式  C.微程序控制方式  D.数据流驱动方式

  答案：A；冯·诺依曼机工作方式，可称为**控制流(指令流)驱动方式**。即按照指令的执行序列，依次读取指令，然后根据指令所含的控制信息，调用数据进行处理。B属于多处理机，冯诺依曼机是单指令流和单数据流系统；数据流驱动方式指：只有当一条或一组指令所需的操作数全部准备好时，才能激发相应指令的一次执行，执行结果又流向等待这一数据的下一条或一组指令，以驱动该条或该组指令的执行。因此，程序中各条指令的执行顺序仅仅是由指令间的数据依赖关系决定的。

 `例题`：冯诺依曼计算机中指令和数据均以二进制形式存放在存储器中，CPU区分它们的依据是（）
A.指令操作码的译码结果  B.指令和数据的寻址方式  
==C.指令周期的不同阶段==  D.指令和数据所在的存储单元

  答案：C；虽然指令和数据都以二进制存放在存储器中，但CPU可以**根据指令周期的不同阶段**来区分是指令还是数据，通常在取指阶段取出的是指令，在执行阶段取出的是数据。对于A，CPU只有在确定取出的是指令后，才会将其操作码送去译码，因此不可能依据译码的结果来区分指令和数据

 `例题`：下列关于冯诺依曼结构计算机基本思想的叙述中，错误的是（）

  A.程序的功能都通过中央处理器执行指令实现
  B.指令和数据都用二进制数表示，形式上无差别
  ==C.指令按地址访问，数据都在指令中直接给出==
  D.程序执行前，指令和数据需预先存放在存储器中

  答案：C；程序的功能都通过中央处理器（运算器和控制器）执行指令实现。指令按地址访问，数据由指令的地址码指出，除立即寻址外，数据均存放在存储器内。

------

#####   2.现代计算机的组织结构

  在微处理器问世之前，运算器与控制器分离，存储器容量很小，因此设计成以运算器为中心的结构，其他部件都通过运算器完成信息的传递
  现代计算机已发展为以存储器为中心，使I/O操作尽可能绕过CPU，直接在I/O设备和存储器之间完成，以提高系统的整体运行效率，其结构如下：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638936510253.png)
  目前绝大多数现代计算机仍遵循冯诺依曼的存储程序的设计思想

#####   3.计算机的功能部件

  传统的冯诺依曼计算机和现代计算机的结构虽然有所不同，但功能部件是一致的，包括：

- （1）**输入设备**
  输入设备的主要功能是将程序和数据以机器所能识别和接受的信息形式输入计算机。（常见的输入设备有键盘、鼠标、扫描仪、摄像机等）
- （2）**输出设备**
  输出设备的任务是将计算机处理的结果以人们所能接受的形式或其他系统所要求的信息形式输出（常用的输出设备有显示器、打印机等）。计算机的I/O设备是计算机与外界联系的桥梁。
- （3）**存储器**
  存储器是计算机的存储部件，用来存放程序和数据。
  - 存储器分为**主存储器**（主存，内存储器，内存）和**辅助存储器**（辅存，外存储器，外存）。CPU能够直接访问的存储器是主存。辅存用于帮助主存记忆更多信息，辅存中的信息必须调入主存后，才能被CPU访问。
  - 主存包括**存储体M**、各种逻辑部件及控制电路等。==存储体由许多存储单元组成，每个存储单元包含若干存储元件（或称存储基元、存储元），每个存储元件存储**一位**二进制代码0 or 1==。因此存储单元可存储一串二进制代码，称这串代码为存储字，**称这串代码的位数为存储字长**,存储字长可以是1B或是字节的偶数倍。一个存储字既可代表数，也可代表一串字符，也可代表指令等。

------

> 如果把一个存储体看成一栋大楼，那么每个**存储单元**可看作大楼中的每个房间，每个**存储元件**可看作每个房间中的一张床位，床位有人相当于1，无人相当于0。
>
> 床位数相当于存储字长。每个房间都需要一个房间编号，同样可以赋予每个存储单元一个编号，称为存储单元的地址号。

------

> 主存的工作方式为按**存储单元**(房间)的地址进行存取，这种存取方式称为按地址存取方式,即按地址访问存储器（简称访存）
>

------

  关联存储器（相联存储器），是一种不根据地址而是根据存储内容来进行存取的存储器，可以实现快速地查找块表。相联存储器既可以按照地址寻址也可以按照内容寻址（通常是某些字段），为了与传统寄存器作区别，称为按内容寻址的存储器。

------

​	主存的最基本组成如下：

![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638936510254.png)

- **存储体**存放**二进制信息**。
- 地址寄存器（MAR）存放访存地址，经过地址译码后找到所选的存储单元。
  - MAR用于寻址，其位数对应存储单元的个数，如MAR为10位，则有2^10=1024=1K个存储单元。MAR的长度与PC的长度相等。
- 数据寄存器（MDR)用于**暂存要从存储器中读或写的信息**。
  - MDR的位数和存储字长相等，一般为字节的二次幂的整数倍。
- 时序控制逻辑用于产生存储器操作所需的各种时序信号。

>MAR和MDR虽然是存储器的一部分，但在现代CPU中却是存在于CPU中的

- （4）运算器
  运算器是计算机的执行部件，用于进行算术运算和逻辑运算。算术运算是按算术运算规则进行的运算，如加、减、乘、除；逻辑运算包括与、或、非、异或、比较、移位等运算。
    运算器的核心是算术逻辑单元**ALU**（Arithmetic and Logical Unit）运算器包含若干通用寄存器，用于暂存操作数和中间结果，如累加器ACC，乘商寄存器MQ，操作数寄存器X，变址寄存器IX，基址寄存器BR等，其中ACC,MQ,X是必须有的。

------

ACC，MQ，X这三个寄存器在完成不同运算时，所存放的操作数类别各不相同：
![在这里插入图片描述](E:\Development\Typora\images\20200814162744223.png)

------

  运算器内还有**程序状态寄存器PSW**，也称标志寄存器，用于存放ALU运算得到的一些标志信息或处理机的状态信息。

- （5）控制器
  	控制器是计算机的指挥中心，由其指挥各部件自动协调地进行工作。控制器由程序**计数器PC、指令寄存器IR和控制单元CU组成**。
        **PC**用于存放当前<u>欲执行指令的地址</u>，可自动+1以形成下一条指令的地址，与主存的MAR之间有一条直接通路。
        **IR**用来存放当前的指令，其内容来自主存的MDR。指令中的操作码OP（IR）送至CU，用以分析指令并发出各种微操作命令序列；地址码Ad(IR)送往MAR，用以取操作数。（操作码表示机器所执行的各种操作，地址码表示参加运算的数在存储器内的位置）  
      

  > **一般将运算器和控制器集成到同一个芯片上，称为中央处理器CPU**。CPU和主存共同构成主机，而除主机外的其他硬件装置（外存、I/O设备等）统称为外部设备，简称外设。现代计算机可认为由CPU、I/O设备及存储器组成（或由主机和外部设备组成）

  ![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638936510265.png)

  下图所示为冯诺依曼结构的模型机：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638936510266.png)
 ==CPU包含ALU、通用寄存器组GPRs、标志寄存器、控制器、指令寄存器IR、程序计数器PC、存储器地址寄存器MAR和存储器数据寄存器MDR。==

​		图中从控制器送出的虚线为控制信号，可控制如何修改PC以得到下一条指令的地址、ALU执行什么运算、主存是进行读操作还是写操作（读/写控制信号)

- CPU和主存之间通过一组**总线**相连，总线中有**地址、控制、数据**3组信号线。
  - MAR中的地址信息会直接送到地址线上，用于指向读/写操作的主存存储单元；
  - 控制线中有读/写信号线，指出数据是从CPU写入主存还是从主存读出到CPU，根据是读操作还是写操作来控制将**MDR**中的数据是直接送到数据线上还是将数据线上的数据接收到MDR中。

------

  `例题`：在运算器中，不包含（）
		A.状态寄存器  B.数据总线  C.ALU  ==D.地址寄存器==

  答案：D；地址寄存器位于CPU内，但并未集成到运算器与控制器中。运算器中包含PSW、CPU内部数据总线

  `例题`：若一个8位的计算机系统以16位来表示地址，则该计算机系统有（）个地址空间
  答案：2^16=65536；8位计算机表明计算机字长为8位，即一次可以处理8位的数据，而16位表示地址码的长度

  `例题`:关于相联存储器，下列说法中正确的是（）
  A.只可以按地址寻址
  B.只可以按内容寻址
  C.既可以按内容寻址又可按地址寻址
  D.以上说法均不对

  答案：C；相联存储器既可以按照地址寻址也可以按照内容寻址（通常是某些字段），为了与传统寄存器作区别，称为按内容寻址的存储器。

  `例题`:设主存储器容量为64K x 32位，且指令字长、存储字长、机器字长三者相等。写出如下图所示各寄存器的位数，并指出哪些寄存器之间有信息通路
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638936510267.png)

  答案：16位：MAR,PC；32位：MDR，IR,ACC,MQ,X；
  寄存器之间的信息通路有：
PC——>MAR,MDR——>IR,Ad（IR）——>MAR,MDR——>ACC（取数）
ACC——>MDR（存数），MDR——>X（X为操作数寄存器）

（各个子系统通过数据总线连接形成的数据传送路径称为数据通路。数据通路是对于子系统之间而言的，因此答案中没有ACC与MQ，ACC与X）

------

####  1.2.3计算机软件的分类

#####   1.系统软件和应用软件

​		软件按功能可分为**系统软件**和**应用软件**

- 系统软件又称为系统程序，是一组保证计算机系统高效、正确运行的基础软件，通常作为系统资源提供给用户使用。系统软件主要用来管理整个计算机系统，监视服务，使系统资源得到合理调度，高效运行。
  - 系统软件主要有OS、**数据库管理系统DBMS**、语言处理程序（如汇编程序、编译程序）、分布式软件系统、网络软件系统、标准库程序、服务性程序（如诊断程序、调试程序、连接程序）等。
- 应用软件又称应用程序，是指用户为解决某个应用领域中的各类问题而编制的程序，如各种科学计算类程序、工程设计类程序、数据统计与处理程序等



> 数据库管理系统DBMS不同于数据库系统DBS。DBMS是位于用户和OS之间的一层数据管理软件，是系统软件；DBS是指计算机系统中引入数据库后的系统，一般由数据库、数据库管理系统、数据库管理员DBA和应用系统构成。



#####   2.三个级别的语言与四种程序

机器语言（面向机器）→ 汇编语言（面向机器）→高级语言（面向问题）

![image-20230210200421069](E:/Development/Typora/images/image-20230210200421069-1676269041901-1.png)

  三个级别的语言：

- （1）**机器语言**：又称<u>二进制代码语言</u>，是计算机唯一可以直接识别和执行的语言
- （2）**汇编语言**：使用汇编语言编辑的程序，必须经过一个称为**汇编程序**的`系统软件`的翻译(翻译程序)，将其转换为计算机的机器语言后，才能在计算机的硬件系统上运行。==汇编语言没有通用性，每台机器必须有一种与之相对应的汇编语言。==
- （3）**高级语言**：通常高级语言需要经过编译程序编译成**汇编语言程序**，然后经过==汇编操作==得到**机器语言程序**，或直接由高级语言程序==翻译==成机器语言程序

  四种程序：

- （1）**翻译程序**：指把**高级语言源程序翻译成机器语言程序**（目标代码）的软件
  翻译程序有两种：编译程序与解释程序
  - （2）**编译程序**：将高级语言源程序**一次全部翻译成目标程序**，每次执行程序时，只需执行目标程序，因此只要源程序不变，则无须重新翻译。同一种高级语言在不同体系结构下，编译成的目标程序是不一样的，目标程序与体系结构相关，但仍不是计算机硬件能直接执行的程序。
  - （3）**解释程序**：将源程序的一条语句翻译成对应的机器目标代码，并立即执行，然后翻译下一条源程序语句并执行，直至所有源程序语句全部被翻译并执行完。==所以解释程序的执行过程是翻译一句执行一句，并且不会生成目标程序。==

- （4）**汇编程序**：把汇编语言源程序翻译成机器语言程序。

------

  `例题`:只有当程序执行时才将源程序翻译成机器语言，并且一次只能翻译一行语句，边翻译边执行的是（ ）程序，把汇编语言源程序转变为机器语言程序的过程是（ ）
1.编译  2.目标  3.汇编  4.解释

答案：4,3

  `例题`:关于编译程序和解释程序，下列说法中错误的是（）
  A.编译程序和解释程序的作用都是将高级语言程序转换成机器语言程序
  B.编译程序编译时间较长，运行速度较快
  ==C.解释程序方法较简单，运行速度也较快==
  D.解释程序将源程序翻译成机器语言，并且翻译一条以后，立即执行这条语句

  答案：C；由于解释程序要边翻译边执行，因此一般速度较编译程序慢。

  `例题`:计算机硬件能够直接执行的是（）
  ==1.机器语言程序==   2.汇编语言程序   3.硬件描述语言程序
  A.1   B.1,2   C.1,3   D.1,2,3

  答案：A；硬件能直接执行的只能是机器语言（二进制编码），汇编语言经过汇编后才能被执行；硬件描述语言是电子系统硬件行为描述、结构描述、数据流描述的语言，是对电路系统的结构、行为的标准文本描述。

------

机器语言和汇编语言与机器指令对应，而高级语言不与指令直接对应，具有较好的可移植性。

编译程序与汇编程序的区别：编译程序翻译的源语言是高级语言，目标语言是诸如汇编语言或机器语言之类的“低级语言”。汇编程序翻译的源语言是汇编语言，目标语言是机器语言。

------

####  1.2.4计算机的工作过程

  计算机的工作过程分为以下3个步骤：

- （1）把程序和数据装入主存
- （2）**将源程序转换成可执行文件**
- （3）从可执行文件的首地址开始逐条执行指令

#####   1.从源程序到可执行文件

  在计算机中编写的C语言程序，都必须被转换为一系列的低级机器指令，这些指令按照一种称为**可执行目标文件**的格式打好包，并以二进制磁盘文件的形式存放起来。
  以UNIX中的GCC编译器程序为例，读取源程序文件hello.c，并把它翻译成一个可执行目标文件hello，整个翻译过程可分为4个阶段完成：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638936510268.png)

- （1）预处理阶段：预处理器cpp对源程序中以字符#开头的命令进行处理，例如将#include命令后面的.h文件内容插入程序文件。输出结果是一个以.i为扩展名的源文件hello.i
- （2）编译阶段：编译器ccl对预处理后的源程序进行编译，生成一个汇编语言源程序hello.s。汇编语言源程序中的每条语句都以一种文本格式描述了一条低级机器语言指令。
- （3）汇编阶段：汇编器as将hello.s翻译成机器语言指令，把这些指令打包成一个称为可重定位目标文件的hello.o，它是一种二进制文件
- （4）链接阶段：链接器Id将多个可重定位目标文件和标准库函数printf所在的可重定位目标模块printf.o合并，生成可执行文件hello。最终生成的可执行文件被保存在磁盘上。

#####   2.指令执行过程的描述

  以取数指令（将指令地址码指示的存储单元中的操作数取出后送ACC）为例，其信息流程如下：

- （1）取指令：PC——>MAR——>M——>MDR——>IR

- （2）分析指令：OP（IR）——>CU

- （3）执行指令：Ad（IR）——>MAR——>M——>MDR——>ACC

  此外，每取完一条指令，还须形成下一条指令的地址，即（PC）+1——>PC

------

在（1）中，PC没加括号，表示的是PC中的值经过数据通路送到MAR，在表示数据通路时括号可省略（因为只是表示数据流经的途径，不强调数据本身的流动），但当题目中的括号未省时，最好不省，和题目中保持一致。在运算时括号不可省。

------

####  1.2.5计算机系统的多级层次结构

  计算机系统的层次结构划分应用了一种处理系统复杂性的方法——抽象，这与计算机网络中的分层思想类似
  计算机系统的多级层次结构的作用，即根据从各种角度所看到的机器之间的有机联系，来分清彼此之间的界面，明确各自的功能。
  分层方式的一种（程序员角度的抽象）：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638936510269.png)

1. 第一级是**微程序机器层**，是一个实在的硬件层，由机器硬件直接执行微指令。机器M0是直接将机器M1中的每一条机器指令翻译成一组微指令，即构成一个微程序。机器M0每执行完对应于一条机器指令的一个微程序后，便由机器M1中的下一条机器指令使机器M0自动进入与其相对应的另一个微程序的执行。微程序机器M0可看作是对实际机器M1的分解，即用M0的微程序解释并执行M1的每一条机器指令。
2. 第二级是传统机器语言层，也是一个实际的机器层，由微程序解释机器指令系统
3. 第三级是操作系统层，由操作系统程序实现。操作系统程序是由机器指令和广义指令组成的，这些广义指令是为了扩展机器功能而设置的，是由操作系统定义和解释的软件指令，所以这一层也称混合层。
4. 第四级是汇编语言层，它为用户提供一种符号化的语言，借此可编写汇编语言源程序。这一层由汇编程序支持和执行。
5. 第五级是高级语言层，是面向用户的，由各种高级语言编译程序支持和执行。
6. 在高级语言层之上，还可以有应用层，它由解决实际问题和应用问题的处理程序组成，如文字处理软件、数据库软件等。
7. 通常把没有配备软件的纯硬件系统称为裸机，第3~5层称为虚拟机，简单来说就是软件实现的机器。虚拟机只对该层的观察者存在。

------

> 在计算机领域中，站在某类用户的角度，若感觉不到某个事物或属性的存在，即看不到某个事物或属性，则称为“对该用户而言，某个事物或属性是透明的”。

  例如，对于高级语言程序员来说，浮点数格式、乘法指令等指令的格式、数据如何在运算器中运算等都是透明的；而对于机器语言或汇编语言程序员来说，指令的格式、机器结构、数据格式等则是不透明的。
  在CPU中，IR、MAR、MDR对各类程序员都是透明的。

### 1.3 计算机的性能指标

####  1.3.1计算机的主要性能指标

#####   1.机器字长

  机器字长是指计算机进行一次整数运算（即定点整数运算）所能处理的二进制数据的位数（一次能处理数据的位数）。机器字长一般等于内部寄存器的大小，字长越长，数的表示范围越大，计算精度越高。计算机字长通常为字节的整数倍。

------

> 机器字长、指令字长、存储字长的区别与联系：
>   机器字长：计算机能直接处理的二进制的位数，机器字长一般等于内部寄存器的大小，它决定了计算机的运算精度
>   指令字长：一个指令字中包含的二进制代码的位数
>   存储字长：一个存储单元存储的二进制代码的长度
>
>   它们都必须是字节的整数倍。指令字长一般取存储字长的整数倍，若指令字长等于存储字长的2倍，则需要2次访存来取出一条指令，因此取指周期为机器周期的2倍（机器周期是CPU操作的最基本单位）；若指令字长等于存储字长，则取指周期等于机器周期

------

#####   2.数据通路带宽

  数据通路带宽指数据总线一次所能并行传送信息的位数。这里所说的数据通路宽度是指外部数据总线的宽度，它与CPU内部的数据总线宽度（内部寄存器的大小）有可能不同。

------

> 各个子系统通过数据总线连接形成的数据传送路径称为数据通路

------

#####   3.主存容量

  主存容量是指主存所能存储信息的最大容量（主存中存放二进制代码的总位数），主存容量=存储单元个数 x 存储字长，通常以字节衡量，也可用字数x字长（如512K x 16位）来表示存储容量。其中，MAR的位数反映存储单元的个数，MAR的位数反映可寻址范围的最大值（而不一定是实际存储器的存储容量）。
  例如，MAR为16位，表示2^16，即此存储体内有 2 ^ 16=65536个存储单元（可称为64K内存），若MDR为32位，表示存储容量为64K x 32位。

#####   4.运算速度

- （1）吞吐量和响应时间
  吞吐量：指系统在单位时间内处理请求的数量。它取决于信息能多快地输入内存，CPU能多快地取指令，数据能多快地从内存取出或存入，以及所得结果能多快地从内存送给一台外部设备。几乎每步都关系到主存，因此系统吞吐量主要取决于主存的存取周期。
    响应时间：指从用户向计算机发送一个请求，到系统对该请求作出响应并获得所需结果的等待时间。通常包括CPU时间（运行一个程序所花费的时间）与等待时间（用于磁盘访问、存储器访问、I/O操作、OS开销等的时间）
- （2）主频和CPU时钟周期
  CPU时钟周期：通常为节拍脉冲或T周期，它是CPU中最小的时间单位，每个动作至少需要1个时钟周期。
    主频（CPU时钟频率）：机器内部主时钟的频率，是衡量机器速度的重要参数。对于同一个型号的计算机，其主频越高，完成指令的一个执行步骤所用的时间最短，执行指令的速度越快。

------

CPU时钟周期=1/主频，主频通常以Hz为单位，1Hz即每s一次

主频高的CPU不一定比主频低的CPU快，衡量CPU运算速度的指标有很多，不能以单独的某个指标判断CPU的好坏。CPU的运算速度还要看CPU的流水线的各方面的性能指标（架构、缓存、指令集、CPU的位数、Cache的大小等）。

------

- （3）CPI（Clock cycle Per Instruction）：执行一条指令所需的时钟周期数
- （4）CPU执行时间：指运行一个程序所花费的时间
  CPU执行时间=（指令条数 x CPI）/主频=CPU时钟周期数/主频
    上式表明，CPU的性能（CPU的执行时间）取决于：主频、CPI、指令条数
    主频、CPI和指令条数是相互制约的。例如，更改指令集可减少程序所含指令的条数，但同时可能引起CPU结构的调整，从而可能会增加时钟周期的宽度（降低主频）。
- （5）MIPS、MFLOPS、GFLOPS、TFLOPS
  MIPS（Million Instructions Per Second）：即每秒执行多少百万条（10 ^ 6）指令，MIPS=指令条数/（执行时间 x 10^6）=主频/CPI
    MFLOPS（Mega Floating-point Operations Per Second）：即每秒执行多少百万次浮点运算，MFLOPS=浮点操作次数/（执行时间x10^6）
    GFLOPS（Giga Floating-point Operations Per Second）：每秒执行多少十亿次（10 ^ 9 ）浮点运算
    TFLOPS（Tera Floating-point Operations Per Second)：每秒执行多少万亿次（ 10 ^ 12 ）浮点运算
    PFLOPS：P=10^3T （ 10 ^ 15）
    EFLOPS：E=10 ^ 3 P （ 10 ^ 18）
    ZFLOPS: Z= 10 ^ 3 E （10 ^ 21）

------

在描述存储容量、文件大小时，K,M,G,T通常用2的幂次表示，在描述速率、频率时，k，M,G,T通常用10的幂次表示

------

------

  例题:CPU的CPI与下列（）因素无关
  A.时钟频率   B.系统结构   C.指令集   D.计算机组织

  答案：A； 系统结构、指令集、计算机组织都会影响CPI，时钟频率并不会影响CPI（只是决定每个CLOCK的时间），可影响指令的执行速度

  例题:下列说法中，正确的是（）
  1.在微型计算机的广泛应用中，会计电算化属于科学计算方面的应用
  2.决定计算机计算精度的主要技术是计算机的字长
  3.计算机“运算速度”指标的含义是每秒能执行多少条操作系统的命令
  4.利用大规模集成电路技术把计算机的运算部件和控制部件做在一块集成电路芯片上，这样的一块芯片称为单片机
  A.1,3   B.2,4   C.2   D.1,3,4

  答案：C；计算机“运算速度”指标的含义是每秒能执行多少条指令；4中集成的芯片称为CPU

  例题:假定基准程序A在某计算机上的运行时间为100s，其中90s为CPU时间，其余为I/O时间。若CPU速度提高50%，I/O速度不变，则运行基准程序A所耗费的时间为（）

  A.55s   B.60s   C.65s   D.70s
  答案：D;CPU速度提高50%，CPU速度是原来的1.5倍而不是2倍，90/1.5+10

  例题:假定计算机M1和M2具有相同的指令集体系结构（ISA），主频分别为1.5GHz和1.2GHz。在M1和M2上运行某基准程序P，平均CPI分别为2和1，则程序P在M1和M2上运行时间的比值为（）

  答案：1.6

  例题:某台计算机只有Load/Store指令能对存储器进行读/写操作，其他指令只对寄存器进行操作。根据程序跟踪实验结果，已知每种指令所占的比例及CPI数如下
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389365102610.png)
  求上述情况下的平均CPI。假设程序由M条指令组成。算逻运算中25%的指令的两个操作数中的一个已在寄存器中，另一个必须在算逻指令执行前用Load指令从存储器中取到寄存器中。因此有人建议增加另一种算逻指令，其特点是一个操作数取自寄存器，另一个操作数取自存储器，即寄存器——存储器类型，假设这种指令的CPI等于2。同时，转移指令的CPI变为3。求新指令系统的平均CPI。

  答案：CPI=0.43 * 1+0.21 * 2+0.12 * 2+0.24 * 2=1.57
  增加新算逻指令后，原来的LOAD指令数减少，因此总指令数减少。设原指令总数为M，新指令总数为M-0.25*0.43M=0.8925M，计算得新的CPI为1.9076

------

####  1.3.2几个专业术语

- （1）系列机：具有基本相同的体系结构，使用相同基本指令系统的多个不同型号的计算机组成的一个产品系列
- （2）兼容：指计算机软件或硬件的通用性，即使用或运行在某个型号的计算机系统上的硬件/软件也能应用于另一个型号的计算机系统时，称这两台计算机在硬件或软件上具有兼容性
- （3）软件可移植性：指把使用在某个系列计算机中的软件直接或进行很少的修改就能运行在另一个系列计算机中的可能性
- （4）固件：将程序固定在ROM中组成的部件称为固件。固件是一种具有软件特性的硬件，是软/硬件结合的产物。例如，目前OS已实现了部分固化（把软件永恒地存储于只读存储器中）



## 	2.数据的表示和运算

### 2.1 数制与编码

####  2.1.1 进位计数制及其相互转换

  在计算机系统内部，所有的信息都是用[二进制](https://so.csdn.net/so/search?q=二进制&spm=1001.2101.3001.7020)进行编码的，这样做的原因有：

- （1）二进制只有两种状态，使用有两个稳定状态的物理器件就可以表示二进制数的每一位，制造成本较低
- （2）二进制位1和0正好与逻辑值真和假对应，为计算机实现逻辑运算和程序中的逻辑判断提供了便利条件
- （3）二进制的编码和运算规则都很简单，通过逻辑门电路能方便地实现算术运算

#####   1.进位计数法

  在进位计数法中，**每个数位所用到的不同数码的个数称为基数**，如10进制的基数为10。每个数码所表示的数值等于该数码本身乘以一个与它所在数位有关的常数，这个常数称为位**权**。一个进位数的数值大小就是它的各位数码按权相加。

#####   2.不同进制数之间的相互转换

- （1）二进制转为8进制和16进制
  对于一个`二进制混合数`（**既包含整数部分，又包含小数部分**）

  - 在转换时应以小数点为界。其整数部分，==从小数点开始往左数==，将一串二进制数分为**3位**（八进制）一组或**4位**（16进制）一组，在数的最左边可根据需要加0补齐；
  - 对于小数部分，==从小数点开始往右数==，也将一串二进制数分为**3位**一组或**4位**一组，在数的最右边也可根据需要加0补齐。
        例：（1111000010.01101）2=（1702.32）8=（3C2.68）16

- （2）十进制数转换为任意进制数
  采用基数乘除法，这种转换方法对十进制数的整数部分和小数部分分别进行处理，对整数部分用**除基取余法**，对小数部分用**乘基取整法**，最后将整数部分与小数部分的转换结果拼接起来。–这里的基表示对应进制的基数

  > ​	`除基取余法`（整数部分的转换）：整数部分除基取余，最先取得的余数为数的最低位，最后取得的余数为数的最高位（<font color='red'>除基取余，先余为低，后余为高，因为后余乘以基数的幂次更高</font>），**商为0**时结束例：将（123.6875）10转换为二进制
  >   整数部分：
  > ![在这里插入图片描述](E:\Development\Typora\images\20200815071922497.png)
  >   （123）10=（1111011)2

  > `  乘基取整法`（小数部分的转换）：小数部分乘基取整，最先取得的整数为数的最高位，最后取得的整数为数的最低位（<font color='red'>乘积取整，先整为高，后整为低，因为后整要除以更多基数的幂次</font>) ，**乘积为1.0**或满足精度要求时结束小数部分：
  >   ![在这里插入图片描述](E:\Development\Typora\images\20200815073100969.png)
  >     （0.6875）10=（0.1011）2
  >     所以，（123.6875）10=（1111011.1011)2

------

  在计算机中，小数和整数不一样，**整数可以连续表示，但小数是离散的**（二进制表示小数时只能用$\frac {1}{2^n}$的和的任意组合表示），<font color='orange'>所以并不是每一个十进制小数都可以准确地用二进制表示。但任意一个二进制小数都可用十进制小数表示。</font>

------

####  2.1.2 真值与机器数

  +15，-8这种<font color='red'>带+或-符号</font>的数称为**真值**，真值是机器数所代表的实际值
  在计算机中，**通常采用数的符号与数值一起编码的方法来表示数据**，常用的有原码、补码、反码表示法。这几种表示法都将数据的符号数字化，`通常用0表示正，用1表示负`

​		如0,101（逗号“，”并不实际存在，只是用来区分符号位与数值位，约定整数的数值位与符号位之间用逗号隔开，小数的符号位与数值位之间用小数点隔开）表示+5。

​	**这种把符号数字化的数称为机器数。**

####  2.1.4 字符与字符串

#####   1.字符编码ASCII码

  普遍采用的一种字符系统是7位二进制编码的ASCII码（最早是7位，后来扩充为8位，在7位时期，为满足被8整除条件，需加1位空位才能使用），它可表示10个十进制数码、52个英文大小写字母及一定数量的专用符号，共**128**个字符。

> 0~9的ASCII码值为48（011 0000）~57（011 1001），即去掉高3位，只保留低4位，正好是二进制形式的0~9

#####   2.汉字的表示和编码

  汉字的编码包括汉字的`输入编码、汉字内码、汉字字形码`三种，它们是计算机中用于输入、内部处理和输出三种用途的编码。区位码用2字节表示一个汉字，每字节用七位码。区位码是4位十进制数，前2位是区码，后2位是位码，所以称为区位码。如汉字“学”的区位码为4907（十进制），用2个字节的二进制可以表示为00110001 00000111。
  国标码将10进制的区位码转换为16进制数后，再在每字节上加上20H。国标码两字节的最高位都是0，ASCII码的最高位也为0。为了便于区分中文和英文字符，将国标码两字节的最高位都改为1，这就是汉字内码
  区位码和国标码都是输入码，它们与汉字内码的关系（16进制）为：
  国标码=（区位码）16+2020H  汉字内码=（国标码）16+8080H

------

### 2.2 定点数的表示与运算

####  2.2.1 定点数的表示

#####   1.无符号数与有符号数的表示

  在计算机中参与运算的机器数有两类：**无符号数和有符号数**

- （1）无符号数
  ==指整个机器字长的全部二进制位均为数值位，没有符号位，相当于数的绝对值。==若机器字长为8位，则数的表示范围为0~2^8-1，即0 ~255
- （2）有符号数(真值和机器数)
  <font color='red'>0正1负</font>，**通常约定二进制的最高位为符号位，即将符号位放在有效数字的前面，组成有符号数**
    有符号数的机器表示有原码、补码、反码、移码，约定X为真值，$[X]_原$为原码，$[X]_补$为补码，$[X]_反$为反码，$[X]_移$为移码。

#####   2.机器数的定点表示

> ​	**根据小数点的位置是否固定**，在计算机中有两种数据格式：**定点表示**和**浮点表示**。定点表示的数称为定点数，浮点表示的数称浮点数。<u>采用定点数的机器称为**定点机**。</u>
>  在定点机中，由于小数点的位置固定不变，故当机器处理的数不是纯小数或纯整数时，必须乘上一个比例因子，否则将溢出。
>  定点表示即约定机器数中小数点位置是固定不变的，小数点不再使用“.”表示，而是约定它的位置。通常采用两种约定：==将小数点的位置固定在数据的最高位之前（定点小数），或固定在最低位之后（定点整数）==

- （1）定点小数
  **定点小数是纯小数，约定小数点位置在符号位之后、有效数值部分最高位之前。**
  - 若数据X的**形式**为$X=x_0.x_1x_2…x_n$（其中$x_0$为符号位，$x_1$~$x_n$是数值的有效部分，也称尾数，$x_1$为最高有效位），则在计算机中的表示形式为：（设机器字长为n+1位）
    ![在这里插入图片描述](E:\Development\Typora\images\20200815111559908.png)
      当$x_0$=0，其余均为1时，X为最大正数1-2-n。$x_0=1$，其余均为1时，X为其（原码）所能表示的最大负数-（1-2-n)

- （2）定点整数
  **定点整数是纯整数，约定小数点位置在有效数值部分最低位之后。**
  ![在这里插入图片描述](E:\Development\Typora\images\20200815112035116.png)
    当$x_0$=0，其余均为1时，X为最大正数$2^n-1$。x0=1，其余均为1时，X为其（原码）所能表示的最大负数$-（2^n-1)$

#####   3.原码、补码、反码、移码

######   （1）原码表示法

  用机器数的最高位表示该数的符号，其余的各位表示数的绝对值，故原码表示又称带符号的绝对值表示。

- 纯小数的原码定义
  ![-](E:\Development\Typora\images\2020081511280532.png)

  例如：字长为8位，x=+0.1101，[x]原=0.1101000；x=-0.1101，[x]原=1.1101000
  若字长为n+1，原码小数的表示范围为-（1-2-n）~1-2-n（关于原点对称）

- 纯整数的原码定义
  ![在这里插入图片描述](E:\Development\Typora\images\20200815113810767.png)
    例如：字长为8位，x=+1110，[x]原=0,0001110；x=-1110，[x]原=1,0001110
    若字长为n+1，原码整数的表示范围为-（2n-1）~2n-1（关于原点对称)

------

>   真值0的原码表示有正0和负0两种形式。[+0]原=0 0000和[-0]原=1 0000
>

------

######   （2）补码表示法

------

>     时钟指向6点，若要它指向3点，可顺时针转9格，也可逆时针转3格，6-3=3，6+9=15。时针转一圈能指示12小时，12在时钟里是不被显示而自动丢失的，15-12=3,15点和3点均显示3。在数学上称12为模，写为mod 12，称+9是-3以12为模的补数，记为$− 3 ≡ + 9 -3 \equiv +9−3≡+9（mod 12）$，或者说，对于模12，-3和9互为补数
>     只要确定了模，就可找到一个与负数等价的正数（该正数即为负数的补数）来代替此负数，这样就可把减法运算用加法实现
>     补数概念中的结论有：
>
>   ​		a.一个负数可用它的正补数代替，而这个正补数可用模加上负数本身得到；
>
>   ​		b.一个正数和一个负数互为补数时，它们的绝对值之和即为模数；
>
>   ​		**c.正数的补数即该正数本身**

------

>   **补码表示法中的加减法统一用加法实现**
>

- 纯小数的补码定义
  ![在这里插入图片描述](E:\Development\Typora\images\20200815142749423.png)

  例如，字长为8位，

x=+0.1001，$[x]_补$=0.1001000；

x=-0.0110，$[x]_补$=1.1010000

  若字长为n+1，补码的表示范围为-1~1-2-n（比原码多表示-1）

- 纯整数的补码定义
  ![在这里插入图片描述](E:\Development\Typora\images\20200815143538472.png)
    例如，字长为8位，x=+1010，[x]补=0，0001010；x=-1101，[x]补=1，1110011
    若字长为n+1，补码的表示范围为-2n~2n-1（比原码多表示-2n)

------

`真值0的补码表示是唯一的`。==即[+0]补=[-0]补=0.0000==，由定义得[-1]补=10.0000-1.0000=1.0000,对于小数，补码比原码多表示一个-1（这是因为补码中的0只有1种表示形式，故它能比原码多表示一个-1）。对于整数，[-8]补=10000-1000=1000，补码比原码多表示一个-2n（因为补码没有负0，故诸如10000000这样的数表示的是8位补码的最小数-128）

------

- 由原码求补码、由补码求原码
  - ==**正数原补码相同，[x]补=[x]原**==
  - ==对于负数，原码符号位不变，数值部分按位取反，末尾加1即得补码（`取反加1`，同样适用于由补码求原码）==

> -14 补码的另外一种计算方法：符号位不变，其余各位000 1110，从右往左，0和第一个1不变，其余各位取反。
>
> 
>
> ![image-20220909092714220](E:\Development\Typora\images\image-20220909092714220.png)
>

- 补码的算术移位
  将[x]补的`符号位与数值位`一起右移一位并`保持原符号位数值不变`，可实现除法功能（除以2）。
    变形补码，又称模4补码，双符号位的补码小数，其定义为：
  ![在这里插入图片描述](E:\Development\Typora\images\2020081514565340.png)
    模4补码双符号位00表示正，11表示负，用在完成算术运算的ALU部件中

######   （3）反码表示法

  **反码通常用来作为由原码求补码或由补码求原码的中间过渡**

- 纯小数的反码定义
  ![在这里插入图片描述](E:\Development\Typora\images\20200815150053836.png)
  例如，字长为8位，

- x=+0.0110，[x]反=0.0110000；

- x=-0.0110，[x]补=1.1001111

  

  若字长为n+1，反码的表示范围为-（1-2-n）~1-2-n（与原码纯小数的表示范围相同，关于原点对称)

------

> 真值0的反码表示不唯一，[+0]反=0 .0000和[-0]反=1.1111
>

------

- 纯整数的反码定义
  ![在这里插入图片描述](E:\Development\Typora\images\20200815150808510.png)
    例如，字长为8位，x=+1011，[x]反=0,0001011；x=-1011，[x]反=1,1110100
    若字长为n+1，反码的表示范围为-（2n-1）~2n-1（与原码纯整数的表示范围相同，关于原点对称)
    真值、原码、补码、反码及[-x]补的转换规律为：

![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16626840248354.png)

######   （4）移码表示法

  能直接从移码形式判断其真值的大小，又因为检验移码的特殊值较容易，因此移码常用来表示浮点数的阶码。它只能表示整数。
  `移码就是在真值X上加上一个常数（偏置值），通常这个常数取2^n，相当于X在数轴上向正方向偏移了若干单位`。

​		移码定义为：
![在这里插入图片描述](E:\Development\Typora\images\20200815152507758.png)
  例如，字长为8位，x=+10101，[x]移=1,0010101；x=-10101，[x]移=0,1101011
  移码的特点：

- `移码中0的表示唯一`，[+0]移=2 ^ n+0=[-0]移=2^n-0=100…0（n个0）
- 一个真值的移码和补码仅差一个符号位，**[x]补的符号位取反即得[x]移**（1正0负，与其他机器数符号位取值正好相反），反之亦然
- 移码全0时，对应真值的最小值-2^n；移码全1时，对应真值的最大值$2 ^ n-1$
- 移码保持了数据原有的大小顺序，移码大真值就大，移码小真值就小

------

  长度为n+1的定点数，按不同编码方式表示的数据范围如下表：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16626840248365.png)

------



​		`例题`：对真值0表示形式唯一的机器数是（）

  答案：补码和移码

  `例题`：若定点整数为64位，含一位符号位，采用补码表示，所能表示的绝对值最大负数为（）

  答案：-263

  `例题`：5位二进制定点小数，用补码表示时，最小负数是（）
  A.0.111  B.1.0001  C.1.111  D.1.0000

  答案：D；

  `例题`：下列关于补码和移码关系的叙述中，（）是不正确的
  A.相同位数的补码和移码表示具有相同的数据表示范围
  B.0的补码和移码表示相同
  C.同一个数的补码和移码表示，其数值部分相同，而符号相反
  D.一般用移码表示浮点数的阶，而补码表示定点整数

  答案：B

  `例题`：若[x]补=1,x1x2x3x4x5x6，其中xi取0 or 1，若要x>-32,应当满足
  A.x1为0，其他各位任意
  B.x1为1，其他各位任意
  C.x1为1，x2…x6中至少有1位为1
  D.x1为0，x2…x6中至少有1位为1

  答案：C

  `例题`：设x为整数，[x]补=1,x1x2x3x4x5，若要x<-16,应当满足
  A.x1~x5至少有一个为1
  B.x1为0，x2~x5至少有一个为1
  C.x1为0，x2~x5任意
  D.x1为1，x2~x5任意

  答案：C

  `例题`：设x为真值，x*为其绝对值，满足 [ -x * ]补=[ -x ]补，当且仅当（）
  A.x任意  B.x为正数  C.x为负数  D.以上说法都不对

  答案：D；当且仅当x为正数或0时

  `例题`：关于模4补码，下列说法正确的是（）
  A.模4补码和模2补码不同，它更容易检查乘除运算中的溢出问题
  B.每个模4补码存储时只需一个符号位
  C.存储每个模4补码需要两个符号位
  D.模4补码，在算术与逻辑部件中为一个符号位

  答案：B;模4补码具有模2补码的全部优点且更易检查加减运算中的溢出问题，而不是乘除运算；存储模4补码仅需一个符号位，因为任何一个正确的数值，模4补码的两个符号位总是相同的，只在把两个模4补码的数送往ALU完成加减运算时，才把每个数的符号位的值同时送到ALU的双符号位中，即只在ALU中采用双符号位

  `例题`：若寄存器内容为10000000，若它等于-0，则为（）
  A.原码  B.补码  C.反码  D.移码

  答案：A；值等于-0说明只有可能是原码或反码（因为补码和移码表示0时是唯一的）

  `例题`：在计算机中，通常用来表示主存地址的是（）
  A.移码  B.补码  C.原码  D.无符号数

  答案：D；

  `例题`：由3个1和5个0组成的8位二进制补码，能表示的最小整数是（）

  答案：-125

  `例题`：证明：在定点小数表示中，[x]补+[y]补=2+（x+y）=[x+y]补

  答案：分四种情况；（1）x>0,y>0:[x]补+[y]补=x+y=[x+y]补=2+x+y（mod 2）;
  （2）x>0，y<0:x+y有大于或小于0两种情况，[x]补+[y]补=2+x+y;若x+y>0,进位2丢失,[x]补+[y]补=x+y,又[x+y]补=x+y，得证。若x+y<0，[x+y]补=2+x+y，得证。
  （3）x<0，y>0，与（2）同，把xy互换即可
  （4）x<0,y<0:[x]补+[y]补=2+（2+x+y），因为1<2+x+y<2，进位2丢失，[x]补+[y]补=2+x+y=[x+y]补
  结论：在模2意义下，任意两数的补码之和等于两数之和的补码，对定点整数也成立。

  `例题`：假设有2个整数x和y，x=-68,y=-80，采用补码形式（含1位符号位）表示，x和y分别存放在寄存器A和B中。另外，还有两个寄存器C和D。ABCD都是8位的寄存器。请回答下列问题（二进制序列要求用16进制表示）
  （1）寄存器A和B中的内容分别是什么
  （2）x和y相加后的结果存放在寄存器C中，寄存器C中的内容是什么？此时，溢出标志位OF是什么？符号标志位SF是什么？进位标志位CF是什么？
  （3）x和y相减后的结果存放在寄存器D中，寄存器D中的内容是什么？此时，溢出标志位OF是什么？符号标志位SF是什么？进位标志位CF是什么？

  答案：（1）A、B内容分别为BCH、B0H；（2）6CH，OF=1，SF=0，CF=1；（3）0CH，OF=0，SF=0，CF=1

------

####  2.2.2 定点数的运算

#####   1.定点数的移位运算

  二进制表示的机器数在相对于小数点作n位左移或右移时，其实质就是该数乘以或除以2^n

  移位运算根据操作对象的不同分为算术移位和逻辑移位。**有符号数的移位称为算术移位**，**逻辑移位的操作对象是逻辑代码，可视为无符号数**

- （1）算术移位
  
  ==算术移位的对象是有符号数，在移位过程中符号位保持不变== 
  
  1. 对于正数，由于[x]原=[x]补=[x]反=真值，因此移位后出现的空位均用0填充。
  2. 对于负数，由于原码、补码、反码的表示形式不同，因此当机器数移位时，对其空位的填补规则也不同。（不论是正数还是负数，移位后其符号位均不变，且移位后都相当于对真值补0，根据补码、反码的特性，在负数时填充代码有区别）
  3. 对于原码，左移一位若不产生溢出，相当于乘以2，右移一位，若不考虑因移出而舍去的末位尾数，相当于除以2。
  
    不同机器数算术移位后的空位填补规则为：
  ![在这里插入图片描述](E:\Development\Typora\images\20200815154956134.png)
  
    负数的原码数值部分与真值相同，在移位时只要使符号位不变，其空位均填0；负数的反码各位除符号位外与负数的原码正好相反，因此移位后所填的代码应与原码相反，即全部填1。
    在由原码得补码的过程中（由高位到低位找到最后一个1后，后面的照抄），当对其由低位向高位找到第一个1时，在此1左边的各位均与对应的反码相同，在此1右边的各位（包括1在内)均与对应的原码相同。因此负数的补码左移时，因空位出现在低位，填补的代码与原码相同，即填0；右移时空位出现在高位，填补的代码与反码相同，即填1。
  
  
  
- （2）逻辑移位
  逻辑移位将`操作数`视为无符号数，逻辑左移时，高位移丢，低位填0，右移时，低位移丢，高位填0；逻辑移位不管是左移还是右移，都填0；
  
- （3）循环移位
  循环移位分为带进位标志位CF的循环移位（大循环）和不带进位标志位的循环移位（小循环）
  ![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16626840248366.png)
  （a)不带进位的循环右移：操作数循环右移位，空出的高位部分由移出的低位部分来填充。同时,CF中只保存最后一次移出的那一位的内容

  （b）带进位的循环右移：操作数连同CF位循环右移，用原CF的值填补空出的位，移出的位再进入CF。

  （c）不带进位的循环左移：操作数循环左移位，空出的低位部分由移出的高位部分来填充。同时,CF中只保存最后一次移出的那一位的内容

  （d）带进位的循环左移：操作数连同CF位循环左移，用原CF的值填补空出的位，移出的位再进入CF。

  循环移位操作适合将数据的低字节数据和高字节数据互换

------

    `例题`：一个8位寄存器内的数值为11001010，进位标志寄存器C为0，若将此8位寄存器循环左移（不带进位位）1位，则该8位寄存器和标志寄存器内的数值分别为（）

    答案：10010101 ； 1

    `例题`：已知32位寄存器R1中存放的变量x的机器码为8000 0004H，当x为int类型时，乘除法采用移位操作，x的真值是多少？x/2的真值是多少？x/2存放在R1中的机器码是什么？2x的真值是多少？2x存放在R1中的机器码是多少？

    答案：x为补码，x的真值为4-231，x/2的真值为2-230,x/2的机器码为C0000002H,2x的真值为8-232，发生溢出（能表示的最小数为-231）2x的机器码为8000 0008H

    `例题`：下列关于各种移位的说法正确的是（）
    1.假设机器数采用反码表示，当机器数为负时，左移时最高数位丢0，结果出错；右移时最低数位丢0，影响精度
    2.在算术移位的情况下，补码左移的前提条件是其原最高有效位与原符号位要相同
    3.在算术移位的情况下，双符号位的移位操作只有低符号位需要参加移位操作
    A.1,3  B.2  C.3  D.1,2，3

    答案：D；双符号位的最高符号位代表真正的符号，而低位符号位用于参与移位操作以判断是否发生溢出

------

#####   2.原码定点数的加减法运算

  `加法规则`：先判符号位，若相同，则绝对值相加，结果符号位不变；若不同，则做减法，绝对值大的数减绝对值小的数，结果符号位与绝对值大的数相同。
  `减法规则`：两个原码表示的数相减，首先将减数符号取反，然后将被减数与符号取反后的减数按原码加法进行运算。

#####   3.补码定点数的加减法运算

   计算机系统中普遍采用补码加减运算。**补码运算符号位与数值位按同样规则一起参与运算，==符号位运算产生的进位要丢掉，结果的符号位由运算得出。==**补码加减运算公式：
![在这里插入图片描述](E:\Development\Typora\images\20200815162711200.png)

![image-20220913163035001](E:\Development\Typora\images\image-20220913163035001.png)   当参与运算的数是定点小数时，模M=2；参与运算的数是定点整数时，模M=2n+1，mod M运算是为了将溢出位丢掉
   若做加法，两数补码直接相加；若做减法，则将被减数补码与减数的机器负数的补码相加。
   例：机器字长为8位（含一位符号位)，A=15，B=24，求[A+B]补和[A-B]补
  $[A]_补$=00001111，$[B]_补$=00011000，$[-B]_补$=11101000，$[A+B]_补$=00100111，对应真值39，$[A-B]_补$=11110111，对应真值-9

![image-20220913170049986](E:\Development\Typora\images\image-20220913170049986.png)

------

  实现补码定点加减法的基本硬件配置框图如下：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16626840248367.png)
  图中寄存器A、X、加法器的位数相等，其中A存放被加数（或被减数）的补码，X存放加数（或减数）的补码。当作减法时，由“求补控制逻辑”将$X ‾ \overline{X}$送至加法器，并使加法器的最末位外来进位为1，以达到对减数求补的目的。运算结果溢出时，通过溢出判断电路置1溢出标记V。GA为加法标记，GS为减法标记
  补码加减运算控制流程如图所示：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16626840248368.png)
  加（减）法运算前，被加（减）数的补码在A中，加（减）数的补码在X中。若是加法，直接完成（A）+（X）——>A（mod 2 或 mod 2n+1)的运算；若是减法，则需对减数求补，再和A寄存器中的内容相加，结果送A。最后完成溢出判断。

------

------

  `例题`：假定有符号整数采用补码表示，若int型变量x和y的机器数分别是FFFF FFDFH和0000 0041H，则x,y的值（10进制）及x-y的机器数分别是（）

  答案：x=-33,y=65,x-y的机器数为FFFF FF9EH

------

#####   4.符号拓展

  在计算机算术运算中，有时必须把采用给定位数表示的数转换成具有不同位数的某种表示形式。例如，某个程序要将一个8位数与一个32位数相加，要想得到正确的结果，在将8位数与32位数相加之前，必须把8位数转换成32位数形式，这称为**符号拓展**。

 ==正数的符号拓展即原有形式的符号位移动到新形式的符号位上，新表示形式的所有附加位都用0填充==
  负数的符号拓展方法则根据机器数的不同而不同。

1. 原码表示负数的符号拓展方法与正数相同，此时符号位为1。（新表示形式的所有附加位都用0填充）
2. 补码表示负数的符号拓展方法：原有形式的符号位移动到新形式的符号位上，**新表示形式的所有附加位都用1（对于整数）或0（对于小数）进行填充。**
3. 反码表示负数的符号拓展方法：原有形式的符号位移动到新形式的符号位上，新表示形式的所有附加位都用1进行填充。

#####   5.溢出概念与判别方法

  称大于机器所能表示的最大正数为上溢，小于机器所能表示的最小负数为下溢。定点小数的表示范围为|x|<1，如图：
![在这里插入图片描述](E:\Development\Typora\images\20200815165141607.png)
  仅当`两个符号相同的数相加或两个符号相异的数相减`才有可能产生溢出，如两个正数相加结果符号位为1，一个负数减一个正数，结果符号位为0 上面两种情况都为溢出

没有溢出：结果的补码没有超出数值位所能表示的范围

  补码定点数加减运算溢出判断的方法有3种：

- （1）采用一位符号位
  由于减法运算在机器中是用加法器实现的，因此无论是加法还是减法，==只要参加操作的两个数符号相同，结果又与原操作数不同，则表示结果溢出==
    设A的符号位As，B的符号位为Bs，运算结果的符号位Ss，则溢出逻辑表达式为：（110或001）
  ![在这里插入图片描述](E:\Development\Typora\images\20200815170035532.png)
    V=0表示无溢出，V=1表示有溢出
- （2）采用双符号位
  双符号位法也称模4补码。运算结果的两个符号位Ss1Ss2相同，表示未溢出；不同表示溢出，此时最高位符号位代表真正的符号
    符号位的各种情况：
    Ss1Ss2=00；结果为正，未溢出
    Ss1Ss2=01；结果为正，溢出
    Ss1Ss2=10；结果为负，溢出
    Ss1Ss2=11；结果为负，未溢出
    溢出逻辑表达式为：![在这里插入图片描述](E:\Development\Typora\images\20200815170707295.png)
    V=1溢出，V=0无溢出

------

>  采用双符号位时，寄存器或主存中的操作数只需保存1位符号位即可。因为任何正确的数，两个符号位的值总是相同的，而双符号位在加法器中又是必要的，故在相加时，寄存器中1位符号的值要送到加法器的两个符号位的输入端
>

------

- （3）采用一位符号位根据数据位的进位情况判断溢出
  若符号位的进位Cs与最高位的进位C1相同，则说明没有溢出，否则有溢出。溢出的逻辑判断表达式为![在这里插入图片描述](E:\Development\Typora\images\20200815171041579.png)
    V=1有溢出，V=0无溢出

#####   6.定点数的乘法运算

  乘法操作由累加和右移操作实现。根据机器数的不同，可分为原码一位乘法和补码一位乘法。

- （1）原码一位乘法
  原码一位乘法的特点是符号位与数值位是分开求的，乘积符号由两个数的符号位异或形成，而乘积的数值部分是两个数的绝对值相乘之积。
    设[X]原=xs.x1x2…xn，[Y]原=ys.y1y2…yn，运算规则如下：
    a. 被乘数与乘数均取绝对值参与运算，结果符号位为两个符号位的异或
    b.部分积的长度同被乘数，取n+1位，以便存放乘法过程中绝对值大于等于1的值（进位时最高位改变的情况），初值为0
    c.从乘数的最低位yn开始判断：若yn=1，则部分积加上被乘数|x|，然后右移一位；若yn=0，则部分积加上0，然后右移一位.部分积右移一位的同时，乘数也右移一位，由次低位作为新的末位，空出最高位放部分积的最低位（每次做加法时，被乘数仅与原部分积的高位相加，其低位被移至乘数所空出的高位位置）
    d.重复步骤c，判断n次
    由于乘积的数值部分是两数绝对值相乘的结果，因此原码一位乘法运算过程中的右移操作均为逻辑右移

------

考虑到运算时可能出现绝对值大于1的情况（进位时最高位改变的情况，但此刻并非溢出；若取单个符号位，最高位改变可能被当成溢出处理），所以部分积和被乘数取双符号位

------

  例：设机器字长为5位（含一位符号位，n=4），x=-0.1101,y=0.1011，采用原码一位乘法求x*y
  |x|=00.1101，|y|=00.1011
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16626840248379.png)
  符号位为1，得x * y=-0.10001111

------

  原码一位乘运算的基本硬件配置框图如下：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166268402483710.png)
  图中A、X、Q均为n+1位的寄存器，其中X存放被乘数的原码，Q存放乘数的原码。移位和加控制电路受末位乘数Qn的控制（当Qn=1时，A和X内容相加后，A、Q右移一位；当Qn=0时，只作A、Q右移一位的操作）。计数器C用于控制逐位相乘的次数。S存放乘积的符号。GM为乘法标记
  原码一位乘控制流程如图：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166268402483711.png)
  乘法运算前，A寄存器被清零，作为初始部分积，被乘数原码在X中，乘数原码在Q中，计数器C中存放乘数的位数n。乘法开始后，首先通过异或运算，求出乘积的符号并存于S，接着将被乘数和乘数从原码形式变为绝对值。然后根据Qn的状态决定部分积是否加上被乘数，再逻辑右移一位，重复n次。

------

------

  例题：在原码一位乘法中，（）
  A.符号位参加运算
  B.符号位不参加运算
  C.符号位参加运算，并根据运算结果改变结果中的符号位
  D.符号位不参加运算，并根据运算结果确定结果中的符号

  答案：B；在原码一位乘中，符号位不参加运算，符号位单独处理

------

- （2）补码一位乘法（Booth算法）
  这是一种有符号数的乘法，采用相加和相减操作计算补码数据的乘积。
    设[X]补=xs.x1x2…xn，[Y]补=ys.y1y2…yn，运算规则如下：
    a.符号位参与运算，运算的数均以补码表示
    b.被乘数一般取双符号位参与运算，部分积取双符号位，初值为0，乘数可取单符号位
    c.乘数末位增设附加位yn+1，且初值为0
    d.根据（yn，yn+1）的取值来确定操作
  ![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166268402483712.png)
    e.移位按补码右移规则进行
    f.按照上述算法进行n+1步操作，但第n+1步不再移位（共进行n+1次累加和n次右移），仅根据yn与yn+1的比较结果做相应的计算
    例：设机器字长为5位（含一位符号位，n=4)，x=-0.1101，y=0.1011，采用Booth算法求x*y
    [x]补=11.0011，[-x]补=00.1101，[y]补=0.1011
  ![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166268402483713.png)
    [x * y]补=1.01110001,x * y=-0.10001111
- （3）乘法运算总结
  ![在这里插入图片描述](E:\Development\Typora\images\20200815210158524.png)

#####   7.定点数的除法运算

  笔算除法的右移除数可以用左移余数的方法代替，最后得到的余数乘上2-n才是真正的余数；笔算除法求商是从高位向低位求的，转换为将每一位商写到寄存器的最低位，并把原来的部分商左移一位。
  除法运算可转换成累加——左移（逻辑左移），根据机器数的不同，可分为原码除法和补码除法

- （1）原码除法运算（不恢复余数法）
  原码除法主要采用原码不恢复余数法，也称原码加减交替除法。特点是商符和商值是分开进行的，商符由两个操作数的符号位异或形成。求商值的规则如下：
     设被除数[X]原=xs.x1x2…xn，除数[Y]原=ys.y1y2…yn，则
     a.商的符号![Qs=xs](E:\Development\Typora\images\20200815211446437.png)
     b.商的数值：|Q|=|X|/|Y|
     求|Q|的不恢复余数法运算规则如下：
     a.符号位不参与运算
     b.先用被除数减去除数（|X|-|Y|=|X|+（-|Y|）=|X|+[-|Y|]补），当余数为正时，商上1，余数和商左移一位，再减去除数；当余数为负时，商上0，余数和商左移一位，再加上除数。
     c. 当第n+1步余数为负时，需加上|Y|得到第n+1步正确的余数（余数与被除数同号）
    例：设机器字长为5位（含一位符号位，n=4），x=0.1011，y=0.1101,采用原码加减交替除法求x/y
    |x|=0.1011，|y|=0.1101，[|y|]补=0.1101,[-|y|]补=1.0011
  ![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166268402483714.png)
    Qs=0,得x/y=+0.1101，余0.0111 x 2-4
- （2）补码除法运算（加减交替法）
  补码一位除法的特点是，符号位与数值位一起参与运算，商符自然形成。除法第一步根据被除数和除数的符号决定是做加法还是减法；上商的原则根据余数和除数的符号位共同决定，同号上商1，异号上商0；最后一步商恒置1。
    加减交替法的规则如下：
    a.符号位参与运算，除数与被除数均用补码表示，商和余数也用补码表示
    b.若被除数与除数同号，则被除数减去除数；若被除数与除数异号，则被除数加上除数。
    c.若余数与除数同号，则商上1，余数左移1位减去除数；若余数与除数异号，则商上0，余数左移一位加上除数
    d.重复执行c操作n次
    e.若对商的精度没有特殊要求，则一般采用末位恒置1法
    例：设机器字长为5位（含一位符号位，n=4），x=0.1000，y=-0.1011,采用补码加减交替除法求x/y
    采用2位符号位，[x]原=00.1000，[x]补=00.1000，[y]原=11.1011，
  [y]补=11.0101,[-y]补=00.1011
  ![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166268402483715.png)
    得[x/y]补=1.0101，余0.0111 x 2-4
- （3）除法运算总结
  ![在这里插入图片描述](E:\Development\Typora\images\2020081522060068.png)

####  2.2.3 C语言中的整数类型及类型转换

#####   1.有符号数和无符号数的转换

```c
int main()
{
	short x=-4321;
	unsigned short y=(unsigned short)x;
	printf("x=%d,y=%u\n",x,y);
}
123456
```

  上述代码会输出x=-4321,y=61215
  x=（1110 1111 0001 1111）2，y=（1110 1111 0001 1111）2
  x为补码表示，y为无符号的二进制真值，被解释为61215。将short int 强制转换成unsigned short 只改变数值，而两个变量对应的每一位都是一样的。强制类型转换的结果保持位值不变，仅改变了解释这些位的方式。

```c
int main()
{
	unsigned short x=65535;
	short y=(short)x;
	printf("x=%u,y=%d\n",x,y);
}
123456
```

  输出x=65535,y=-1

#####   2.不同字长整数之间的转换

```c
int main()
{
	int x=165537,u=-34991;			//int型占用4B
	short y=(short)x,v=(short)u;    //short型占用2B
	printf("x=%d,y=%d\n",x,y);
	printf("u=%d,v=%d\n",u,v);
}
1234567
```

  输出x=165537,y=-31071,u=-34991,v=30545
  其中x、y、u、v的16进制表示分别为0x000286a1、0x86a1、0xffff7751、0x7751。当大字长变量向小字长变量强制类型转换时，系统把多余的高位字长部分直接截断，低位直接赋值。

```c
int main()
{
	short x=-4321;
	int y=x;
	unsigned short u=(unsigned short)x;
	unsigned int v=u;
	printf("x=%d,y=%d\n",x,y);
	printf("u=%u,v=%u\n",u,v);
}
123456789
```

  输出x=-4321，y=-4321，u=61215,v=61215
  x、y、u、v的16进制表示分别是0xef1f、0xffffef1f、0xef1f、0x0000ef1f;
  短字长整数到长字长整数的转换，不仅要使对应的位值相等，高位部分还会扩展为原数字的符号位。（短字长到长字长的转换，在位值相等的条件下还要补充高位的符号位，转换后所表示的数值与原数值一样）

------

  char类型为8位ASCII码整数，其转换为int时，在高位部分补0即可

------

------

  `例题`：一个C语言程序在一台32位机器上运行。程序中定义了三个变量xyz，其中x和z为int型，y为short型。当x=127，y=-9时，执行语句z=x+y后，xyz的值分别是（）

  答案：x=0000007FH,y=FFF7H,z=00000076H,y将被强制转换为int型，扩充的位数用1填补

  `例题`：假定在一个8位字长的计算机中运行如下C程序段：

```c
unsigned int x=134;
unsigned int y=246;
int m=x;
int n=y;
unsigned int z1=x-y;
unsigned int z2=x+y;
int k1=m-n;
int k2=m+n;
12345678
```

  （1）执行上述程序段后，变量m和k1的值分别是多少（用10进制表示）
  （2）上述程序段涉及有符号整数加减、无符号整数加减运算，这四种运算能否利用同一个加法器辅助电路实现？简述理由
  （3）计算机内部如何判断有符号整数加减运算的结果是否发生溢出？上述程序段中，哪些有符号整数运算语句的执行结果会发生溢出

  答案：（1）m=-122,k1=-112;
  （2）能。n位加法器实现的是模2n无符号整数加法运算。对于无符号整数a和b，a+b可直接用加法器实现，而a-b可用a加b的补数实现，即
  a-b=a+[-b]补（mod 2n），所以n位无符号整数加减运算都可在n位加法器中实现。由于有符号整数用补码表示，补码加减运算公式为
  [a+b]补=[a]补+[b]补（mod 2n）;[a-b]补=[a]补+[-b]补（mod 2n）,所以n位有符号整数加减运算都可在n位加法器中实现
  （3）有符号整数加减运算的溢出判断规则为：若加法器的两个输入端（加法）的符号相同，且不同于输出端（和）的符号，则结果溢出，或加法器完成加法操作时，若次高位（最高数位）的进位和最高位（符号位）的进位不同，则结果溢出
  有符号整数运算语句中，int k2=m+n会溢出

  例题：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166268402483716.png)
  答案：（1）n=0时，n-1的机器数为全1，值为unsigned类型可表示的最大数，循环判断条件永真。若都定义为int型，不会死循环，n-1=-1，当i=0时循环判断条件不成立，循环退出
  （2）相等，各为00FFFFFFH，4B7FFFFFH；
  （3）float型数只有24位有效位，舍入后数值增大，所以比f1(24)大1
  （4）得到的sum的机器数为全1，作为int型解释时为-1。最大n值是30
  （5)对应的值是无穷大，不溢出的最大n为126，不舍入的最大n为23

------

####  2.2.4 数据的存储和排列

#####   1.数据的大端方式和小端方式存储

  在存储数据时，数据从低位到高位可按从左至右排列，也可按从右到左排列。通常用最低有效字节（LSB）和最高有效字节（MSB）来分别表示数的低位和高位。例如，在32位计算机中，一个int型变量i的机器数为01 23 45 67H，其最高有效字节MSB=01H，最低有效字节LSB=67H。

  现代计算机基本上都采用字节编址，即每个地址编号中存放1字节。不同类型的数据占用的字节数不同，int和float型数据占4B，double型数据占8B，而程序中对每个数据只给定一个地址。
  多字节数据都存放在连续的字节序列中，根据数据中各字节在连续字节序列中的排列顺序不同，可采用两种排列方式：大端方式（big endian）和小端方式(little endian)
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166268402483717.png)
  

> ​	大端方式按从最高有效字节到最低有效字节的顺序存储数据，即最高有效字节存放在前面；
>
> ​	小端方式按从最低有效字节到最高有效字节的顺序存储数据，即最低有效字节存放在前面。

  例如，反汇编得到：`4004d3: 01 05 64 94 04 08 add %eax,0x8049464`
  其中4004d3是16进制表示的地址，01 05 64 94 04 08是指令的机器代码，add %eax,0x8049464是指令的汇编形式，该指令的第二个操作数是一个立即数0x8049464。执行指令时，从指令代码的后4字节中取出该立即数，可知采用的是小端方式存储。（在小端方式存储的机器代码中，字节是按相反顺序显示的)

#####   2.数据按边界对齐方式存储

  假设存储字长为32位，可按字节、半字和字寻址。对于机器字长为32位的计算机，数据以边界对齐方式存放，半字地址一定是2的整数倍，字地址一定是4的整数倍，这样无论所取的数据是字节、半字还是字，均可一次性访存取出。所存储的数据不满足上述条件时，填充空白字节。使用这种方式浪费了一些存储空间，提高了取指令和数据的速度（空间换时间）。
  数据不按边界对齐方式存储时，可充分利用存储空间，但半字长或字长的指令可能会存储在两个存储字中，此时需2次访存，且对高低字节的位置进行调整、连接之后才能得到所要的指令或数据。
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166268402483718.png)

### 2.3 浮点数的表示与运算

####  2.3.1 浮点数的表示

#####   1.浮点数的表示格式

>   **浮点数即小数点的位置能浮动的数**，通常，浮点数表示为 **N=$R^E$ x M**，`R`是浮点数阶码的底（隐含），与尾数的基数相同，通常`R=2`。E和M都是有符号的定点数`，E称为阶码，M称为尾数`。浮点数由阶码和尾数两部分组成。

![在这里插入图片描述](E:\Development\Typora\images\20200816091606135.png)

- `阶码是整数`，阶符 $J_f$ 和 阶码的位数 m 共同反映浮点数的表示范围及小数点的实际位置；
- 数符$S_f$代表浮点数的符号；
- 尾数的位数`n`反映浮点数的精度；
- 基数`R`越大，可表示的浮点数范围越大，所表示的数的个数越多，但浮点数精度下降

#####   2.规格化浮点数

  为提高运算的精度，需充分利用尾数的有效数位，通常采取`浮点数规格化形式`，<font color='green'>即规定尾数的最高数位必须是一个有效值</font>。非规格化浮点数需要进行**规格化操作**才能变成规格化浮点数。

> ​	规格化操作即指通过调整一个非规格化浮点数的`尾数`和`阶码`的大小，**使非0的浮点数在尾数的最高数位上保证是一个有效值。**

  **左规**：==将尾数算术左移一位、阶码减1（基数为2时）的方法称为左规，左规可能要进行多次。==
  **右规**：当浮点数运算的结果尾数出现溢出（双符号位为01或10）时，将尾数算术右移一位，阶码加1（基数为2时）的方法称为右规。需要右规时，只需进行一次。
  规格化浮点数的**尾数M**的绝对值应满足条件 `1/R<=|M|<=1`。

----

**若R=2,则有1/2<=|M|<=1。**
  规格化表示的尾数形式如下：

- （1）原码规格化后
  - 正数为**`0.1xx…x`**的形式，其最大值表示为0.11…1，最小值表示为0.100…0。尾数的表示范围为`1/2<=M<=(1-2-n)。`
  - 负数为**`1.1xx…x`**的形式，其最大值表示为1.10…0，最小值表示为1.11…1。尾数的表示范围为-(1-2-n)<=M<=-1/2。

- （2）补码规格化后
  - 正数为`0.1xx…x`的形式，其最大值表示为0.11…1，最小值表示为0.100…0。尾数的表示范围为1/2<=M<=(1-2-n)。 **（正数不变）**
  - 负数为`1.0xx…x`的形式，其最大值表示为1.01…1，最小值表示为1.00…0。尾数的表示范围为-1<=M<=-(1/2+2n)。


>  当浮点数尾数的基数为2时，`原码规格化数的尾数最高位一定是1，补码规格化数的尾数最高位一定与尾数符号位相反。`

​		基数不同，浮点数的规格化形式也不同。当基数为4时，原码规格化形式的尾数最高2位不全为0，规格化时，尾数左/右移2位，阶码减/加1；当基数为8时，原码规格化形式的尾数最高3位不全为0，规格化时，尾数左/右移3位，阶码减/加1

------

  `例题`：采用规格化的浮点数最主要是为了（）
  A.增加数据的表示范围  B.方便浮点运算
  C.防止运算时数据溢出  D.增加数据的表示精度

  答案：D；

  `例题`：设浮点数共12位。其中阶码含1位阶符共4位，以2为底，补码表示；尾数含1位数符共8位，补码表示，规格化。则该浮点数所能表示的最大正数是（）

  答案：27-1;

  `例题`：已知X=-0.875 x 21，Y=0.625 x 22，设浮点数格式为阶符1位，阶码2位，数符1位，尾数3位，通过补码求出Z=X-Y的二进制浮点数规格化结果是（）

  答案：0111011；浮点数表示为：X=001 1001 Y=010 0101；
  -Y=010 1011；X的尾数部分为11.001，右规后为11.100；-Y的尾数部分为11.011，X、-Y尾数相加（运算时采用双符号位，但存储时只存储一位符号位即可），得10.111,右规得11.011（双符号位的最高符号位代表真正的符号，而低位符号位用于参与移位操作以判断是否发生溢出。双符号位设置的意义就在于用低符号位容纳最高数位产生的进位，而用高符号位表示真正的符号。双符号位10右规符号位变成11，双符号位01右规符号位变成00，10表示负溢出，右规之后还是负数，即变成11），最后的结果为0111011

  `例题`：已知十进制数x=-5/256、y=+59/1024，按机器补码浮点运算规则计算x-y，结果用二进制表示，浮点数格式如下：阶符取2位，阶码取3位，数符取2位，尾数取9位

  答案：11101,11.011000100

  `例题`：设浮点数字长32位，其中阶码部分8位（含一位阶符），尾数部分24位（含1位数符），当阶码的基值分别是2和16时：
  （1）说明基值2和16在浮点数中如何表示
  （2）当阶码和尾数均用补码表示，且尾数采用规格化形式时，给出两种情况下所能表示的最大正数真值和非零最小正数真值
  （3）在哪种基值情况下，数的表示范围大
  （4）两种基值情况下，对阶和规格化操作有何不同

  答案：（1）浮点机中一旦基值确定了就不会再改变，所以基值2和16在浮点数中是隐含表示的，并不出现在浮点数中；
  （2）r=2时，最大正数真值2127 x （1-2-23），最小正数真值2-129
  r=16时，最大正数真值16127 x （1-2-23），最小正数真值16-129（尾数数据位最高4位不全为0）
  （3）r=16时，数的表示范围大
  （4）对阶中，需要小阶向大阶看齐，基值为2的浮点数尾数右移一位，阶码加1，基值为16的浮点数尾数右移4位，阶码加1。规格化时，若为原码规格化，若基值为2的浮点数尾数最高有效位出现0，需尾数左移1位，阶码减1；当基数为16时，原码规格化形式的尾数最高4位若全为0，尾数左移4位，阶码减1

  例题：设浮点数的格式如下（阶码和尾数均用补码表示，基为2）
![在这里插入图片描述](E:\Development\Typora\images\20200817150904669.png)
  （1）将27/64转换为浮点数
  （2)将-27/64转换为浮点数

  答案：（1）1111,0110110000；（2）1111,1001010000

  `例题`：两个规格化浮点数进行加减法运算，最后对结果规格化时，能否确定需要右规的次数？能否确定需要左规的次数？

  答案：两个n位数的加减运算，其和/差最多为n+1位，因此有可能需要右规，但右规最多一次。由于异号数相加或同号数相减，其和/差的最少位数无法确定，因此左规的次数也无法确定，但最多不会超过尾数的字长n位次（正数最多n-1次，负数最多n次）。

------

#####   3.浮点数的表示范围（考研大纲中已删除）

  设阶码和尾数均用补码表示，阶码部分共K+1位（含一位阶符），尾数部分共n+1位（含一位数符），浮点数表示范围如下：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166268402483819.png)

1.   运算结果大于最大正数时称为**正上溢**，小于绝对值最大负数时称为**负上溢**，正上溢和负上溢统称上溢。数据一旦产生上溢，计算机必须`中断`运算操作，进行溢出处理。
2.   当运算结果在0至最小正数之间时称为**正下溢**，在0至绝对值最小负数之间称为负下溢，正下溢和负下溢统称下溢。数据下溢时，浮点数值趋于0，计算机将其当做机器零处理。



![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166268402483820.png)

------

  例题：什么是浮点数的溢出？什么情况下发生上溢出？什么情况下发生下溢出？

  答案：浮点数的运算结果可能出现以下几种情况：
  1.阶码上溢出。一个正指数超过了最大允许值时，浮点数发生上溢出。若结果是正数，则发生正上溢出；若结果是负数，则发生负上溢出。这种情况为软件故障，通常要引入溢出故障处理程序处理
  2.阶码下溢出。一个负指数比最小允许值还小时，浮点数发生下溢出。一般机器把下溢出时的值置为0。不发生溢出故障。
  3.尾数溢出。当尾数最高有效位有进位时，发生尾数溢出。此时进行右规，直到尾数不溢出为止。此时，只要阶码不发生上溢出，浮点数就不会溢出（运算结果超过尾数表示范围不一定溢出，只有规格化后阶码超出所能表示的范围时，才发生溢出）
  4.非规格化尾数。当数值部分高位不是一个有效值时（**如原码时为0或补码时与符号位相同**），尾数为非规格化形式。此时进行左规，直到尾数为规格化形式为止。

------

#####   4.IEEE754标准

  按照`IEEE754`标准的浮点数格式如图：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166268402483821.png)
  `IEEE754`标准规定常用的浮点数格式有**短浮点数（单精度、float型）、长浮点数（双精度、double型）、临时浮点数**
![在这里插入图片描述](E:\Development\Typora\images\20200816100220737.png)
  IEEE754标准的浮点数（除临时浮点数外），**是尾数用采取隐藏位策略的原码表示**，且阶码用`移码`表示的浮点数。
  以短浮点数为例，最高位为数符位，其后是8位阶码，以2为底，用`移码`表示，阶码的偏置值为28-1-1=127；其后23位是原码表示的尾数数值位。对于规格化的2进制浮点数，数值的最高位总是1，为了能使尾数多表示一位有效位，将这个1隐含，因此尾数数值实际上是24位。隐含的1是一位整数。在浮点格式中表示的23位尾数是纯小数。例如，（12）10=（1100）2，规格化后结果为1.1x23，其中整数部分的1将不存储在23位尾数内。（短浮点数与长浮点数都采用隐含尾数最高数位的方法，临时浮点数又称扩展精度浮点数，无隐含位)

------

  为何要用移码表示阶码：a.移码比较大小更方便；b.检验移码的特殊值时较容易
  移码即真值+偏置值。偏置值为127，而非128的原因是：指数可以为正数也可以为负数，为将负数转变为正数（为了不在阶码中引入阶符），实际的指数值要加上偏置值。
  -127~+127加上127即得到 0 ~ +254，然而阶码值E的范围为1~254，因为阶码为0时表示指数为负无穷大，整个数无穷接近于0，可将0用于表示0（尾数也为0时）或非规格化数（尾数不为0时）。为什么不加128呢？因为255为8位全1，也有特殊用途，当阶码值为255时（指数为正无穷），若尾数部分为0，则表示无穷大；若尾数部分不为0，则认为这是一个“非数值”（浮点数运算错误）

------

  阶码是以移码形式存储的。对于短浮点数，偏置值为127；对于长浮点数，偏置值为1023。存储浮点数阶码部分之前，偏置值要先加到阶码真值上。例如1.1x23，阶码值为3，在短浮点数中，移码表示的阶码为130（82H）；在长浮点数中，阶码为1026（402H）
  IEEE754标准中，规格化的短浮点数真值为：（-1）s x 1.M x 2 E-127;规格化长浮点数真值为：（-1）s x 1.M x 2 E-1023
  短浮点数E的取值为1~ 254（8位表示），M为23位，共32位；长浮点数E的取值为1~2046（11位表示），M为52位，共64位。IEEE754标准浮点数的范围为：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166268402483822.png)

------

  例题：按照IEEE754标准规定的32位浮点数（41A4C000）16对应的10进制数是（）
  A.4.59375  B.-20.59375  C.-4.59375  D.20.59375

  答案：D；

  例题：假定采用IEEE754标准中的单精度浮点数格式表示一个数为45100000H，则该数的值是（）
  A.（+1.125）10 x 210  B.（+1.125）10 x 211
  C.（+0.125）10 x 211  D.（+0.125）10 x 210

  答案：B；

  例题：已知两个实数x=-68，y=-8.25，它们在C语言中定义为float型变量，分别存放在寄存器A和B中。另外还有两个寄存器C和D。ABCD都是32位的寄存器。请问（要求用16进制表示2进制序列）x和y相减后的结果存放在D中，D中的内容是什么

  答案：IEEE754标准，x的浮点数表示为
  1 1000 0101 0001000 0000 0000 0000 0000
  即x=-1.0001 x 26
  y的浮点数表示为
  1 1000 0010 000 0100 0000 0000 0000 0000，对阶后为：
  1 1000 0101 001 0000 1000 0000 0000 0000，
  即y=-0.00100001 x 26
  进行尾数原码减法，得x-y=-0.11101111 x 26=-1.1101111 x 25，浮点表示为C26F0000H

  例题：对下列每个IEEE754单精度数值，解释它们所表示的是哪种数字类型（规格化数、非规格化数、无穷大、0）。当它们表示某个具体数值时，给出该数值。
  （1）0b0000 0000 0000 0000 0000 0000 0000 0000
  （2）0b0100 0010 0100 0000 0000 0000 0000 0000
  （3）0b1000 0000 0100 0000 0000 0000 0000 0000
  （4）0b1111 1111 1000 0000 0000 0000 0000 0000

  答案：前面的0b意思是数字的表示形式为二进制
（1）+0；（2）规格化数，25 x （1.1）2;
  （3）非规格化数，尾数首位无隐藏的整数1，阶码全0时有特殊规定为
2-126 ，因此（3）表示2-126 x （-0.1）2;
  （4）负无穷

------

#####   5.定点、浮点表示的区别

- （1）数值的表示范围
  若定点数和浮点数的字长相同，则浮点表示法所能表示的数值范围将远远大于定点表示法
- （2）精度
  精度指一个数所含有效数值位的位数。对于字长相同的定点数和浮点数来说，浮点数虽然扩大了数的表示范围，但精度降低了（要用字长的一部分表示阶码，尾数部位的有效位数减少）
- （3）数的运算
  浮点数包括阶码和尾数两部分，运算时不仅要做尾数的运算，还要做阶码的运算，而且运算结果要求规格化
- （4）溢出问题
  在定点运算中，当运算结果超出数的表示范围时，发生溢出；浮点运算中，运算结果超出尾数表示范围时不一定溢出，只有规格化后阶码超出所能表示的范围时，才发生溢出

------

  对于位数相同的定点数与浮点数，可表示的浮点数个数比定点数个数多吗？
  否，可表示的数据个数取决于编码所采用的位数。编码位数一定，编码出来的数据个数是一定的。n位编码只能表示2^n个数，所以对于相同位数的定点数与浮点数来说，可表示的数据个数应该一样多（有时可能由于一个值有2个或多个编码对应，编码个数会有少量差异）

------

####  2.3.2 浮点数的加减运算

  **阶码运算和尾数运算分开进行。浮点数的加减运算一律采用`补码`。**

#####   1.对阶

  对阶的目的是使两个操作数的小数点位置对齐，即使得两个数的阶码相等。先求阶差，然后以`小阶向大阶看齐`的原则，将阶码小的尾数右移一位（基数为2），阶加1，直到两个数的阶码相等为止。尾数右移时，舍弃掉有效位会产生误差，影响精度

#####   2.尾数求和

  将对阶后的尾数按定点数加减运算规则计算

#####   3.规格化

  以双符号位为例，当尾数大于0时，其补码规格化形式为：
   `[S]补=00.1xx…x`
  当尾数小于0时，其补码规格化形式为：
   `[S]补=11.0xx…x`
  当尾数的最高数值位与符号位不同时，即为规格化形式。规格化分为左规和右规

- （1）左规
  当尾数出现00.0xx…x或11.1xx…x时，需左规，尾数左移一位，阶码减1，直到尾数为00.1xx…x或11.0xx…x
- （2）右规
  当尾数求和结果溢出（如尾数为10.xx…x或01.xx…x）时，**需右规，尾数右移1位，阶码加1**

#####   4.舍入

  在对阶和右规的过程中（进行了右移），可能会将尾数低位丢失，引起误差。常见的舍入方法有：`0舍1入法和恒置1法`

- **0舍1入法**：类似于4舍5入，尾数右移时，被移去的最高数值位为0，则舍去；被移去的最高数值位为1，则在尾数的末位加1。这样做可能会使尾数再一次溢出，此时需再做一次右规。
- **恒置1法**：尾数右移时，都使右移后的尾数末位恒置1，此方法有使尾数变大和变小（尾数为负时）两种可能。

#####   5.溢出判断

   当尾数之和（差）出现10.xx…x或01.xx…x时，并不表示溢出，需将此数右规后，根据阶码判断结果是否溢出

>  浮点数溢出与否是由阶码的符号决定的。以双符号位补码为例，当阶码的符号位出现01时，即阶码大于最大阶码，表示上溢，进入中断处理；当阶码的符号位出现10时， 阶码小于最小阶码，表示下溢，按机器零处理。

------

  `例题`：浮点数加、减运算过程一般包括对阶、尾数运算、规格化、舍入和判断溢出等步骤。设浮点数的阶码和尾数均采用补码表示，且位数分别为5和7（均含2位符号位）。若有两个数X=27x29/32和Y=25x5/8，则用浮点加法计算X+Y的最终结果是（）
  A.00111 1100010  B.00111 0100010  C.01000 0010001  D.溢出

  答案：D；

  `例题`：下列关于对阶操作说法正确的是（）
  A.在浮点加减运算的对阶操作中，若阶码减小，则尾数左移
  B.在浮点加减运算的对阶操作中，若阶码增大，则尾数右移；若阶码减小，则尾数左移
  C.在浮点加减运算的对阶操作中，若阶码增大，则尾数右移
  D.以上都不对

  答案：C；对阶操作，是将小的阶码调整到与大的阶码一致（小的向大的对齐），只可能尾数右移，因此不存在阶码减小，尾数左移的情况

  `例题`：下列关于舍入的说法，正确的是（）
  1.不仅仅只有浮点数需要舍入，定点数在运算时也可能要舍入
  2.在浮点数舍入中，只有左规时可能要舍入
  3.在浮点数舍入中，只有右规时可能要舍入
  4.在浮点数舍入中，左右规格化均可能要舍入
  5.舍入不一定产生误差

  答案：5；舍入是浮点数的概念，定点数没有舍入的概念；浮点数舍入的情况有2种：对阶（对阶时需要尾数右移）与右规；舍入不一定产生误差

------

#####   6.C语言中的浮点数类型及类型转换

   C语言中的float和double类型分别对应于IEEE754单精度浮点数和双精度浮点数。long double类型对应于扩展双精度浮点数，但其长度和格式随编译器和处理器类型的不同而不同。在C程序中等式的赋值和判断中会出现强制类型转换，以`char->int->long->double`和`float->double`最为常见，从前到后范围和精度都从小到大，转换过程中没有损失。

- （1）从int转换为float时，虽然不会发生溢出，但int可以保留32位，float保留24位（尾数+隐含位），可能有数据舍入，若从int转换为double则不会出现
- （2）从int或float转换为double时，由于double的有效位数更多，因此能保留精确值
- （3）从double转换为float时，由于float表示范围更小，因此可能发生溢出，由于有效位数变少，可能被舍入
- （4）从float或double转换为int时，因为int没有小数部分，所以数据可能会向0方向被截断（仅保留整数部分），影响精度，由于int的表示范围更小，可能发生溢出

### 2.4 算术逻辑单元（ALU）

   运算器由算术逻辑单元ALU、累加器、状态寄存器和通用寄存器组等组成。ALU的基本功能包括加减乘除四则运算，与或非，异或等逻辑运算，以及移位、求补等操作。
   运算器的操作和操作种类由控制器决定。运算器处理的数据来自存储器；处理后的结果数据通常送回存储器，或暂存在运算器中。

####  2.4.1 串行加法器和并行加法器

  加法器是由全加器再配以其他必要的逻辑电路组成的，根据组成加法器的全加器个数是单个还是多个，加法器有串行和并行之分。

#####   1.一位全加器

  全加器（FA）是最基本的加法单元，有加数Ai、加数Bi与低位传来的进位Ci-1共三个输入，有本位和Si与向高位的进位Ci共两个输出。
  全加器的逻辑表达式如下：
![在这里插入图片描述](E:\Development\Typora\images\20200816145105731.png)
  一位全加器的逻辑结构和逻辑符号为：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166268402483823.png)

#####   2.串行加法器

  在串行加法器中，有一个全加器，数据逐位串行送入加法器中进行运算。若操作数长n位，则加法就要分n次进行，每次产生1位和，并且逐行地送回寄存器。进位触发器用来寄存进位信号，以便参与下一次运算。

#####   3.并行加法器

  并行加法器由多个全加器组成，其位数与机器的字长相同，各位数据同时运算。并行加法器可同时对数据的各位相加。虽然操作数的各位是同时提供的，但低位运算所产生的进位会影响高位的运算结果，并行加法器的最长运算时间主要是由进位信号的传递时间决定的，而每个全加器本身的求和延迟只是次要因素。
  提高并行加法器速度的关键是尽量加快进位产生和传递的速度
  并行加法器的进位产生和传递如下：
  并行加法器中的每个全加器都有一个从低位送来的进位输入和一个传送给高位的进位输出。通常将传递进位信号的逻辑线路连接起来构成的进位网络称为进位链。
  进位表达式为：
  Ci=Gi+PiCi-1（Gi=1或PiCi-1=1时，Ci=1）
  Gi是进位产生函数，Gi=AiBi；Pi是进位传递函数，Pi=Ai⨁ \bigoplus⨁Bi

------

  当Ai与Bi都为1时，Ci=1，即有进位信号产生，所以将AiBi称为进位产生函数或本地进位，并以Gi表示。Ai⨁ \bigoplus⨁Bi=1且Ci-1=1时，Ci=1。这种情况可视为第i-1位的进位信号Ci-1可通过本位向高位传送，因此，把Ai⨁ \bigoplus⨁Bi称为进位传递函数（进位传递条件），并以Pi表示

------

  并行加法器的进位通常分为串行进位与并行进位

- （1）串行进位
  把n个全加器串接起来，就可以进行2个n位数的相加，这种加法器称为串行进位的并行加法器，串行进位又称行波进位，每级进位直接依赖于前一级的进位，即进位信号是逐级形成的。
  ![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166268402483824.png)
    并行加法器的最长运算时间主要是由进位信号的传递时间决定的，位数越多延迟时间就越长，而全加器本身的求和延迟为次要因素。
- （2）并行进位
  并行进位又称先行进位、同时进位，其特点是各级进位信号同时形成。
    采用并行进位的方式可加快进位产生和传递的速度，即将各级低位产生的本级G和P信号依次同时送到高位各全加器的输入，以使它们同时形成进位信号，各进位信号表达式如下：
  ![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166268402483825.png)
    上述各式中所有的进位输出仅由Gi、Pi及最低进位输入C0决定，而不依赖于其低位的进位输入Ci-1，因此各级进位输出可同时产生。
    这种进位方式是快速的，与字长无关。但随加法器位数增加，电路结构会很复杂。实际情况下可采用分组并行进位方式，把n位全加器分为若干小组，小组内的各位之间实行并行快速进位，小组与小组之间可采用串行进位方式，也可采用并行快速进位方式。有以下两种情况：
- a.单级先行进位方式（单重分组跳跃进位），又称组内并行、组间串行进位方式。以16位加法器为例，可分为4组，每组4位。第一小组组内的进位逻辑函数C1C2C3C4是同时产生的，实现上述进位逻辑的电路称为4位先行进位电路CLA。利用4位CLA电路及进位产生/传递电路和求和电路可构成4位CLA加法器。用4个这样的CLA加法器构成的16位单级先行进位加法器如图所示：
  ![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166268402483826.png)
- b.多级先行进位方式，又称组内并行、组间并行进位方式。仍以16位字长的加法器为例，分析两级先行进位加法器的设计方法。第一小组的进位输出C4可以写为：

![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166268402483927.png)
  这种电路称为成组先行进位电路（BCLA）。利用这种4位的BCLA电路及进位产生与传递电路和求和电路可构成4位BCLA加法器。16位的两级先行进位加法器可由4个BCLA加法器和1个CLA电路构成：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166268402483928.png)

####  2.4.2 算术逻辑单元的功能和结构

  ALU的基本结构为：

![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166268402483929.png)
  Ai和Bi为输入变量；Ki为控制信号，Ki的不同取值可决定该电路做哪种算术运算或逻辑运算；Fi为输出函数。
  典型的4位ALU芯片74181外特性如下：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166268402483930.png)
  M的值用来区分算术运算（M=0）和逻辑运算（M=1），S3~S0的不同取值可实现不同的操作。74181为4位并行加法器，其4位进位是同时产生的，用4片74181芯片可组成16位ALU，其片内进位是快速的，但片间进位是逐片传递的，即组内并行（74181片内）、组间串行（74181片间），如图：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166268402483931.png)
  若把16位ALU中的每4位作为一组，即将74181芯片与74182芯片（先行进位芯片）配合，用类似位间快速进位的方法来实现16位ALU（4片ALU组成），则能得到16位的两级先行进位ALU，即组内并行（74181片内）、组间并行（74181片间），如图：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166268402483932.png)

------

  例题：在串行进位的并行加法器中，影响加法器运算速度的关键因素是（）
  A.门电路的级延迟  B.元器件速度  C.进位传递延迟  D.各位加法器速度的不同

  答案：C；

  例题：组成一个运算器需要多个部件，但下面的（）不是组成运算器的部件
  A.状态寄存器  B.数据总线  C.ALU  D.地址寄存器

  答案：D；数据总线供ALU与外界交互数据使用，地址寄存器不属于运算器，而属于存储器



## 3.存储系统

### 3.1 存储器概述

####  3.1.1 存储器的分类

#####   1.按在计算机中的作用（层次）分类

- （1）主存储器
  简称**主存**，又称[内存](https://so.csdn.net/so/search?q=内存&spm=1001.2101.3001.7020)储器（内存），用来存放计算机运行期间所需的大量程序和数据，CPU可直接随机地对其进行访问，也可以和高速缓冲存储器（Cache）及辅助存储器交换数据。**其特点是容量较小、存取速度较快、每位价格较高。**
- （2）辅助存储器
  简称辅存，又称外存储器（外存），是主存的后援存储器，用来存放当前暂时不用的程序和数据，以及一些需要永久性保存的信息，它不能与CPU直接交换信息。其特点是容量极大、存取速度较慢、单位成本低。
- （3）高速缓冲存储器
  简称Cache，**位于主存和CPU之间**，用来存放正在执行的程序段和数据，以便CPU能高速地使用它们。Cache的存取速度可与CPU的速度相匹配，但存储容量小、价格高。目前的高档计算机通常将它们制作在CPU中

#####   2.按存储介质分类

  按存储介质，存储器可分为磁表面存储器（磁盘、磁带）、磁心存储器、半导体存储器（MOS型存储器、双极型存储器）和光存储器（光盘）

#####   3.按存取方式分类

- （1）**随机存储器**（RAM）。==存储器的任何一个存储单元的内容都可以随机存取，而且存取时间与存储单元的物理位置无关==。主要用作主存或高速缓冲存储器。 

  - RAM又分为静态RAM（以触发器原理寄存信息）和动态RAM（以电容充电原理寄存信息）

- （2）**只读存储器ROM**。==存储器的内容只能随机读出而不能写入。信息一旦写入存储器就固定不变，即使断电，内容也不会丢失。== 通常用它存放固定不变的程序、常数和汉字字库，甚至用于OS的固化。它与随机存储器可共同作为主存的一部分，统一构成主存的地址域。

  - 由ROM派生出的存储器也包含可反复重写的类型，广义上的ROM已可通过电擦等方式进行写入，但其写入速度比读取速度慢得多。

- （3）**串行访问存储器**。对存储单元进行读写操作时，需按其物理位置的先后顺序寻址，包括顺序存取存储器（如磁带）与直接存取存储器（如磁盘）

  顺序存取存储器的内容只能按某种顺序存取，存取时间的长短与信息在存储体上的物理位置有关。直接存取存储器既不像RAM那样随机地访问任何一个存储单元，又不像顺序存取存储器那样完全按顺序存取，而是介于两者之间。存取信息时通常先寻找整个存储器中的某个小区域（如磁盘上的磁道），再在小区域内顺序查找。

#####   4.按信息的可保存性分类

- 断电后，存储信息即消失的存储器，称为**易失性存储器**，如RAM。
- 断电后信息仍然保持的存储器，称为**非易失性存储器**，如ROM、磁表面存储器和光存储器。
- 若某个存储单元所存储的信息被读出时，原存储信息被破坏，则称为**破坏性读出**。
- 若读出时，被读单元原存储信息不被破坏，则称为**非破坏性读出**。具有破坏性读出性能的存储器，每次读出操作后，必须紧接一个再生的操作，以便恢复被破坏的信息。

####  3.1.2 存储器的性能指标

  存储器有3个主要性能指标，即**存储容量、单位成本、存储速度。**

（1）存储容量=存储字数x字长（如1M x 8位）。存储字数表示存储器的地址空间大小，字长表示一次存取操作的数据量。

（2）单位成本：每位价格=总成本/总容量

（3）存储速度：数据传输率=数据的宽度/存储周期



- a.存取时间（Ta）：存取时间又称存储器的访问时间（Memory Access Time），是指从启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间。（读出时间是指从主存接收到有效地址开始到数据稳定为止的时间，写入时间是指从主存接收到有效地址开始到数据写入被写单元为止的时间）
- b.存取周期（Tm）：存取周期又称读写周期或访问周期。它是指存储器进行一次完整的读写操作所需的全部时间，即连续两次独立访问存储器操作（读或写操作）之间所需的最小时间间隔 （存取周期=存取时间+恢复时间）  
- c.主存带宽（Bm）：主存带宽又称数据传输率，表示每秒从主存进出信息的最大数量，单位为字/秒、字节/秒或位/秒。
  存取时间不等于存储周期，通常存储周期大于存取时间。这是因为对任何一种存储器，在读写操作之后，总要有一段恢复内部状态的复原时间。对于破坏性读出的存储器，存取周期往往比存取时间大得多，因为存储器中的信息读出后需要马上进行再生。
  ![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638931217001.png)

------

  一个操作数在内存中可能占多个单元，如何在指令中给出操作数的地址？
  ==现代计算机都采用字节编址方式，即一个内存单元只能存放一字节的信息==。一个操作数可能占用1、2、4、8个内存单元。也即一个操作数可能有多个内存地址对应。

>     有两种不同的地址指定方式：大端方式与小端方式
>     大端方式：指令中给出的地址是操作数最高有效字节所在的地址
>     小端方式：指令中给出的地址是操作数最低有效字节所在的地址

  主存中存储单元地址的分配：
  主存各存储单元的空间位置是由单元地址号来表示的，而地址总线是用来指出存储单元地址号的，根据该地址可读出或写入一个存储字。通常计算机系统既可按字寻址，也可按字节寻址。例如IBM370的字长为32位，它可按字节寻址，即它的每个存储字包含4个可独立寻址的字节，其地址分配如图：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638931217002.png)
  字地址是用该字**高位字节**的地址来表示，故其字地址是4的整数倍 ，正好用地址码的末二位来区分同一字的4个字节的位置。但对PDP-11机而言，其字长为16位，字地址是2的整数倍，它用低位字节的地址来表示字地址：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638931217013.png)

------

### 3.2 存储器的层次化结构

####  3.2.1 多级存储系统

![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638931217014.png)
  存储系统层次结构主要体现在**Cache-主存层次**和**主存-辅存层次**。

- 前者主要解决CPU与主存速度不匹配的问题，后者主要解决存储系统的容量问题。

> （主存与Cache之间的信息调度功能全部由硬件自动完成。而主存与辅存层次的调度目前广泛采用虚拟存储技术实现）在存储体系中，Cache、主存能与CPU直接交换信息，辅存则要通过主存与CPU交换信息；主存与CPU、Cache、辅存都能交换信息。

![在这里插入图片描述](E:\Development\Typora\images\20200817204609437.png)
  存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。从CPU角度看，Cache-主存层次速度接近于Cache，容量和价位却接近于主存。从主存-辅存层次分析，其速度接近于主存，容量和价位却接近于辅存。主存和Cache之间的数据调动是由硬件自动完成的，对所有程序员均是透明的；而主存和辅存之间的数据调动则是由硬件和OS共同完成的，对应用程序员是透明的。
  在Cache-主存和主存-辅存层次中，上一层中的内容都只是下一层中内容的副本，也即Cache（或主存）中的内容只是主存（或辅存)中内容的一部分。
  在主存-辅存这一层次的不断发展中，逐渐形成了虚拟存储系统，在这个系统中程序员编程的地址范围与虚拟存储器的地址空间相对应。 对具有虚存的计算机系统而言，编程时可用的地址空间远大于主存空间。

------

  `例题`：CPU执行一段程序时，Cache完成存取的次数为1900，主存完成存取的次数为100，已知Cache存取周期为50ns，主存存取周期为250ns。设主存与Cache同时访问。
  （1）Cache/主存系统的效率是多少；（2）平均访问时间是多少

  答案：平均访问时间=60ns；Cache-主存系统的效率=访问Cache的时间/平均访问时间=83.3%

------

### 3.3 半导体随机存储器

  主存由DRAM实现，靠处理器的那一层（Cache）由SRAM实现，它们都属于易失性存储器。DRAM的每bit成本低于SRAM。

####  3.3.1 SRAM和DRAM

#####   1.SRAM的工作原理

  通常把存放`一个`二进制位的物理器件称为**存储元**（床位），它是存储器的最基本的构件。地址码相同的多个存储元构成一个**存储单元**（房间）。若干存储单元的集合构成存储体。当对某个基本单元电路进行读/写操作时，必须被行、列地址共同选中。
  静态随机存储器SRAM的存储元是用双稳态触发器（六晶体管MOS）来记忆信息的，因此即使信息被读出后，它仍保持其原状态而不需要再生（非破坏性读出)。
  SRAM的存取速度快，但集成度低，功耗较大，所以一般用来组成高速缓冲存储器。

#####   2.DRAM的工作原理

  动态随机存储器DRAM是利用存储元电路中栅极电容上的**电荷来存储信息的**，DRAM的基本存储元通常只使用一个晶体管，所以它比SRAM的密度要高很多。DRAM采用地址复用技术，地址线是原来的1/2，且地址信号分行、列两次传送。
  **DRAM的存取速度比SRAM慢，一般用来组成大容量主存系统。**
  DRAM电容上的电荷一般只能维持1~2ms，因此即使电源不断电，信息也会自动消失。为此，==每隔一定时间必须刷新，通常取2ms，这个时间称为`刷新周期`。==

​		刷新的过程实质上是先将原存信息读出，再由刷新放大器形成原信息并重新写入的再生过程。刷新是一行行进行的。常用的刷新方式有3种：集中刷新、分散刷新、异步刷新。

-   注意刷新与重写的区别：
    -   **重写**：破坏性读出后重写，以恢复原来的信息。 
    -   **刷新**：非破坏性读出的动态M，需补充电荷以保持原来的信息。 

-   对整个存储器来说，各芯片可以同时刷新
-   对每块DRAM芯片，**是按行刷新**，为一个刷新周期

  （1）`集中刷新`：指在一个刷新周期内，利用一段固定的时间，依次对存储器的所有行进行逐一再生，在此期间停止对存储器的读写操作，称为死时间，又称访存死区。

2ms内集中安排**所有**刷新周期。

刷新周期数= 最大容量芯片的行数

![image-20221215234539162](E:/Development/Typora/images/image-20221215234539162-1676545436508-1.png)

> 集中刷新的优点是读写操作时不受刷新工作的影响，因此系统的存取速度较高；
>
> 缺点是在集中刷新期间（死区）不能访存。

（2）`分散刷新`：把对每行的刷新分散到各个工作周期中。 一个存储器的系统工作周期分为两部分：前半部分用于正常读、写或保持；后半部分用于刷新某一行。这种刷新方式增加了系统的存取周期。

![image-20221215234612743](E:/Development/Typora/images/image-20221215234612743-1676545459404-3.png)

> 分散刷新的优点是没有死区；缺点是加长了系统的存取周期。
>
> 各刷新周期分散安排在存取周期中。

（3）异步刷新（用在大多数计算机中）

  （3）`异步刷新`：异步刷新是前两种方法的结合，它既可以缩短死时间，又能充分利用最大刷新间隔为2ms的特点。具体做法是将刷新周期除以行数，得到两次刷新操作之间的时间间隔t，利用逻辑电路每隔时间t产生一次刷新请求。 这样可以避免使CPU连续等待过长时间，而且减少了刷新次数。
  若将刷新安排在不需要访问存储器的译码阶段，则既不会加长存取周期，又不会产生死时间，这是分散刷新方式的发展，也称透明刷新

各刷新周期**分散**安排在2ms内。

每隔一段时间刷新一行。

![image-20221215234703186](E:/Development/Typora/images/image-20221215234703186-1676545540160-5.png)DRAM刷新对CPU是透明的，即刷新不依赖于外部的访问； DRAM的刷新单位是行，刷新操作仅需要行地址；刷新类似于读操作，但又有所不同，刷新操作仅给栅极电容补充电荷，不需要信息输出。此外，刷新时不需要选片，即整个存储器中的所有芯片同时被刷新。

#####   3.存储器的读、写周期

> -   片选端$CS^*$ 或$CE^*$
>     -   有效时，可以对该芯片进行读写操作
> -   输出$OE^*$
>     -   控制**读操作**。有效时，**芯片内数据输出**
>     -    该控制端对应系统的读控制线
> -   写$WE^*$
>     -    控制**写操作**。有效时，**数据进入芯片中**
>     -   该控制端对应系统的写控制线

![image-20221216001345195](E:/Development/Typora/images/image-20221216001345195-1676545999355-7.png)

- （1）RAM的读周期
  从给出有效地址开始，到读出所选中单元的内容并在外部数据总线上稳定地出现所需的时间，称为读出时间（tA）。地址片选信号$\overline{CS}$必须保持到数据稳定输出，tCO为片选的保持时间，在读周期中$\overline{WE}$为高电平。
  ![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638931217015.png)
    读周期与读出时间是两个不同的概念，读周期时间（tRC)表示存储芯片进行两次连续读操作时所必须间隔的时间，它总是大于等于读出时间。
- （2）RAM的写周期
  要实现写操作，要求片选信号 $\overline{CS}$和写命令信号$\overline{WE}$必须都为低电平。为使数据总线上的信息能够可靠地写入存储器，要求$\overline{CS}$信号与 $\overline{WE}$信号相"与"的宽度至少为tw
    为保证在地址变化期间不会发生错误写入而破坏存储器的内容， $\overline{WE}$信号在地址变化期间必须为高电平。为了保证有效数据的可靠写入，地址有效的时间至少为tWC=tAW+tW+tWR。为了保证在 $\overline{WE}$和 $\overline{CS}$变为无效前能把数据可靠地写入，要求写入的数据必须在tDW以前在数据总线上已经稳定。
  ![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638931217016.png)

#####   4.SRAM和DRAM的比较

![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638931217017.png)

####  3.3.2 只读存储器

#####   1.只读存储器（ROM）的特点

  ROM和RAM都是支持随机存取的存储器，其中SRAM和DRAM均为易失性半导体存储器。**而ROM中一旦有了信息，就不能轻易改变，即使掉电也不会丢失，它在计算机系统中是只供读出的存储器。**ROM位密度比可读写存储器高，且可靠性高，具有非易失性。

#####   2.ROM的类型

  ROM可分为掩模式只读存储器（MROM）、一次可编程只读存储器（PROM）、可擦除可编程只读存储器（EPROM）、闪速存储器（Flash Memory）和固态硬盘（Solid State Drives）

（1）掩模式只读存储器
	MROM的内容由制造厂按用户要求写入，写入后无法更改。

（2）一次可编程只读存储器
	可实现一次性编程，写入后无法改变。

（3）可擦除可编程只读存储器
	可对内容多次改写。需要修改EPROM的内容时，先将其全部内容擦除，然后编程。EPROM又可分为紫外线擦除和电擦除（E2PROM）。EPROM不能取代RAM，因为其编程次数有限，且写入时间太长。

（4）闪速存储器（Flash Memory）
	主要特点是既可在不加电的情况下长期保存信息，又能在线进行快速擦除和重写。

（5）固态硬盘（Solid State Drives,SSD）
	基于闪存的固态硬盘是用固态电子存储芯片阵列制成的硬盘，由控制单元和存储单元（Flash 芯片）组成。

####  3.3.3 主存储器的基本组成

![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638931217018.png)

  由一个个存储0或1的记忆单元（也称存储元件）构成的存储矩阵（也称存储体）是存储器的核心部分。记忆单元是具有两种稳态的能表示二进制0和1的物理器件。为了存取存储体中的信息，须对存储单元编号（也称编址）。编址单位是具有相同地址的那些存储元件构成的一个单位，可按字节编址，也可按字编址。现代计算机通常采用**字节编址**方式，此时存储体内的一个地址中有1字节。

  指令执行过程中需要访问主存时，CPU首先把被访问单元的地址送到MAR中，然后通过地址线（单向）将主存地址送到主存中的地址寄存器，以便地址译码器进行译码选中相应单元，同时CPU将读写信号通过控制线送到主存的读写控制电路。如果是写操作，CPU同时将要写的信息送到MDR中，在读写控制电路的控制下，经数据线（双向）将信号写入选中的单元；如果是读操作，那么主存读出选中单元的内容送到数据线，然后送到MDR中。数据线的宽度与MDR的宽度相同，地址线的宽度与MAR的宽度相同。 上图中采用64位数据线，所以在按字节编址方式下，每次最多可存取8个单元的内容。地址线的位数决定了主存地址空间的最大可寻址范围。数据线和地址线数共同反映存储体容量的大小，上图芯片的容量=236x64位。

------

  `例题`：某一SRAM芯片，其容量为1024x8位，除电源和接地端外，该芯片的引脚的最小数目为：
  A.21   B.22   C.23  D.24

  答案：A；地址线10根，数据线8根，加上片选线，读写控制线2根，共21根

  `例题`：动态RAM采用下列哪种刷新方式时，不存在死时间
  A.集中刷新   B.分散刷新   C.异步刷新   D.都不对

  答案：B;异步刷新虽然缩短了死时间，但死时间依然存在

  `例题`：某一DRAM芯片，采用地址复用技术，其容量为1024x8位，除电源和接地端外，该芯片的引脚数最少是（）（读写控制线为两根）

  A.16   B.17   C.19   D.20

  答案：B；采用地址复用技术时，通过行通选和列通选分行、列两次传送地址信号，因此地址线减半为5根，数据线8根，加上行通选和列通选及读写控制线共4根，总共为17根。DRAM采用地址复用技术，而SRAM不采用。
  关于地址复用：1.地址复用技术只适用于DRAM，不适合于SRAM。2.地址复用技术的目的是为了减少地址线的数量，便于增加DRAM的集成度。3.地址复用技术的本质是分2次送行列地址，因为半导体存储芯片的核心存储矩阵是采用行列地址交叉确定存储单元，所以既可以像SRAM那样一次同时取得行列地址，提高运行速度，也可像DRAM那样分两次取得行列地址，减少地址线的数量。

  `例题`：某容量为256MB的存储器由若干4Mx8位的DRAM芯片构成，该DRAM芯片的地址引脚和数据引脚总数是（）
  A.19   B.22   C.30   D.36

  答案：A；11+8

  `例题`：下列关于闪存的叙述中，错误的是（）
  A.信息可读可写，并且读、写速度一样快
  B.存储元由MOS管组成，是一种半导体存储器
  C.掉电后信息不丢失，是一种非易失性存储器
  D.采用随机访问方式，可替代计算机外部存储器

  答案：A；闪存依然是ROM的一种，写入时必须擦除原有数据，因此写速度比读速度慢。对于D，SSD固态硬盘即由Flash芯片组成

  `例题`：U盘属于（）类型的存储器
  A.高速缓存   B.主存   C.只读存储器   D.随机存取存储器

  答案：C；随机存取和随机存储器（RAM）不同，只读存储器ROM也是随机存取的，因此，支持随机存取的存储器不一定是RAM

  `例题`：在显示适配器中，用于存放显示信息的存储器称为刷新存储器，它的重要性能指标是带宽。具体工作中，显示适配器的多个功能部分要争用刷新存储器的带宽。设总带宽50%用于刷新屏幕，保留50%的带宽用于其他非刷新功能，且采用分辨率为1024x768像素、颜色深度为3B、刷新频率为72Hz的工作方式
  （1）计算刷新存储器的总带宽
  （2）为达到这样高的刷新存储器带宽，应采取何种技术措施

  答案：（1）2x72x1024x768x3B/s=339.738MB/s
  （2）要提高刷新存储器带宽，可采用：a.采用高速DRAM芯片；b.采用多体交叉存储结构；c.刷新存储器至显示控制器的内部总线宽度加倍；d.采用双端口存储器将刷新端口和更新端口分开

  `例题`：一个1K x 4位的动态RAM芯片，若其内部结构排列成64x64形式，且存取周期为0.1μs
  （1）若采用分散刷新和集中刷新（即异步刷新）相结合的方式，刷新信号周期应取多少
  （2）若采用集中刷新，则对该存储芯片刷新一遍需多少时间？死时间率是多少

  答案：（1）需在2ms时间内刷新64行，刷新信号的时间间隔为2ms/64=31.25 μs，可取刷新周期为31μs；
  （2）刷新一遍需2ms，每次刷新一行需一个存取周期，死时间率为0.32%

------

### 3.4 主存储器与CPU的连接

####  3.4.1 连接原理

- （1）主存储器通过**数据总线、地址总线和控制总线**`（总线）`和**CPU**连接
- （2）数据总线的位数与工作频率的乘积正比于数据传输率
- （3）地址总线的位数决定了可寻址的最大内存空间
- （4）控制总线（读/写）指出总线周期的类型和本次输入/输出操作完成的时刻
  ![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638931217029.png)

####  3.4.2 主存容量的扩展

  需要在字和位两方面进行扩充才能满足实际存储器的容量要求。通常采用`位扩展法、字扩展法和字位同时扩展法`来扩展主存容量

#####   1.位扩展法

  CPU的数据线数与存储芯片的数据位数不一定相等，此时必须对存储芯片扩位（即进行位扩展，用多个存储器件对字长进行扩充，增加存储字长），使其数据位数与CPU的数据线数相等。
  位扩展的连接方式是将多个存储芯片的地址端、片选端和读写控制端相应并联，数据端分别引出。

**位扩展法的要点：**

-    “位的并联”：各芯片的数据线与CPU数据线的各对应位拼接
-    各芯片的片选线应连在一起，**合用一个片选信号。**

 

`例1：`用8片8K x 1位的RAM芯片组成8K x 8位的存储器。8片RAM芯片的地址线A12~A0、$ \overline{CS}、\overline{WE}$都分别连在一起，每片的数据线依次作为CPU数据线的一位
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389312170210.png)
 

`例2：` 用4片`1K*4`的2114芯片组成一个 `1K*16`的存储器。

解：需要4片2114芯片，将它们并联起来**共用**一个片选信号，然后各芯片的数据线与CPU数据线的各对应位拼接

![image-20221216002621993](E:/Development/Typora/images/image-20221216002621993-1676546324693-9.png)



> 仅使用位扩展时，各芯片连接地址线的方式相同，但连接数据线的方式不同，在某一时刻选中所有的芯片，==所以片选信号 $\overline{CS}$要连接到所有芯片。==

#####   2.字扩展法

  字扩展是指**增加存储器中字的数量，而位数不变**。字扩展将芯片的地址线、数据线、读写控制线相应并联，而由片选信号来区分各芯片的地址范围。

**字扩展法的要点：**

-   各芯片的数据线与**CPU数据线的各对应位串接**在一起
-   各芯片的`片选线要分开`，分别与CPU地址总线的高位地址译码后的片选信号相连

`例1：`用4片16K x 8位的RAM芯片组成64K x 8位的存储器。4片RAM芯片的数据线D0~D7和$\overline{WE}$都分别连在一起。将A15A14用作片选信号，A15A14=00时，译码器输出端0有效，选中最左边的1号芯片；A15A14=01时，译码器输出端1有效，选中2号芯片，依次类推（在同一时间内只能有一个芯片被选中）。各芯片的地址分配如下：
  第1片，最低地址：00 0000 0000 0000 0000 00;最高地址：00 1111 1111 1111 1111 11（16位）
  第2片，最低地址：01 0000 0000 0000 0000 00;最高地址：01 1111 1111 1111 1111 11（16位）
  第3片，最低地址：10 0000 0000 0000 0000 00;最高地址：10 1111 1111 1111 1111 11（16位）
  第4片，最低地址：11 0000 0000 0000 0000 00;最高地址：11 1111 1111 1111 1111 11（16位）
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389312170211.png)
  仅采用字扩展时，各芯片连接地址线的方式相同，连接数据线的方式也相同，但在某一时刻只需选中部分芯片，==所以通过片选信号 $\overline{CS}$或采用译码器设计连接到相应的芯片。==

`例2`：用Intel2114`（1K*4）`芯片，组成 `4K *4`的存储器。

1、 计算分析：

-    2114的规格为1K*4，芯片地址线10条($A_9—A_0$)，数据线4条
-    需4片2114，系统地址线12条($A_{11}A_{10}$为片选线)，$数据线$4条

2、 片选及地址分析：

![image-20221216003043416](E:/Development/Typora/images/image-20221216003043416-1676546663665-11.png)

![image-20221216003059462](E:/Development/Typora/images/image-20221216003059462-1676546663665-12.png)





#####   3.字位同时扩展法

  字位同时扩展指既增加存储字的数量，又增加存储字长。
  用8片16K x 4位的RAM芯片组成64K x 8位的存储器。每两片构成一组16K x 8位的存储器（位扩展），4组便构成64K x 8位的存储器（字扩展）。地址线A15A14经译码器得到4个片选信号。
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389312170212.png)
  采用字位同时扩展时，各芯片连接地址线的方式相同，但连接数据线的方式不同，而且需要通过片选信号C$\overline{CS}$或采用译码器设计连接到相应的芯片。

####  3.4.3 存储芯片的地址分配和片选

- CPU要实现对存储单元的访问，首先要选择存储芯片，即进行**片选**；
- 然后为选中的芯片依地址码选择相应的存储单元，以进行数据的存取，即进行**字选**。
  - 片内的字选通常是由CPU送出的N条低位地址线完成的，地址线直接接到所有存储芯片的地址输入端（N由片内存储容量2n决定）。
- 片选信号的产生分为**线选法**和**译码片选法**。

#####   1.线选法

线选法用除片内寻址外的高位地址线直接（或经反相器）分别连接至各个存储芯片的片选端，==当某地址线信息为0时，就选中与之对应的存储芯片==。

**这些片选地址线每次寻址时只能有一位有效，不允许同时有多位有效，**这样才能保证每次只选中一个芯片（或芯片组）。假设4片2K x 8位存储芯片用线选法构成8K x 8位存储器，各芯片的片选信号如下：（其中低位地址线A10~A0作为字选线，用于片内寻址）
![在这里插入图片描述](E:\Development\Typora\images\20200818091614310.png)

> 线选法不需要地址译码器，但地址空间不连续，选片的地址线必须分时为低电平，不能充分利用系统的存储器空间，造成地址资源的浪费

#####   2.译码片选法

译码片选法用除片内寻址外的高位地址线通过地址译码器芯片产生片选信号。如用8片8K x 8位的存储芯片组成64K x 8位存储器（地址线为16位，数据线为8位），需要8个片选信号；若采用线选法，除去片内寻址的13位地址线，仅余高3位，不足以产生8个片选信号。因此，采用译码片选法，即用一片74LS138作为地址译码器，则A15A14A13=000时选第一片，以此类推。

##### 3.**全译码**

取全部存储器内部寻址线以外的其他 地址线，通过地址译码器产生片选信号。

-   ![image-20221216003219574](E:/Development/Typora/images/image-20221216003219574-1676546835292-15.png)





####  3.4.4 存储器与CPU的连接

#####   1.合理选择存储芯片

  合理选择存储芯片主要指存储芯片的类型（RAM或ROM）和数量的选择。通常选用ROM存放系统程序、标准子程序和各类常数，RAM则是为用户编程而设置的。

#####   2.地址线的选择

  CPU的地址线数往往比存储芯片的地址线数要多。通常将CPU地址线的低位与存储芯片的地址线相连，以选择芯片中的某一单元（字选），这部分的译码通常是由芯片的片内逻辑完成的。而CPU地址线的高位则在扩充存储芯片时使用，用来选择存储芯片（片选），这部分译码由外接译码器逻辑完成。
  例如，设CPU地址线为16位，即A15~A0,1K x 4位的存储芯片仅有10根地址线，此时可将CPU的低位地址A9~ A0与存储芯片的地址线A9~A0相连

#####   3.数据线的选择

  CPU的数据线数与存储芯片的数据线数不一定相等，在相等时可直接相连；在不等时必须对存储芯片扩位，使其数据位数与CPU的数据线数相等。

#####   4.读/写命令线的连接

  CPU的读写命令线一般可直接与存储芯片的读/写控制端相连，通常高电平为读，低电平为写。有些CPU的读/写命令线是分开的（读为 $\overline{RD}$，写为 $\overline{WE}$，均为低电平有效），此时CPU的读命令线应与存储芯片的允许读控制端相连，而CPU的写命令线则应与存储芯片的允许写控制端相连。

#####   5.片选线的连接

  片选线的连接是CPU与存储芯片连接的关键。存储器由许多存储芯片叠加而成，哪一片被选中完全取决于该存储芯片的片选控制端$\overline{CS}$是否能收到来自CPU的片选有效信号。
  片选有效信号与CPU的访存控制信号$\overline{MREQ}$​（低电平有效）有关，因为只有当CPU要求访存时，才要求选中存储芯片。若CPU访问I/O,则 $\overline{MREQ}$为高，表示不要求存储器工作。

------

  `例题：`假定用若干2K x 4位的芯片组成一个8K x 8位的存储器，则地址0B1FH所在芯片的最小地址是（）
  A.0000H  B.0600H  C.0700H  D.0800H

  答案：D；各组的地址分配：第一组：0000H~07FFH；
  第二组：0800H ~0FFFH；第三组：1000H ~17FFH；
  第四组：1800H~1FFFH；

  `例题`：80386DX是32位系统，以4B为编址单位，当在该系统中用8KB（8K x 8位）的存储芯片构造32KB的存储体时，应完成存储器的（）设计
  A.位扩展  B.字扩展  C.字位扩展  D.字位均不扩展

  答案：A；

  `例题`：地址总线A0（高位）~A15（低位），用4K x 4位的存储芯片组成16KB存储器，则产生片选信号的译码器的输入地址线应该是（）

  答案：A；

  `例题`：![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389312170213.png)

  答案：D；

  `例题`：主存储器的地址寄存器和数据寄存器各自的作用是什么？设一个1MB容量的存储器，字长为32位，问：
  （1）按字节编址，地址寄存器和数据寄存器各几位？编址范围为多大？
  （2）按字编址，地址寄存器和数据寄存器各几位？编址范围为多大？

  答案：在存储器中，MAR用来存放当前CPU访问的内存单元地址，或存放CPU写入内存的内存单元地址。MDR用于存放由内存中读出的信息或写入内存的信息
  （1）20位、8位，编址范围00000H~FFFFFH；
  （2）18位、32位，00000H~3FFFFH

  `例题`：有一组16K x 16位的存储器，由1K x 4位的DRAM芯片构成（芯片是64x64结构）
  （1）共需要多少RAM芯片
  （2）采用异步刷新方式，如单元刷新间隔不超过2ms，则刷新信号周期是多少

  答案：（1）64；（2）刷新时不需要选片，整个存储器中的所有芯片同时被刷新，2ms/64=31.25μs，可取刷新信号周期为31μs

  `例题`：设有32片256K x 1位的SRAM芯片
  （1）采用位扩展方法可构成多大容量的存储器
  （2）采用32位的字编址方式，该存储器需要多少地址线
  （3）画出该存储器与CPU连接的结构图，设CPU的接口信号有地址信号、数据信号和控制信号 $\overline{MREQ}$​、$\overline{WE}$

  答案：（1）256K x 32位;（2）18；（3）用$\overline{MREQ}$作片选信号，$\overline{WE}$作读写控制信号，CPU访存地址为A19~A2，最高地址位为A19（A0、A1保留，在字节编址时使用）：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389312170214.png)

  `例题：`某机主存空间为64KB，I/O空间与主存单元统一编址，I/O空间占用1KB，范围为FC00H~FFFFH。可选用8K x 8位和1K x 8位两种SRAM芯片构成主存储器，R D ‾ \overline{RD}RD和$\overline{WR}$分别为系统提供的读写信号线。画出该存储器的逻辑图，并标明每块芯片的地址范围

  答案：由于64KB存储空间中，I/O占用了最高的1KB空间（FC00H~FFFFH），RAM芯片应当分配在余下的低63KB空间中。选用7片8K x 8位芯片和7片1K x 8位芯片，共计63KB
  8K x 8RAM芯片片内地址应有13根，连接地址线A12~A0，每片的地址范围为0000H ~1FFFH
  64KB的存储器应有64K个存储单元，地址线有16根。地址范围为0000H~FFFFH
  地址线A12~A0并行连接到7片8K x 8位RAM芯片的13个地址端，用3根高地址线A15、A14、A13经3/8译码器译码，译码器的7个输出端（000~110）分别连接到7片8K x 8位芯片的片选端，用以选择7片8K x 8位芯片中的1片。剩下的1个输出端111用以控制另一个3/8译码器。
  1Kx8的存储器共有1K个存储单元，地址线应有10根，地址范围为000H~ 3FFH。地址线A9~A0，并行连接到7片1K x 8位RAM芯片的10个地址端。3根地址线A12、A11、A10经3/8译码器译码，译码器的7个输出端（000~110）分别连接到7片1K x 8位芯片的片选端，用以选择7片1K x 8位芯片中的1片。
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389312170215.png)

  地址范围：
  U0：0000H~ 1FFFH；U1：2000H~ 3FFFH；U2：4000H~ 5FFFH；
  U3：6000H~ 7FFFH；U4：8000H~ 9FFFH；U5：A000H~ BFFFH；
  U6：C000H~ DFFFH；
  U7：E000H~ E3FFH；U8：E400H~ E7FFH；U9：E800H~ EBFFH；
  U10：EC00H~ EFFFH；U11：F000H~ F3FFH；U12：F400H~ F7FFH；
  U13：F800H~ FBFFH；
  余下的FC00H~FFFFH为I/O空间

  `例题`：设CPU有16根地址线，8根数据线，并用 $\overline{MREQ}$作为访存控制信号（低电平有效），用$\overline{WR}$作为读写控制信号（高电平为读、低电平为写）。现有下列存储芯片：1Kx4位RAM，4Kx8位RAM，8Kx8位RAM，2Kx8位ROM、4Kx8位ROM，8Kx8位ROM及74LS138译码器和各种门电路。画出CPU与存储器的连接图。要求：
  （1）主存地址空间分配：6000H~ 67FFH为系统程序区；6800H ~6BFFH为用户程序区。
  （2）合理选用芯片，并说明各选几片
  （3）详细画出存储芯片的片选逻辑图

  答案：（2）选择1片2Kx8位ROM，2片1Kx4位RAM；
  0~10号地址线应用来选择ROM芯片，0 ~ 9号地址线应用来选择RAM芯片，能用来作为74LS138（3线-8线译码器）输入的只能是11 ~15号地址线，因此取11、12、13这三位分别作为A、B、C的输入端。
  ROM芯片的13、12、11号线为100，因此取74LS138的4号输出端。RAM芯片的13、12、11号线为101，取5号输出端，又因为10号线为0时才选中RAM芯片，选用输入输出端均反相的与非门。
  **还需注意的点有ROM不接$\overline{WR}$，接地**
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389312170216.png)



**例1：**已知RAM芯片和地址译码器的引脚如图所示，试回答如下问 题： 

（1）若要求构成一个8K×8的RAM 阵列，需几片这样的芯片？ 设RAM阵列组占用起始地址为E000H的连续地址空间，若采 用全地址译码方式译码，试画出存储器系统的电路连接图。

（2）试写出每块RAM芯片的地址空间。

![image-20221216003418657](E:/Development/Typora/images/image-20221216003418657-1676547001558-17.png)

**例2：**某半导体存储器，按字节编址。其中，0000H～ 07FFH为ROM区， 选用EPROM芯片（2KB/片）；0800H～1FFFH为RAM区，选用RAM芯片 （2KB/片）。地址总线A15～A0（低）。

​	(1)计算芯片数

​	(2)给出地 址分配和片选逻辑 

​	(3)画出连接图（全译码）。



解：（1）计算容量和芯片数

ROM区：2KB 

`单元数=末地址-首地址+1`=07FFH-0000H+1=800H=2K

 容量=2KB 芯片数=2KB/2KB=1

 RAM区：3KB 

`单元数=末地址-首地址+1`=1FFFH-0800H+1=1800H=6K

容量=6KB 

芯片数=6KB/2KB=3 

（2）地址分配与片选逻辑

![image-20221216003553930](E:/Development/Typora/images/image-20221216003553930-1676547001559-18.png)

（3)画出连接图

![image-20221216003604693](E:/Development/Typora/images/image-20221216003604693-1676547001559-19.png)



**例3：**某计算机的存储器容量为4K * 8，其中固化区为2K * 8，工作 区为2K * 8。要求用RAM2114（1K * 4）芯片和EPROM2716 （2K * 8）构成。

分析需要的芯片数量、地址空间划分，并画 出逻辑结构图。

1、 存储空间分配与芯片数量

![image-20221216003645876](E:/Development/Typora/images/image-20221216003645876-1676547001559-20.png)



**例4：**设计一半导体存储器，其中ROM区4KB，选用ROM芯片 （4K×4位/片）；RAM区4KB，需同时选用RAM芯片 （2KB/片和2K×4位/片，各占2KB）。地址总线A15～A0， 双向数据总线D7～D0，读/写线R/W*。

   1.给出芯片片选逻辑式和地址分配，确定每组芯片的地址空 间范围

2.   画出该存储器逻辑框图（各芯片信号线的连接及片选逻辑 电路，片选低电平有效，全译码方式）



2、片选逻辑与地址范围：

![image-20221216003746426](E:/Development/Typora/images/image-20221216003746426-1676547001559-21.png)



### 3.5 双端口RAM和多模块存储器

  为提高CPU访问存储器的速度，可采用双端口存储器、多模块存储器等技术，它们同属并行技术，前者为空间并行，后者为时间并行。

####  3.5.1 双端口RAM

  双端口RAM是指同一个存储器有左、右两个独立的端口，分别具有两组相互独立的地址线、数据线和读写控制线，允许两个独立的控制器同时异步地访问存储单元。 当两个端口的地址不相同时，在两个端口上进行读写操作一定不会发生冲突。
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389312170217.png)
  两个端口同时存取存储器的同一地址单元时，会因数据冲突造成数据存储或读取错误。两个端口对同一主存操作有以下4种情况：
  （1）两个端口不同时对同一地址单元存取数据
  （2）两个端口同时对同一地址单元读出数据
  （3）两个端口同时对同一地址单元写入数据
  （4）两个端口同时对同一地址单元操作，一个写入数据，另一个读出数据
  其中，（1）和（2）不会出现错误；（3）会出现写错误；（4）会出现读错误
  解决方法：置忙信号B U S Y ‾ \overline{BUSY}BUSY为0，由判断逻辑决定暂时关闭一个端口（即被延时)，未被关闭的端口正常访问，被关闭的端口延长一个很短的时间段后再访问。

####  3.5.2 多模块存储器

  常用的有单体多字存储器和多体低位交叉存储器。

------

  CPU的速度比存储器快，若同时从存储器中取出n条指令，就可充分利用CPU资源，提高运行速度。多体交叉存储器就是基于这种思想提出的。

------

#####   1.单体多字存储器

  单体多字系统的特点是存储器中只有一个存储体，每个存储单元存储m个字，总线宽度也为m个字。一次并行读出m个字，地址必须顺序排列并处于同一存储单元。
  单体多字系统在一个存取周期内，从同一地址取出m条指令，然后将指令逐条送至CPU执行，即每隔1/m存取周期，CPU向主存取一条指令。单体多字系统的缺点是：指令和数据在主存内必须是连续存放的，一旦遇到转移指令或操作数不能连续存放，这种方法的效果不明显。

#####   2.多体并行存储器

  多体并行存储器由多体模块组成。每个模块都有相同的容量和存取速度，各模块都有独立的读写控制电路、地址寄存器和数据寄存器。它们既能并行工作、又能交叉工作。
  多体并行存储器分为高位交叉编址（顺序方式）和低位交叉编址（交叉方式）两种。
  （1）高位交叉编址：高位地址表示体号，低位地址为体内地址。 高位交叉编址主要用于存储器容量扩展。
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389312170218.png)
  图中存储器共有4个模块M0~M3，每个模块有n个单元。
  高位交叉编址方式下，总是把低位的体内地址送到由高位体号确定的模块内进行译码。访问一个连续主存块时，总是先在一个模块内访问，等到该模块访问完才转到下一个模块访问，CPU总是按顺序访问存储模块，存储模块不能并行访问，因而不能提高存储器的吞吐率。高位交叉编址方式下易出现某一个存储体繁忙，其余空闲。
  模块内的地址是连续的，存取方式仍是串行存取，因此这种存储器仍是顺序存储器。

------

  取0号地址时，可交叉取得M1中的n号地址，而要取1号地址时须等到0号地址取完才能取

------

  （2）低位交叉编址
  低位交叉编址主要用于存储器带宽、访问速度的提高。 低位地址为体号，高位地址为体内地址。每个模块按模m交叉编址，模块号=单元地址%m。假定有m个模块，每个模块有k个单元，则0，m，…，（k-1）m单元位于M0；第1，m+1，…，（k-1）m+1单元位于M1；以此类推。
  低位交叉编址方式下，总是把高位的体内地址送到由低位体号确定的模块内进行译码。程序连续存放在相邻模块中，因此称采用此编址方式的存储器为交叉存储器。采用低位交叉编址后，可在不改变每个模块存取周期的前提下，采用流水线的方式并行存取，提高存储器的带宽。
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389312170319.png)
  设模块字长等于数据总线宽度，模块存取一个字的存取周期为T，总线传送周期为r，为实现流水线方式存取，存储器交叉模块数应大于等于
  m=T/r
  式中，m称为交叉存取度。每经过r时间延迟后启动下一个模块，交叉存储器要求其模块数>=m，以保证启动某模块后经过m x r的时间后再次启动该模块时，其上次的存取操作已完成（即流水线不间断）。这样，连续存取m个字所需的时间为：t1=T+（m-1）r。而顺序方式连续读取m个字所需的时间为t2=mT。
  模块数为4的流水线方式存取示意图如图：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389312170320.png)
  例：设存储器容量为32个字，字长为64位，模块数为4，分别采用顺序方式和交叉方式进行组织。存储周期T=200ns，数据总线宽度为64位，总线传输周期r=50ns。在连续读出4个字的情况下，求顺序存储器和交叉存储器各自的带宽。
  32x10^7b/s;73x10 ^ 7b/s；

------

  高性能存储芯片：
  （1）SDRAM（同步DRAM）：SDRAM与处理器的数据交换同步于系统的时钟信号，不需要插入等待状态（CPU无须等待）
  （2）RDRAM：主要解决存储器带宽的问题
  （3）带Cache的DRAM（CDRAM）适合猝发式读取

------

------

  例题：双端口RAM在（）情况下会发生读/写冲突
  A.左端口和右端口的地址码不同
  B.左端口和右端口的地址码相同
  C.左端口和右端口的数据码不同
  D.左端口和右端口的数据码相同

  答案：B；

  例题：某机器采用四体低位交叉存储器，现分别执行下述操作：1.读取6个连续地址单元中存放的存储字，重复80次；2.读取8个连续地址单元中存放的存储字，重复60次。则1,2所花费的时间比为

  答案：4:3；对于1：在每轮读取存储器的前6个T/4时间（共3T/2）内，依次进入各体。下一轮欲读取存储器时，最近访问的M1还在占用中（才过T/2时间），因此必须再等待T/2的时间才能开始新的读取（M1连续完成两次读取，也即总共2T的时间即可进入下一轮。进入下一轮不需要第6个字读取结束，第5个字读取结束，M1就已空出，即可马上进入下一轮）。最后一轮读取结束的时间是本轮第6个字读取结束，共（6-1）x(T/4)+T=2.25T。
  情况1的总时间为（80-1）x 2T+2.25T=160.25T;
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389312170321.png)
  对于2：（60-1）x 2T+( 8-1 ) x T/4 +T=120.75T

  例题：下列说法中，正确的是（）
  1.高位多体交叉存储器能很好地满足程序的局部性原理
  2.高位四体交叉存储器可能在一个存储周期内连续访问4个模块
  3.双端口存储器可以同时访问同一区间，同一单元
  A.1,3  B.2,3  C.3  D.1

  答案：B；高位多体交叉存储器若取了0，就不能继续取1，但可以取n，不满足程序的局部性原理；高位交叉存储器有可能一次连续读出彼此地址相差一个存储体容量的4个字；

  例题：某计算机使用四体交叉编址寄存器，假定在存储器总线上出现的主存地址（10进制）序列为8005,8006,8007,8008,8001,8002,8003,8004,8000，则有可能发生访存冲突的地址对是：
  A.8004,8008  B.8002,8007  C.8001,8008  D.8000,8004

  答案：D；

  例题：某计算机主存按字节编址，由4个64M x 8位的DRAM芯片采用交叉编址方式构成，并与宽度为32位的存储器总线相连，主存每次最多读写32位数据。若double型变量x的主存地址为804001AH，则读取x需要的存储周期数是（）

  答案：3个存储周期；1个存储周期读4个B，double数据类型占8个字节。因为主存地址最低2位表示该字节存储的芯片编号，数据在从体2上开始，但是对于存储的读取是从体0开始的。所以在第一个周期结束，实际上读了体2，体3上的数据，第二轮周期把4个体都读一遍，现在还剩下体0和体1上的两个数据，然后第三个周期，才能读完8个字节。

  例题：一个四体并行交叉存储器，每个模块容量是64K x 32位，存取周期为200ns
  （1）在一个存取周期中，存储器能向CPU提供多少位二进制信息
  （2）若存取周期为400ns,则在0.1μs内每个体可向CPU提供32位二进制信息，该说法对吗？为什么？

  答案：（1）128位（流水线稳定后）；（2）不对，因为在0.1μs内整个存储器可向CPU提供32位二进制信息（流水线稳定），但每个存储体必须经过400ns才能向CPU提供32位二进制信息

  例题：某计算机字长32位，存储体的存储周期为200ns
  （1）采用四体交叉工作，用低2位的地址作为体地址，存储数据按地址顺序存放。主机最快多长时间可以读出一个数据字？存储器的带宽是多少？
  （2）若4个体分别保存主存中前1/4、次1/4、再下个1/4、最后1/4这四段的数据，即选用高2位的地址作为体地址，可以提高存储器顺序读出数据的速度吗？为什么？
  （3）若把存储器改成单体4字宽度，会带来什么好处和问题？
  （4）比较采用四体低位地址交叉的存储器和四端口读出的存储器这两种方案的优缺点

  答案：（1）理想情况是每个存取周期平均可读出4个数据字，即读出1个数据字时间为50ns，数据传输率32bit/50ns=80MB/s
  （2）若对多体结构的存储器选用高位地址交叉，通常起不到提高存储器读写速度的作用，因为它不符合程序的局部性原理，一次连续读出彼此地址相差1个存储体的容量的4个字的机会太少。因此，通常只有1个存储模块在不停忙碌，其他存储模块是空闲的。
  （3）若把存储器的字长扩大为原来的4倍，实现的则是一个单体4字结构的存储器，每次读可以同时读出4个字的内容，有利于提高存储器每个字的平均读写速度，但其灵活性不如多体单字结构的存储器，还会多用到几个缓冲寄存器。
  （4）多端口存储器是对同一个存储体使用多套读写电路实现的，扩大存储容量的难度显然比多体结构的存储器要大，而且不能对多端口存储器的同一个存储单元同时执行多个写入操作，而多体结构的存储器则允许在同一个存储周期对几个存储体执行写入操作

------

### 3.6 高速缓冲存储器

  通常将存储系统分为Cache-主存层次和主存-辅存层次。

####  3.6.1 程序访问的局部性原理

  程序访问的局部性原理包括时间局部性和空间局部性。 时间局部性是指在最近的未来要用到的信息，很可能是现在正在使用的信息，因为程序中存在循环。空间局部性是指在最近的未来要用到的信息，很可能与现在正在使用的信息在存储空间上是邻近的，因为指令通常是顺序存放、顺序执行的，数据一般也是以向量、数组等形式簇聚地存储在一起的。
  高速缓冲技术就是利用程序访问的局部性原理，把程序中正在使用的部分存放在一个高速的、容量较小的Cache中，使CPU的访存操作大多数针对Cache进行，从而大大提高程序的执行速度。
  例：假定数组元素按行优先方式存储，对于下面的两个函数：

```c
程序A：
int sumarrayrows( int a[M][N] )
{
	int i,j,sum=0;
	for( i=0;i<M;i++ )
		for( j=0;j<N;j++ )
			sum+=a[i][j];
	return sum;
}
程序B：
int sumarraycols( int a[M][N] )
{
	int i,j,sum=0;
	for( j=0;j<N;j++ )
		for( i=0;i<M;i++ )
			sum+=a[i][j];
	return sum;
}
123456789101112131415161718
```

  （1）对于数组a的访问，哪个空间局部性更好？哪个时间局部性更好？
  （2）对于指令访问来说，for循环体的空间局部性和时间局部性如何？

  答案：（1）程序A对数组a的访问顺序与存放顺序是一致的，因此空间局部性好。程序B对数组a的访问顺序与存放顺序不一致，因而没有空间局部性。两个程序的时间局部性都很差，因为每个数组元素都只被访问一次。
  （2）对于for循环体，程序A和程序B中的访问局部性是一样的。因为循环体内指令按序连续存放，所以空间局部性好；内循环体被连续重复执行，因此时间局部性也好。

####  3.6.2 Cache的基本工作原理

  Cache位于存储器层次结构的顶层，通常由SRAM构成，其基本结构如图：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389312170322.png)
  为便于Cache和主存之间交换信息，Cache和主存都被划分为相等的块，Cache块又称Cache行，每块由若干字节组成，块的长度称为块长（Cache行长)。主存的地址分成两段：高m位表示主存的块地址，低b位表示块内地址，同样，缓存的地址也分为两段：高c位表示缓存的块号，低b位表示块内地址。由于Cache容量远小于主存容量，所以Cache中的块数要远少于主存中的块数，它仅保存主存中最活跃的若干块的副本。因此Cache按照某种策略，预测CPU在未来一段时间内欲访存的数据，将其装入Cache。
  当CPU发出读请求时，若访存地址在Cache中命中，就将此地址转换成Cache地址，直接对Cache进行读操作，与主存无关。若Cache不命中，则仍需访问主存，并把此字所在的块一次性地从主存调入Cache。 若此时Cache已满，则需根据某种替换算法，用这个块替换Cache中原来的某块信息。CPU与Cache之间的数据交换以字为单位，而Cache与主存之间的数据交换则以Cache块为单位。

------

  某些计算机中也采用同时访问Cache和主存的方式，若Cache命中，则主存访问终止；否则访问主存并替换Cache。

------

  当CPU发出写请求时，若Cache命中，有可能会遇到Cache与主存中的内容不一致的问题。例如，由于CPU写Cache，把Cache某单元中的内容从X修改成了X’，而主存对应单元中的内容仍然是X，没有改变。所以若Cache命中，需要按照一定的写策略处理，常见的处理方法有全写法和写回法。
  CPU欲访问的信息已在Cache中的比率称为Cache的命中率。设一个程序执行期间，Cache的总命中次数为Nc，访问主存的总次数为Nm，则命中率H为：H=Nc/（Nc+Nm）
  设tc为命中时的Cache访问时间，tm为未命中时的访问时间，则Cache-主存系统的平均访问时间Ta为：
  Ta=Htc+（1-H）tm

------

  Cache行的大小与命中率：
  当块由小到大增长时，起初会因局部性原理使命中率有所提高。倘若继续增大块长，命中率很可能下降。
  行长较大，可充分利用程序访问的空间局部性，使一个较大的局部空间被一起调到Cache中，因而可以增加命中机会。但行长也不能过大：（1）行长大使失效损失变大。若未命中，需花更多时间从主存读块。（2）行长太长，Cache项数变少，因而命中的可能性变小。

  发生取指令Cache缺失的处理过程：
（1）PC恢复当前指令的值；（2）对主存进行读操作；(3）将读入的指令写入Cache中，更改有效位和标记位；（4）重新执行当前指令

  统一缓存与分立缓存、指令Cache与数据Cache:
  统一缓存是指指令和数据都存放在同一缓存内的Cache；分立缓存是指指令和数据分别存放在两个Cache中：指令Cache与数据Cache。指令和数据可以分别存储在不同的Cache中，这种结构也称哈佛Cache，其特点是允许CPU在同一个Cache存储周期内同时提取指令和数据，由于指令执行过程中取指和取数据都有可能访问Cache，因此这一特性可以保证不同的指令同时访存。
  统一缓存与分立缓存的选用主要考虑以下两个因素：（1）与主存结构有关，若计算机的主存是统一的（指令、数据存储在同一主存内），则对应的Cache采用统一缓存；若主存采用指令、数据分开存储的方案，则相应的Cache采用分立缓存。（2）与机器对指令执行的控制方式有关。当采用超前控制（超前取指或指令预取）或流水线控制方式时，一般采用分立缓存。

------

####  3.6.3 Cache和主存的映射方式

  Cache行中的信息是主存中某个块的副本，地址映射是指把主存地址空间映射到Cache地址空间，即把存放在主存中的信息按照某种规则装入Cache。
  由于Cache行数比主存块数少得多，因此主存中只有一部分块的信息可放在Cache中，因此在Cache中要为每块加一个标记，指明它是主存中哪一块的副本。 该标记的内容相当于主存中块的编号。为了说明Cache行中的信息是否有效，每个Cache行需要一个有效位。
  地址映射不同于地址变换。地址变换是指CPU在访存时，将主存地址按映射规则换算成Cache地址的过程。 由于主存和Cache的块大小相同，块内地址都是相对于块的起始地址的偏移量（即低位地址相同），因此地址变换主要是主存的块号（高位地址）与Cache块号间的转换。 地址映射的方法有以下三种：

#####   1.直接映射

  主存中的每一块只能装入Cache中的唯一位置。若这个位置已有内容，则产生块冲突，原来的块将无条件地被替换出去（无须使用替换算法）。 直接映射不够灵活，即使Cache的其他许多地址空着也不能占用，这使得直接映射的块冲突概率最高，空间利用率最低。
  直接映射的关系可定义为：j = i mod 2c
  j是Cache的块号（行号），i是主存的块号，2c是Cache中的总块数。在这种映射方式中，主存的第0块、第2c块、第2c+1…只能映射到Cache的第0行；而主存的第1块、第2c+1块、第2c+1+1块…只能映射到Cache的第1行，依次类推。主存块号的低c位正好是它要装入的Cache行号。 给每个Cache行设置一个长为t=m-c的标记（tag），当主存某块调入Cache后，就将其块号的高t位设置在对应Cache行的标记中。
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389312170323.png)
  直接映射的地址结构为：
![在这里插入图片描述](E:\Development\Typora\images\20200818205131857.png)
  CPU访存过程如图：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389312170324.png)
  首先根据访存地址中间的c位，直接找到对应的Cache行，将对应Cache行中的标记和主存地址的高t位标记进行比较，若相等且有效位为1，则访问Cache命中， 此时根据主存地址中低位的块内地址，在对应的Cache行中存取信息；若不相等或有效位为0，则不命中，此时CPU从主存中读出该地址所在的一块信息送到对应的Cache行中，将有效位置1，并将标记设置为地址中的高t位，同时将该地址中的内容送CPU。

#####   2.全相联映射

  主存中的每一块可以装入Cache中的任何位置，每行的标记用于指出该行取自主存的哪一块，所以CPU访存时需要与所有Cache行的标记进行比较。 全相联映射方式Cache块的冲突概率低，空间利用率高，命中率高；缺点是标记的比较速度较慢，实现成本较高，需采用昂贵的按内容寻址的相联存储器进行地址映射。
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389312170325.png)

  全相联映射的地址结构为：
![在这里插入图片描述](E:\Development\Typora\images\20200818210506821.png)

#####   3.组相联映射

  将Cache空间分为大小相同的组，主存的一个数据块可以装入一组内的任何一个位置，即组间采取直接映射，组内采取全相联映射。 它是对直接映射和全相联映射的一种折中，当Cache组数Q=1时变为全相联映射，Q=Cache块数时变为直接映射。假设每组有r个Cache行，则称之为r路组相联。
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389312170326.png)
  组相联映射的关系可定义为：
  j=i mod Q
  其中，j是Cache行的组号，i是主存的块号，Q是Cache的组数
  路数越大，即每组Cache行的数量越大，发生块冲突的概率越低，但相联比较电路越复杂。选定适当的数量，可使组相联映射的成本接近于直接映射，而性能上仍接近于全相联映射。
  组相联映射的地址结构为：
![在这里插入图片描述](E:\Development\Typora\images\20200818211941412.png)
  CPU访存过程如下：首先根据访存地址中间的组号找到对应的Cache组；将对应Cache组中每个行的标记与主存地址的高位标记进行比较；若有一个相等且有效位为1，则访问Cache命中， 此时根据主存地址中的块内地址，在对应Cache行中存取信息；若都不相等或相等但有效位为0，则不命中，此时CPU从主存中读出该地址所在的一块信息送到对应Cache组的任意一个空闲行中，将有效位置1，并设置标记，同时将该地址中的内容送CPU。

  例：假设某个计算机的主存地址空间大小为256MB，按字节编址，其数据Cache有8个Cache行，行长为64B
  （1）若不考虑用于Cache的一致维护性和替换算法控制位，并且采用直接映射方式，则该数据Cache的总容量是多少？
  （2）若该Cache采用直接映射方式，则主存地址为3200（10进制）的主存块对应的Cache行号是多少？采用二路组相联映射时又是多少？
  （3）以直接映射方式为例，简述访存过程（设访存的地址为0123456H）

  答案：（1）4256位；Cache包括了可以对Cache中所包含的存储器地址进行跟踪的硬件，即Cache的总容量包括：存储容量、标记阵列容量（有效位、标记位）（标记阵列中的一致性维护位和Cache数据一致性维护方式相关，替换算法控制位和替换算法相关，题中不计算）

------

  每个Cache行对应一个标记项（包括有效位、标记位Tag、一致性维护位、替换算法维护位），而在组相联中，将每组的标记项排成一行，将各组从上到下排列，成为一个二维的标记阵列（对于直接映射，一行就是一组）。查找Cache时就是查找标记阵列的标记项是否符合要求。二路组相联的标记阵列如图：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389312170327.png)

------

  本题中每行相关的存储器容量如图：
![在这里插入图片描述](E:\Development\Typora\images\20200819194953849.png)
  标记字段长度的计算：主存地址有28位（256MB=228B），其中6位为块内地址（26B=64B），3位为行号，剩余19位为标记字段，总容量为8x(20+64x8)=4256位。
  （2）直接映射方式中，主存按照块的大小划分，主存地址3200对应的字块号为3200B/64B=50。而Cache只有8行，则50mod8=2，因此对应的Cache行号为2。二路组相联方式，实质上就是将两个Cache行合并，内部采用全相联方式，外部采用直接相联方式，50mod4=2,对应的组号为2，即对应的Cache行号为4or5。
  （3）直接映射方式中，28位主存地址可分为19位的主存标记位，3位的块号，6位的块内地址，即001为块号，010110为块内地址。首先根据块号，查Cache（即001号Cache行)中对应的主存标记位，看是否相同。若相同，再看Cache行中装入有效位是否为1，若是，则表示有效，称此访问命中，按块内地址010110读出Cache行所对应的单元并送入CPU中，完成访存。若出现标记位不相等或有效位为0的情况，则不命中，访问主存将数据取出并送往CPU和Cache的对应块中，把主存的最高19位存入001行的Tag中，并将有效位置1。

  三种映射方式中，直接映射的每个主存块只能映射到Cache中的某一固定行；全相联映射可以映射到所有Cache行；N路组相联映射可以映射到N行。 当Cache大小、主存块大小一定时：
  （1）直接映射的命中率最低，全相联映射的命中率最高
  （2）直接映射的判断开销最小、所需时间最短，全相联映射的判断开销最大、所需时间最长。
  （3）直接映射标记所占的额外空间开销最少，全相联映射标记所占的额外空间开销最大

####  3.6.4 Cache中主存块的替换算法

  在采用全相联映射或组相联映射方式时，从主存向Cache传送一个新块，当Cache或Cache组中的空间已被占满时，就需要使用替换算法置换Cache行。而采用直接映射时，一个给定的主存块只能放到唯一的固定Cache行中，所以在对应Cache行已有一个主存块的情况下，新的主存块毫无选择地把原先已有的那个主存块替换掉，因而无须考虑替换算法。
  常用的替换算法有随机（RAND）算法、先进先出（FIFO）算法、近期最少使用（LRU）算法和最不经常使用（LFU）算法。
  （1）随机算法：随机地确定替换的Cache块。不符合程序访问的局部性原理
  （2）先进先出算法：选择最早调入的行进行替换。不符合程序的局部性原理。
  （3）近期最少使用算法：依据程序访问的局部性原理，选择近期内长久未访问过的Cache行作为替换的行，平均命中率比FIFO高，是堆栈类算法。
  LRU算法对每个Cache行设置一个计数器，用计数值来记录主存块的使用情况，并根据计数值选择淘汰某个块， 计数值的位数与Cache组大小有关，2路时有1位LRU位，4路时有2位LRU位。假定采用4路组相联，有5个主存块{1,2,3,4，5}映射到Cache的同一组，对于主存访问序列{1,2，3,4，1,2，5,1，2,3，4,5}，采用LRU算法的替换过程如图：（图中左边阴影的数字是对应Cache行的计数值，右边的数字是存放在该行中的主存块号）
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389312170328.png)

  计数器的变化规则：（1）命中时，所命中的行的计数器清零，计数值比其低的计数器加1，其余不变； （2）未命中且还有空闲行时，新装入的行的计数器置0，其余全加1； （3）未命中且无空闲行时，计数值为3的行的信息块被淘汰，新装行的块的计数器置0，其余全加1。

  当集中访问的存储区超过Cache组的大小时，命中率可能变得很低，如上例中的访问序列变为1，2,3,4,5，1,2，3,4,5，…，而Cache每组只有4行，那么命中率为0，这种现象称为抖动。

  （4）最不经常使用算法：将一段时间内被访问次数最少的存储行换出。每行也设置一个计数器，新行建立后从0开始计数，每访问一次，被访问的行计数器加1，需要替换时比较各特定行的计数值，将计数值最小的行换出。

####  3.6.5 Cache写策略

  因为Cache中的内容是主存块副本，当对Cache中的内容进行更新时，就需选用写操作策略使Cache内容和主存内容保持一致。 此时分2种情况。
  对于Cache写命中（write hit），有两种处理方法
  （1）全写法（写直通法、write-through）：当CPU对Cache写命中时，必须把数据同时写入Cache和主存。当某一块需要替换时，不必把这一块写回主存，用新调入的块直接覆盖即可。 这种方法能随时保持主存数据的正确性。缺点是增加了访存次数，降低了Cache的效率。写直达法的写操作时间就是访问主存的时间。写缓冲：为减少全写法直接写入主存的时间损耗，在Cache和主存之间加一个写缓冲（Write Buffer）。CPU同时写数据到Cache和写缓冲中，写缓冲再控制将内容写入主存。写缓冲是一个FIFO队列，写缓冲可以解决速度不匹配的问题。但若出现频繁写时，会使写缓冲饱和溢出。
![在这里插入图片描述](E:\Development\Typora\images\20200819205932984.png)
  （2）写回法（write-back）：当CPU对Cache写命中时，只修改Cache的内容，而不立即写入主存，只有当此块被换出时才写回主存。 写操作时间就是访问Cache的时间。这种方法减少了访存次数，但存在不一致的隐患。采用这种策略时，每个Cache行必须设置一个标志位（脏位），以反映此块是否被CPU修改过。
  全写法和写回法都对应于Cache写命中（要被修改的单元在Cache中）时的情况。
  对于Cache写不命中，也有两种处理方法
  （1）写分配法（write-allocate）：加载主存中的块到Cache中，然后更新这个Cache块。 它试图利用程序的空间局部性，但缺点是每次不命中都需要从主存中读出一块。
  （2）非写分配法（not-write-allocate)：只写入主存，不进行调块。
  非写分配法通常与全写法合用，写分配法通常和写回法合用

  现代计算机的Cache通常设立多级Cache（通常为3级），假定设3级Cache，按离CPU的远近可各自命名为L1 Cache、L2 Cache、L3 Cache，离CPU越远，访问速度越慢，容量越大。指令Cache与数据Cache分离一般在L1级，此时通常为写分配法和写回法合用。
  下图是一个含有2级Cache的系统，L1 Cache对L2 Cache使用全写法，L2 Cache对主存使用写回法，由于L2 Cache的存在，其访问速度大于主存，因此避免了因频繁写时造成的写缓冲饱和溢出。
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389312170429.png)

------

  例题：关于Cache的更新策略，下列说法中正确的是：
  A.读操作时，全写法和写回法在命中时应用
  B.写操作时，写回法和写分配法在命中时应用
  C.读操作时，全写法和写分配法在失效时应用
  D.写操作时，写分配法、非写分配法在失效时应用

  答案：D；写回法和全写法是在命中Cache的情况下使用的，写不命中时，采用写分配法或非写分配法

  例题：某32位计算机按字节编址，Cache容量为16KB，Cache行的大小为16B，若主存与Cache地址映像采用直接映像方式，则主存地址为0x1234E8F8的单元装入Cache的地址是（）
  A.00010001001101  B.01000100011010  C.10100011111000  D.11010011101000

  答案：C;Cache容量为16KB=214B，Cache地址长14位，分为2段，高10位表示块号，低4位表示块内地址

  例题：某存储系统中，主存容量是Cache容量的4096倍，Cache被分为64个块，当主存地址和Cache地址采用直接映像方式时，地址映射表的大小应为（）（假设不考虑一致维护和替换算法位）
  A.6x4097bit  B.64x12bit
  C.6x4096bit  D.64x13bit

  答案：D；地址映射表也即标记阵列，Cache有64行，该标记阵列每行存储1个标记项，其中主存标记项为12位（主存容量是Cache的4096倍，即地址长度比Cache长12位，多出的长度即为标记位长度），加上1位有效位，因此总共大小为64x13bit;

  例题：有效容量为128KB的Cache，每块16B，采用8路组相联。字节地址为1234567H的单元调入该Cache，则其Tag应为（）
  A.1234H  B.2468H  C.048DH  D.12345H

  答案：C;块内地址字段4位

  例题：有一主存-Cache层次的存储器，其主存容量为1MB，Cache容量为16KB，每块有8个字，每字32位，采用直接地址映像方式，若主存地址为35301H，且CPU访问Cache命中，则在Cache的第（）（10进制表示）字块中（Cache起始字块为第0字块）

  答案：152；

  例题：有如下C语言程序段：

```c
for( k=0;k<1000;k++ )
	a[k]=a[k]+32;
12
```

  若数组a和变量k均为int型，int型数据占4B，数据Cache采用直接映射方式，数据区大小为1KB、块大小为16B，该程序段执行前Cache为空，则该程序段执行过程中访问数组a的Cache缺失率约为（）

  答案：12.5%；8次访问一次缺失

  例题：对于高速缓存、主存、硬盘构成的三级存储体系，CPU访问该存储系统时发送的地址为（）
  A.高速缓冲地址  B.虚拟地址  C.主存物理地址  D.磁盘地址

  答案：C；当CPU访存时，要先到Cache中查看该主存地址是否在Cache中，所以发送的是主存物理地址。只有在虚拟存储器中，CPU发出的才是虚拟地址，这里并未指出是虚拟存储系统。

  例题：采用指令Cache与数据Cache分离的主要目的是（）
  A.降低Cache的缺失损失  B.提高Cache的命中率
  C.降低CPU的平均访存时间  D.减少指令流水线资源冲突

  答案：把指令Cache与数据Cache分离后，取指与取数分别到不同的Cache中寻找，则指令流水线中取指部分和取数部分就可以很好地避免冲突，即减少了指令流水线的冲突。

  例题：某C语言程序段如下：

```c
for( i=0;i<=9;i++ )
{
	temp=1;
	for( j=0;j<=i;j++ ) temp*=a[j];
	sum+=temp;
}
123456
```

下列关于数组a的访问局部性的描述中，正确的是：
  A.时间局部性和空间局部性皆有  B.无时间局部性，有空间局部性
  C.有时间局部性，无空间局部性  D.时间局部性和空间局部性皆无

  答案：A；时间局部性是，一旦一条指令被执行，它就可能在不久的将来再被执行。空间局部性是，一旦一个存储单元被访问，它附近的存储单元也很快被访问

  例题：设有8页的逻辑空间，每页有1024B，它们被映射到32块的物理存储区中，则按字节编址逻辑地址的有效位是（），物理地址至少是（）位
  A.10,12  B.10,15  C.13,15  D.13,12

  答案：C；对于逻辑地址，表示页号地址有3位，页内地址10位；对于物理地址，块号5位，块内地址10位

  例题：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389312170430.png)

  答案：（1）4256bit  （2）6,5;数组首地址为320，每个存储单元存放一个数组元素，320/16/4=5,数组元素a[0][0]存放在块号5中，a[0][31]在块号6中，a[1][1]对应的行号为21，21mod8=5; （3）程序A的命中率为15/16，程序B的命中率为0，程序A的执行时间更短

  例题：有一Cache系统，字长为16位，主存容量为16字x256块，Cache的容量为16字x8块，采用全相联映射
  （1）主存和Cache的容量各为多少字节？主存和Cache的字地址各为多少位
  （2）若原先已经依次装入了5块信息，问字地址338H所在的主存块将装入Cache块的块号及在Cache中的字地址是多少
  （3）若块表中地址为1的行中标记着36H的主存块号标志，Cache块号标志为5H，则在CPU送来主存的字地址为368H时是否命中？若命中，此时Cache的字地址为多少？

  答案：（1）8192B，256B，12位，7位  （2）高8位为主存块号，低4位为块内地址，块号101，字地址1011000B；  （3）命中，字地址为58H

  例题：某个Cache的容量大小为64KB，行长为128B，且是四路组相联Cache，主存使用32位地址，按字节编址
  （1）该Cache共有多少行、多少组
  （2）该Cache的标记阵列中需要有多少标记项？每个标记项中标记位长度是多少？
  （3）该Cache采用LRU替换算法，若当该Cache为写直达式Cache时，标记阵列总共需要多大的存储容量？写回式又该如何？（四路组相联Cache使用LRU算法的替换控制位为2位）

  答案：（1）512行、128组  （2）512个，18位  （3）1344B，1408B

  例题：某32位计算机，CPU主频为800MHz，Cache命中时的CPI为4，Cache块大小为32B；主存采用8体交叉存储方式，每个体的存储字长为32位，存储周期为40ns；存储器总线宽度为32位，总线时钟频率为200MHz，支持突发传送总线事务。每次读突发传送总线事务的过程包括：送首地址和命令、存储器准备数据、传送数据。每次突发传送32B，传送地址或32位数据均需要一个总线时钟周期。
  （1）CPU和总线的时钟周期各为多少？总线的带宽（即最大数据传输率）为多少？
  （2）Cache缺失时，需要用几个读突发传送总线事务来完成一个主存块的读取？
  （3）存储器总线完成一次读突发传送总线事务所需的时间是多少
  （4）若程序BP执行过程中共执行了100条指令，平均每条指令需进行1.2次访存，Cache缺失率为5%，不考虑替换等开销，则BP的CPU平均执行时间是多少

  答案：（1）1.25ns，5ns，800MB/s
  （2）Cache块大小为32B，因此Cache缺失时需要一个读突发传送总线事务读取一个主存块
  （3）一次读突发传送总线事务包括一次地址传送和32B数据传送：用1个总线时钟周期传送地址，第一个体读数据花费40ns，之后数据存取和数据传输重叠，总时间为5+40+8x5=85ns
  （4）一条指令的平均CPU执行时间包括Cache命中时的指令执行时间和Cache缺失时带来的额外开销。Cache命中时的一条指令执行时间=4x1.25ns=5ns。一条指令执行过程中因Cache缺失而导致的平均额外开销=平均访存次数xCache缺失率x一次读突发传送总线事务时间=1.2x5%x85ns=5.1ns；一条指令的平均CPU执行时间=10.1ns。BP的CPU执行时间=10.1nsx100=1010ns。

  例题：![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389312170431.png)

  答案：（1）A=19，B=19，C=11，D=13，E=9，F=9，G=6
TLB中标记字段B的内容是虚页号
  （2）块号=标记+组号，组号为3，H字段内容为000001000B
  （3）处理缺页开销大，因为缺页处理需要访问磁盘，Cache缺失只需访问主存
  （4）因为采用直写策略需要同时写快速存储器和慢速存储器，而写磁盘比写主存慢很多，所以在Cache-主存层次，可采用直写策略，而在主存-外存层次，修改页面内容时总是采用回写策略

  例题：有一全相联Cache系统，Cache由8个块构成，CPU送出的主存地址流序列分别为01110，10010，01110，10010，01000，00100，01000和01010，即十进制为14，18,14，18，8，4,8,10
  （1）求每次访问后，Cache的地址分配情况
  （2）当Cache的容量换成4个块，地址流为6,15，6，13,11，10，8和7时，求采用先进先出替换算法的相应地址分配和操作

  答案：（1）![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389312170432.png)
（2）
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389312170433.png)

------

### 3.7 虚拟存储器

  主存和联机工作的辅存共同构成了虚拟存储器，二者在硬件和系统软件的共同管理下工作。 对于应用程序员而言，虚拟存储器是透明的。虚拟存储器具有主存的速度和辅存的容量

####  3.7.1 虚拟存储器的基本概念

  虚拟存储器将主存或辅存的地址空间统一编址，形成一个庞大的地址空间，在这个空间内，用户可以自由编程，而不必在乎实际的主存容量和程序在主存中实际的存放位置。
  用户编程允许涉及的地址称为虚地址或逻辑地址，虚地址对应的存储空间称为虚拟空间或程序空间。 实际的主存单元地址称为实地址或物理地址，实地址对应的是主存地址空间，也称实地址空间。虚地址比实地址要大很多。虚拟存储器的地址空间如图：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389312170434.png)
  CPU使用虚地址时，由辅助硬件找出虚地址和实地址之间的对应关系，并判断这个虚地址对应的存储单元内容是否已装入主存。若已在主存中，则通过地址变换，CPU可直接访问主存指示的实际单元；若不在主存中，则把包含这个字的一页或一段调入主存后再由CPU访问。若主存已满，则采用替换算法置换主存中的一页或一段。
  在实际的物理存储层次上，所编程序和数据在操作系统管理下，先送入磁盘，然后操作系统将当前运行所需要的部分调入主存，供CPU使用，其余暂不运行的部分则留在磁盘中。

####  3.7.2 页式虚拟存储器

  以页为基本单位的虚拟存储器称为页式虚拟存储器。 虚拟空间与主存空间都被划分为同样大小的页， 主存的页称为实页，虚存的页称为虚页。把虚拟地址分为两个字段：虚页号和页内地址。虚拟地址到物理地址的转换是由页表实现的。 页表是一张存放在主存中的虚页号和实页号的对照表，它记录程序的虚页调入主存时被安排在主存中的位置。页表一般长久地保存在内存中。
  下图为一个页表示例:
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389312170435.png)
  有效位也称装入位，用来表示对应页面是否在主存， 若为1，则表示该虚拟页已从外存调入主存，此时页表项存放该页的物理页号； 若为0，则表示没有调入主存，此时页表项可以存放该页的磁盘地址。 脏位也称修改位，用来表示页面是否被修改过， 虚存机制中采用回写策略，利用脏位可判断替换时是否需要写回磁盘。 引用位也称使用位，用来配合替换策略进行设置， 例如是否实现最先调入（FIFO位）或最近最少使用（LRU位）策略等。
  CPU执行指令时，需要先将虚拟地址转换为主存物理地址。每个进程都有一个页表基址寄存器，存放该进程的页表首地址，然后根据虚拟地址高位部分的虚拟页号找到对应的页表项， 若装入位为1，则取出物理页号，和虚拟地址低位部分的页内地址拼接，形成实际物理地址；若装入位为0，则说明缺页，需要OS进行缺页处理。
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389312170436.png)
  页式虚拟存储器的优点是，页面长度固定，页表简单，调入方便。缺点是，由于程序不可能正好是页面的整数倍，最后一页的零头将无法利用而造成浪费，并且页不是逻辑上独立的实体，所以处理、保护和共享都不及段式虚拟存储器方便。

------

  在虚拟存储器中，页面不能设置得过大，也不能设置过小：
  页面太小时，平均页内剩余空间较少，可节省存储空间，但会使得页表增大，而且页面太小时不能充分利用访存的空间局部性来提高命中率；页面太大时，可减少页表空间，但平均页内剩余空间较大，会浪费较多存储空间，页面太大还会使页面调入/调出的时间较长

------

####  3.7.3 加快地址转换：快表（TLB）

  由地址转换过程可知，访存时先访问一次主存去查页表，再访问主存才能取得数据。如果缺页，还要进行页面替换、页面修改等，因此采用虚拟存储机制后，访问主存的次数更多了。
  依据程序执行的局部性原理，在一段时间内总是经常访问某些页时，若把这些页对应的页表项存放在高速缓冲器组成的快表（TLB）中，则可以明显提高效率。相应地把放在主存中的页表称为慢表（Page）。在地址转换时，首先查找快表，若命中，则无须访问主存中的页表。
  快表通常采用全相联或组相联方式。 每个TLB项由页表表项内容加上一个TLB标记字段组成，TLB标记用来表示该表项取自页表中哪个虚页号对应的页表项， 因此，TLB标记的内容在全相联方式下就是该页表项对应的虚页号；组相联方式下则是对应虚页号的高位部分，虚页号的低位部分用于选择TLB组的组索引。
  下图为一个具有TLB和Cache的多级存储系统：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389312170437.png)
  图中Cache采用二路组相联方式。CPU给出一个32位的虚拟地址，TLB采用全相联方式，每一项都有一个比较器，查找时将虚页号与每个TLB标记字段同时进行比较，若有一项相等且对应有效位为1，则TLB命中，此时可直接通过TLB进行地址转换；若未命中，则TLB缺失，需要访问主存去查页表。图中所示的是两级页表方式，虚页号被分成目录索引和页表索引两部分，由这两部分得到对应的页表项，从而进行地址转换，并将相应表项调入TLB，若TLB已满，则还需要采用替换策略。完成由虚拟地址到物理地址的转换后，Cache机构根据映射方式将物理地址划分为多个字段，然后根据映射规则找到对应的Cache行或组，将对应Cache行中的标记与物理地址中的高位部分进行比较，若相等且对应有效位为1，则Cache命中，此时根据块内地址取出对应的字送CPU。
  查找时，快表和慢表也可以同步进行，若快表中有此虚页号，则能很快地找到对应的实页号，并使慢表的查找作废。
  在一个具有Cache和TLB的虚拟存储系统中，CPU一次访存操作可能涉及TLB、页表、Cache、主存和磁盘的访问，访问过程如图：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389312170438.png)
  CPU访存过程中存在3种缺失情况：（1）TLB缺失：要访问的页面对应的页表项不在TLB中；（2）Cache缺失：要访问的主存块不在Cache中；（3）缺页：要访问的页面不在主存中
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389312170439.png)
  第一种组合无须访问主存；第2种和第3种组合需访问一次主存；第4种组合需要访问2次主存；第5种组合发生缺页异常，需访问磁盘，并且至少访问两次主存。Cache缺失处理由硬件完成；缺页处理由软件完成，由OS通过缺页异常处理程序来实现；而TLB缺失既可以用硬件又可以用软件来处理，比如OS有专门的TLB缺失异常处理程序。

####  3.7.4 段式虚拟存储器

  段式虚拟存储器中的段是按程序的逻辑结构划分的，各个段的长度因程序而异。 把虚拟地址分为两部分：段号和段内地址。 虚拟地址到实地址之间的变换是由段表来实现的。段表是程序的逻辑段和在主存中存放位置的对照表。 段表的每行记录与某个段对应的段号、装入位、段起点和段长等信息。由于段的长度可变，所以段表中要给出各段的起始地址与段的长度。
  CPU根据虚拟地址访存时，首先根据段号与段表基地址拼接成对应的段表行，然后根据该段表行的装入位判断该段是否已调入主存。已调入主存时，从段表读出该段在主存中的起始地址，与段内地址（偏移量）相加，得到对应的主存实地址。
  段式虚拟存储器的优点是，段的分界与程序的自然分界相对应，因而具有逻辑独立性， 使得它易于编译、管理、修改和保护，也便于多道程序的共享；缺点是因为段的长度可变，分配空间不便，容易在段间留下碎片，造成浪费。

####  3.7.5 段页式虚拟存储器

  把程序按逻辑结构分段，每段再划分为固定大小的页，主存空间也划分为大小相等的页，程序对主存的调入、调出仍以页为基本传送单位，这样的虚拟存储器称为段页式虚拟存储器。 在段页式虚拟存储器中，每个程序对应一个段表，每段对应一个页表，段的长度必须是页长的整数倍，段的起点必须是某一页的起点。
  虚地址分为段号、段内页号、页内地址三部分。CPU根据虚地址访存时，首先根据段号得到段表地址；然后从段表中取出该段的页表起始地址，与虚地址段内页号合成，得到页表地址；最后从页表中取出实页号，与页内地址拼接形成主存实地址。
  段页式虚拟存储器兼具页式和段式虚拟存储器的优点，可以按段实现共享和保护。缺点是在地址变换过程中需要两次查表，系统开销较大。

####  3.7.6 虚拟存储器与Cache的比较

#####   1.相同之处

  （1）最终目标都是为了提高系统性能，两者都有容量、速度、价格的梯度
  （2）都把数据划分为小信息块，并作为基本的传递单位，虚存系统的信息块更大
  （3）都有地址的映射、替换算法、更新策略等问题
  （4）依据程序的局部性原理应用快速缓存的思想，将活跃的数据放在相对高速的部件中

#####   2.不同之处

  （1）Cache主要解决系统速度，而虚拟存储器是为了解决主存容量
  （2）Cache全由硬件实现，是硬件存储器，对所有程序员透明；而虚拟存储器由OS和硬件共同实现，是逻辑上的存储器，对系统程序员不透明，但对应用程序员透明
  （3）对于不命中性能影响，因为CPU的速度约为Cache的10倍，主存的速度为硬盘的100倍以上，因此虚拟存储器系统不命中时对系统性能的影响更大
  （4）CPU与Cache和主存都建立了直接访问的通路，而辅存与CPU没有直接通路。即在Cache不命中时主存能和CPU直接通信，同时将数据调入Cache；而虚拟存储器系统不命中时，只能先由硬盘调入主存，而不能直接和CPU通信。

------

  例题：虚拟存储管理系统的基础是程序访问的局部性原理，此理论的基本含义是（）
  A.在程序的执行过程中，程序对主存的访问是不均匀的
  B.空间局部性
  C.时间局部性
  D.代码的顺序执行

  答案：A；

  例题：![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389312170440.png)
  答案：（1）24位，高12位；20位，高8位；
  （2）![在这里插入图片描述](E:\Development\Typora\images\20200820150130817.png)
  （3）在主存中，04C60H；主存块映射到Cache的第3行，由于该行标记105H！=04CH，因此未命中
  （4)虚页号中高11位为TLB标记，最低1位为TLB组号。 该虚拟地址所对应的物理页面映射到TLB的第0组，组0中存在有效位为1，标记=012H的项，因此访问TLB命中，即虚拟地址所在的页面在主存中

  例题：![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389312170441.png)

  答案：（1）4889、3245、缺页中断、1272、缺页中断、5332
  （2）第二页不在内存，产生缺页中断，根据改进的Clock算法，第三页为未被引用和修改的页面，因此淘汰。新页面进入：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389312170542.png)
地址转换变为：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389312170543.png)

  例题：![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389312170544.png)
  答案：（1）80324；（2）96128；（3）该页面在快表（页表)中无记录

  例题：一个两级存储器系统有8个磁盘上的虚拟页面需要映像到主存的4个页中。某程序生成以下访存页面序列：1,0，2，2，1,7，6，7,0，1，2，0,3，0，4，5，1，5，2，4，5，6,7，6,7,2，4，2,7，3；采用LRU替换策略，设初始时主存为空
（1）画出每个页号访问请求之后存放在主存中的位置
（2）计算主存的命中率

  答案：（1）![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389312170545.png)
（2)13/30

  例题：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389312170546.png)
  答案：（1）28位；（2）全相联映射，SRAM；（3）2路组相联，需要1位LRU位（LRU位位数与Cache组大小有关，每组若有2个Cache行，则需1位LRU位），1位脏位；8x2x(1+1+1+20+8x2^5)=558B;Cache中有效位用来指出所在Cache行中的信息是否有效；（4)0040040H，将00400H与Cache中第2组两行中的标志字段同时比较，虽然有一个Cache行中的标志字段与00400H相等，但对应的有效位为0，而另一行的标志字段不相等，因此访问Cache不命中；组号为3





## 4.指令系统

### 4.1 指令格式

  `指令`（又称机器指令）是指示计算机执行某种操作的命令，是计算机运行的最小功能单位。**一台计算机的所有指令的集合构成该机的指令系统，也称指令集**。 指令系统是计算机的主要属性，位于硬件和软件的交界面上。

####  4.1.1 指令的基本格式

  一条指令就是机器语言的一个语句，它是一组有意义的[二进制](https://so.csdn.net/so/search?q=二进制&spm=1001.2101.3001.7020)代码。一条指令通常包括`操作码字段和地址码`字段两部分：
![在这里插入图片描述](E:\Development\Typora\images\20200820210026453.png)
  

- **操作码指出指令中该指令应该执行什么性质的操作和具有何种功能**。

  - 操作码是识别指令、了解指令功能及区分操作数地址内容的组成和使用方法等的关键信息。
  - 例如，指出是**算术加运算**还是**算术减运算**，是**程序转移**还是**返回操作**。

- **地址码给出被操作的信息（指令或数据）的地址**

  - （这里的“地址”可以是主存地址，也可以是寄存器的地址，甚至可以是I/O设备的地址)，包括参加运算的一个或多个操作数所在的地址、运算结果的保存地址、程序的转移地址、被调用的子程序的入口地址等。

- **指令的长度是指一条指令中所包含的二进制代码的位数**。

  - 指令字长取决于操作码的长度、操作数地址码的长度和操作数地址的个数。指令长度与机器字长没有固定的关系，它可以等于机器字长，也可以大于或小于机器字长。
  - 通常，**把指令长度等于机器字长的指令称为单字长指令，指令长度等于半个机器字长的指令称为半字长指令，指令长度等于两个机器字长的指令称为双字长指令**。

- 在一个指令系统中，若所有指令的长度都是相等的，则称为`定长指令字结构`。若各种指令的长度随指令功能而异，则称为`变长指令字结构`。 因为主存一般是按字节编址的，所以指令字长多为字节的整数倍。

  ![image-20220930083954685](E:/Development/Typora/images/image-20220930083954685-1676269101987-3.png)

  ​	`显地址`：如果在指令代码中明显地给出地址，如在指令中写明主存储器单元地址或者寄存器号，则这种地址称为显地址。

  ​	隐地址：如果地址是以隐含方式约定的，指令中并不出现该地址，则称为隐地址。如事先约定操作数是在某个寄存器中等。

  > 一条指令中给出几个显地址，就称为几地址指令

  根据指令中操作数地址码的数目的不同，可将指令分成以下几种格式：

#####   1.零地址指令

![在这里插入图片描述](E:\Development\Typora\images\20200820211452346.png)
  **只给出操作码OP，没有显式地址。**这种指令有两种可能：
  （1）不需要操作数的指令，如空操作指令、停机指令、关中断指令等
  （2)**零地址的运算类指令仅用在堆栈计算机中**。通常参与运算的两个操作数隐含地从栈顶和次栈顶弹出，送到运算器进行运算，运算结果再隐含地压入堆栈。

#####   2.一地址指令

![在这里插入图片描述](E:\Development\Typora\images\20200820211843139.png)
  根据操作码的含义不同，有两种常见形态：
  （1）只有目的操作数的单操作数指令，<u>按A1地址读取操作数，进行OP操作后</u>，**结果存回原地址**。指令含义：`OP（A1）——>A1`；
  **如操作码含义是加1、减1、求反、求补等**
  （2）隐含约定目的地址的双操作数指令，按指令地址A1可读取源操作数，指令可隐含约定另一个操作数由**ACC**提供，运算结果也将存放在ACC中。指令含义：（ACC）OP（A1)——>ACC；
  若指令字长为32位，操作码占8位，1个地址码字段占24位，则指令操作数的直接寻址范围为2^24=16M；

#####   3.二地址指令

![在这里插入图片描述](E:\Development\Typora\images\20200820212636437.png)

  指令含义：`（A1）OP（A2）——>A1`；
  对于常用的算术和逻辑运算指令，往往要求使用两个操作数，需分别给出目的操作数和源操作数的地址，其中**目的操作数地址还用于保存本次的运算结果**。
  若指令字长为32位，操作码占8位，两个地址码字段各占12位，则指令操作数的直接寻址范围为2^12=4K

#####   4.三地址指令

![在这里插入图片描述](E:\Development\Typora\images\20200820213105887.png)

  指令含义：`（A1）OP（A2）——>A3`

​		(PC)+n->PC(隐含)

  若指令字长为32位，操作码占8位，3个地址码字段各占8位，则指令操作数的直接寻址范围为2^8=256。若地址字段均为主存地址，则完成一条三地址需要4次访问存储器（取指令1次，取两个操作数2次，存放结果1次）

#####   5.四地址指令

![在这里插入图片描述](E:\Development\Typora\images\20200820213514710.png)
  指令含义：`（A1）OP（A2)——>A3，A4=下一条将要执行指令的地址`

​			（A4）→PC

  若指令字长为32位，操作码占8位，4个地址码字段各占6位，则指令操作数的直接寻址范围为$2^6$=64

##### 总结：

1.显地址数多，指令长，所需存储空间大，读取时间长

2.显地址数少，地址选择受限制



####  4.1.2 定长操作码指令格式

  定长操作码指令**在指令字的最高位部分分配固定的若干位（定长）表示操作码。**

​			一般n位操作码字段的指令系统最大能够表示$2^n条$指令。

####  4.1.3 扩展操作码指令格式

  为了在指令字长有限的前提下仍保持比较丰富的指令种类，可采取可变长度操作码，即**全部指令的操作码字段的尾数不固定，且分散地放在指令字的不同位置上**。
  最常见的变长操作码方法是`扩展操作码`，它**使操作码的长度随地址码的减少而增加**，不同地址数的指令可具有不同长度的操作码， 从而在满足需要的前提下，有效地缩短指令字长。下图为一种扩展操作码的安排方式：
  

​		在图中，指令字长为16位，其中4位为基本操作码字段OP，另有3个4位长的地址字段A1、A2、A3。图中所示的三地址指令为15条，1111留作扩展操作码之用；二地址指令15条，1111 1111留作扩展操作码之用；一地址指令为15条，1111 1111 1111留作扩展操作码之用；零地址指令为16条。
  除这种安排外，还有其他多种扩展方法，如形成15条三地址指令、12条二地址指令、63（3x16+15）条一地址指令和16条零地址指令。
  在设计扩展操作码指令格式时，须注意：
  （1）不允许短码是长码的前缀，**即短操作码不能与长操作码的前面部分的代码相同**
  （2)各指令的操作码不能重复

  通常情况下，对使用频率较高的指令分配较短的操作码，对使用频率较低的指令分配较长的操作码。

------

  `例题`：一个计算机系统采用32位单字长指令，地址码为12位，若定义了250条二地址指令，则还可以有（）条单地址指令

  答案：24K；

  `例题`：一处理器中共有32个寄存器，使用16位立即数，其指令系统结构中共有142条指令。在某个给定的程序中，20%的指令带有一个输入寄存器和一个输出寄存器；30%的指令带有两个输入寄存器和一个输出寄存器；25%的指令带有一个输入寄存器、一个输出寄存器、一个立即数寄存器；其余25%的指令带有一个立即数输入寄存器和一个输出寄存器。
  （1）对于以上4种指令类型中的任意一种指令类型来说，共需多少位？假定指令系统结构要求所有指令长度必须是8的整数倍
  （2）与使用定长指令集编码相比，当采用变长指令集编码时，该程序能够少占用多少存储器空间？

  答案：（1）由于有142条指令，因此至少需要8位才能确定各条指令的操作码。20%的一个输入寄存器和一个输出寄存器指令需要18位，对齐到24位；30%的两个输入寄存器和一个输出寄存器需要23位，对齐到24位；25%的一个输入寄存器、一个输出寄存器、一个立即数寄存器指令需要34位，对齐到40位；25%的一个立即数输入寄存器和一个输出寄存器需要29位，对齐到32位；
  （2）由于变长指令最长的长度为40位，所以定长指令编码每条指令的长度均为40位。而采用变长编码，平均长度为30位。能少占用25%的存储空间。

  `例题`：假设指令字长为16位，操作数的地址码为6位，指令有零地址、一地址、二地址三种格式。
  （1）设操作码固定，若零地址指令有M种，一地址指令有N种，则二地址指令最多有几种
  （2）采用扩展操作码技术，二地址指令最多有几种
  （3）采用扩展操作码技术，若二地址指令有P条，零地址指令有Q条，则一地址指令最多有几种

  答案：（1）16-M-N；（2）15种；（3）（16-P）x 2^6-Q x 2 ^(-6);二地址指令操作码每减少一个，可多构成2 ^6条一地址指令操作码；一地址指令操作码每减少一个，可多构成2 ^6条零地址指令操作码；

  `例题`：在一个36位长的指令系统中，设计一个扩展操作码，使之能表示下列指令：
  （1）7条具有两个15位地址和一个3位地址的指令
  （2）500条具有一个15位地址和一个3位地址的指令
  （3）50条无地址指令

  答案：![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638934506541.png)
  `例题`：某模型机共有64种操作码，位数固定，且具有以下特点：
  （1）采用一地址或二地址格式
  （2）有寄存器寻址、直接寻址和相对寻址（位移量为-128~+127）3种寻址方式
  （3）有16个通用寄存器，算术运算和逻辑运算的操作数均在寄存器中，结果也在寄存器中
  （4）取数/存数指令在通用寄存器和存储器之间传送数据
  （5)存储器容量为1MB，按字节编址
  要求设计算术逻辑指令，取数/存数指令和相对转移指令的格式，并简述理由

  答案：应有寻址特征位；
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638934506542.png)
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638934506543.png)

------

### 4.2 指令的寻址方式

  寻址方式是指寻找指令或操作数有效地址的方式，即确定本条指令的数据地址及下一条待执行指令的地址的方法。寻址方式分为指令寻址和数据寻址两大类。
  指令中的地址码字段并不代表操作数的真实地址，这种地址称为形式地址A。形式地址结合寻址方式，可计算出操作数在存储器中的真实地址，这种地址称为有效地址EA。

####  4.2.1 指令寻址和数据寻址

  寻找下一条将要执行的指令地址称为指令寻址； 寻找操作数的地址称为数据寻址。

#####   1.指令寻址

  指令寻址方式有两种：**顺序寻址**方式与**跳跃寻址**方式。
  （1）顺序寻址可通过PC+1（1个指令字长），自动形成下一条指令的地址
  （2）跳跃寻址通过转移类指令实现。

> 所谓跳跃，是指下一条指令的地址码不由程序计数器(PC)给出，而由本条指令给出下条指令地址的计算方式。 是否跳跃可能受状态寄存器和操作数的控制，而跳跃到的地址分为绝对地址（由标记符直接得到）和相对地址（相对于当前指令地址的偏移量），跳跃的结果是当前指令修改PC值，所以下一条指令仍然通过PC给出。

#####   2.数据寻址

  为区别数据寻址的不同方式，**通常在指令字中设一个字段**==（寻址特征）==，用来指明属于哪种寻址方式。
![在这里插入图片描述](E:\Development\Typora\images\20200821090108981.png)

####  4.2.2 常见的数据寻址方式

#####   1.隐含寻址

  这种类型的指令**不明显地给出操作数的地址，而在指令中隐含操作数的地址。** 

​	   例如，单地址的指令格式就不明显地在地址字段中指出第二操作数的地址，而规定累加器ACC作为第二操作数地址，指令格式明显指出的仅是第一操作数的地址。因此，累加器ACC对单地址指令格式来说是隐含寻址。
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638934506554.png)
  

> 隐含寻址的优点是有利于缩短指令字长；
>
> 缺点是需增加存储操作数或隐含地址的硬件。

#####   2.立即（数）寻址 I

  这种类型的指令的地址字段指出的不是操作数的地址，而是操作数本身，又称**立即数**。 数据采用补码形式存放。
![在这里插入图片描述](E:\Development\Typora\images\20200821091229524.png)

​		#表示立即寻址特征，A就是操作数本身

> 立即寻址的优点是指令在执行阶段不访问主存，指令执行时间最短； 
>
> 缺点是A的位数限制了立即数的范围。

#####   3.直接寻址A

  指令字中的形式地址A是操作数的真实地址EA，即`EA=A`
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638934506555.png)
 

> 直接寻址的优点是简单，指令在执行阶段仅访问一次主存，不需要专门计算操作数的地址；
>
> 缺点是A的位数决定了该指令操作数的寻址范围，操作数的地址不易修改。

#####   4.间接寻址 @A

  指令的地址字段给出的形式地址不是操作数的真实地址，而是操作数有效地址所在的存储单元的地址，也就是操作数地址的地址，即`EA=（A）`。**间接寻址可以是一次间接寻址，也可是多次间接寻址**。
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638934506556.png)
  

​		在图中两次间接寻址中，主存字第一位为1时，表示取出的仍不是操作数的地址，即多次间址；主存字第一位为0时，表示取得的是操作数的地址。 （当多次间接寻址时，可用存储字的首位来标志间接寻址是否结束，存储字的首位不能作为EA的组成部分）

> 间接寻址的优点是可扩大寻址范围（有效地址EA的位数大于形式地址A的位数）， 便于编制程序（用间接寻址可方便地完成子程序返回）；
>
> 缺点是指令在执行阶段要多次访存（一次间接寻址需2次访存，多次间接寻址需根据存储字的最高位确定访存次数)。 由于访问速度过慢，这种寻址方式并不常用。一般问到扩大寻址范围时，通常指的是寄存器间接寻址。

#####   5.寄存器寻址 R

  寄存器寻址是指在指令字中**直接给出操作数所在的寄存器的编号**，即`EA=Ri`，其操作数在由Ri所指的寄存器内。![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638934506557.png)
  

> 寄存器寻址的优点是指令在执行阶段不访问主存，只访问寄存器， 因寄存器数量较少，对应地址码长度较小，使得指令字短且因不用访存，所以执行速度快，支持向量/矩阵运算；
>
> 缺点是寄存器价格昂贵，计算机中的寄存器数量有限。

#####   6.寄存器间接寻址 @R

  寄存器间接寻址是指在寄存器Ri中给出的不是一个操作数，而是操作数所在主存单元的地址，即`EA=（Ri）`。
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638934506558.png)
  

> 寄存器间接寻址的特点是，与一般间接寻址相比速度更快，但指令的执行阶段需要访问主存（因为操作数在主存中)。

###### 1.自增型寄存器间接寻址 (R)+

![image-20230214235326800](E:/Development/Typora/images/image-20230214235326800.png)



###### 2.自减型寄存器间址： -（R）

![image-20230214235429460](E:/Development/Typora/images/image-20230214235429460.png)



#####   7.相对寻址

  相对寻址是把PC的内容加上指令格式中的形式地址A而形成操作数的有效地址，即`EA=（PC）+A`，**其中A是相对于当前指令地址的位移量，可正可负，补码表示。**
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638934506559.png)

​		A的位数决定操作数的寻址范围。

  相对寻址的优点是操作数的地址不是固定的，它随PC值的变化而变化，且与指令地址之间总是相差一个固定值，因此便于程序浮动。 相对寻址广泛用于转移指令。

  对于转移指令JMP A，当CPU从存储器中取出一字节时，会自动执行（PC）+1——>PC。 若转移指令的地址为X，占2B，则在取出该指令后，PC的值会增2，即（PC）=X+2， 这样在执行完该指令后，会自动跳转到X+2+A的地址继续执行。

#####   8.基址寻址

  基址寻址是指将CPU中**基址寄存器（BR）**的内容加上指令格式中的形式地址A而形成操作数的有效地址，即`EA=（BR）+A`。 

- 其中基址寄存器既可采用专用寄存器，又可采用通用寄存器。
  - 基址寄存器可采用隐式的和显式的两种。
  - 所谓隐式，是在计算机内专门设有一个基址寄存器BR，使用时用户不必明显指出该基址寄存器，只需由指令的寻址特征位反映出基址寻址即可。
  - 显式是在一组通用寄存器里，由用户明确指出哪个寄存器作为基址寄存器

![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389345065610.png)
  ==基址寄存器是面向OS的==，其内容由OS或管理程序确定，主要用于解决程序逻辑空间与存储器物理空间的无关性。 在程序执行过程中，基址寄存器的内容不变（作为基地址），形式地址可变（作为偏移量)。 采用通用寄存器作为基址寄存器时，可由用户决定哪个寄存器作为基址寄存器，但其内容仍由OS确定。

  基址寻址的优点是可扩大寻址范围（基址寄存器的位数大于形式地址A的位数）；用户不必考虑自己的程序存于主存的哪个空间区域，因此有利于多道程序设计，并可用于编制浮动程序，但偏移量（形式地址A）的位数较短。

------

  基址寻址在多道程序中极为有用。用户可不必考虑自己的程序存于主存的哪一空间区域，完全可由OS或管理程序根据主存的使用情况，赋予基址寄存器内一个初始值（即基地址），便可将用户程序的逻辑地址转化为主存的物理地址（实际地址），把用户程序安置于主存的某一空间区域

------

#####   9.变址寻址 X(R)

  变址寻址是指有效地址EA等于指令字中的形式地址A与变址寄存器IX的内容之和，即`EA=（IX）+A`， 其中IX为变址寄存器（专用），也可用通用寄存器作为变址寄存器。
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389345065611.png)
  `变址寄存器是面向用户的`，在程序执行过程中，变址寄存器的内容可由用户改变（作为偏移量），形式地址A不变（作为基地址)。

  变址寻址的优点是可扩大寻址范围（变址寄存器的位数大于形式地址A的位数）；在数组处理过程中，可设定A为数组的首地址，不断改变变址寄存器IX的内容，便可很容易形成数组中任一数据的地址，特别适合编制循环程序。 偏移量（变址寄存器IX)的位数足以表示整个存储空间。
  变址寻址与基址寻址的有效地址形成过程极为相似。但从本质上来讲，两者有较大区别。基址寻址面向系统，主要用于为多道程序或数据分配存储空间，因此基址寄存器的内容通常由OS或管理程序确定，在程序的执行过程中其值不可变，而指令字中的A是可变的；变址寻址立足于用户，主要用于处理数组问题，在变址寻址中，变址寄存器的内容由用户设定，在程序执行过程中其值可变，而指令字中的A是不可变的。

#####   10.堆栈寻址

  **堆栈是存储器（或专用寄存器组）中一块特定的、按后进先出原则管理的存储区，该存储区中读/写单元的地址是用一个特定的寄存器给出的，该寄存器称为堆栈指针（SP）。**堆栈可分为<u>硬堆栈</u>与<u>软堆栈</u>两种。

- 寄存器堆栈又称`硬堆栈`。寄存器堆栈的成本高，不适合做大容量的堆栈；
- 而从主存中划出的一段区域来做堆栈是最常用的方法，这种堆栈称`软堆栈`。

  在采用堆栈结构的计算机系统中，大部分指令表面上都表现为无操作数指令的形式，因为操作数地址都隐含使用了SP。==通常，在读/写堆栈中的一个单元的前后都伴有自动完成对SP内容的增量或减量操作==



![image-20230214235553346](E:/Development/Typora/images/image-20230214235553346.png)

------

  寻址方式、有效地址、访存次数（不包含为取本条指令而做的访存）的总结：

![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389345065612.png)

>     各常见指令寻址方式的特点和适用情况：
>
>   1.   立即寻址操作数获取便捷，通常用于给寄存器赋初值
>   2.   直接寻址相对于立即寻址，缩短了指令长度
>   3.   间接寻址扩大了寻址范围，便于编制程序，易于完成子程序返回
>   4.   寄存器寻址的指令字较短，指令执行速度较快
>   5.   寄存器间接寻址扩大了寻址范围
>   6.   基址寻址扩大了操作数寻址范围，适用于多道程序设计，常用于为程序或数据分配存储空间
>   7.   变址寻址主要用于处理数组问题，适合编制循环程序
>   8.   相对寻址用于控制程序的执行顺序、转移等

------

####  4.2.3 X86汇编指令入门

#####   1.相关寄存器

  X86处理器中有8个32位的通用寄存器，各寄存器及说明如图：

![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389345065613.png)
  为了向后兼容，EAX、EBX、ECX、EDX的高2位字节和低2位字节可独立使用，E为Extended，表示32位的寄存器。例如，EAX的低两位字节称为AX，而AX的高低字节又可分别作为两个8位寄存器，分别称为AH和AL。寄存器的名称大小写均可。

#####   2.寻址模式和内存分配

  （1）寻址模式
  以mov指令为例，mov用于在内存和寄存器之间移动数据，它有两个参数：第一个是目的地址，第二个是源地址。

```c
mov eax,[ebx]				;将ebx值指示的内存地址中的4字节传送到eax
mov [var],ebx				;将ebx值传送到var的值指示的内存地址中
mov eax,[esi-4]				;将esi-4值指示的内存地址中的4字节传送到eax
mov [esi+eax],cl			;将cl值传送到esi+eax值指示的内存地址中
mov edx,[esi+4*ebx]			;将esi+4*ebx值指示的内存中的4字节传送到edx
12345
```

  （2）数据类型长度规定
  在汇编语言中声明内存大小时，一般显式地使用DB（D表示Data，B表示Byte）、DW（W表示Word,2Bytes）和DD（Double Word,4Bytes）。X86提供了三个指示规则标记，分别为BYTE PTR、WORD PTR和DWORD PTR，如：

```c
mov byte ptr [ebx],2		;将2以单字节形式传送到ebx值指示的内存地址中
mov word ptr [ebx],2		;将2以双字节形式传送到ebx值指示的内存地址中
mov dword ptr [ebx],2		;将2以四字节形式传送到ebx值指示的内存地址中
123
```

#####   3.常用指令

  汇编指令通常可分为数据传送指令、逻辑计算指令和控制流指令。以下用于操作数的标记分别表示寄存器、内存和常数：
  < reg >:表示任意寄存器，若其后带有数字，则指定其位数，如< reg32 >表示32位寄存器（EAX、EBX、ECX、EDX、ESI、EDI、ESP或EBP）；< reg16 >表示16位寄存器（AX、BX、CX或DX）；< reg8 >表示8位寄存器（AH、AL、BH、BL、CH、CL、DH、DL）
  < mem >：表示内存地址（如[eax]、[var+4]或dword ptr[eax+ebx]）
  < con >:表示8位、16位或32位常数。如< con8 >表示8位常数;
  X86中的指令机器码长度为1字节，对同一指令的不同用途有多种编码方式，如：

```c
mov ax,<con16>			;机器码为B8H
mov al,<con8>			;机器码为B0H
mov <reg16>/<mem16>,<reg16>			;机器码为89H
mov <reg8>,<reg8>/<mem8>			;机器码为8AH
mov <reg16>,<reg16>/<mem16>			;机器码为8BH
12345
```

  （1）数据传送指令
  mov指令：
  mov指令将第二个操作数（寄存器的内容、内存中的内容或常数值）复制到第一个操作数（寄存器或内存）。但不能用于直接从内存复制到内存。

```c
语法：
mov <reg>,<reg>
mov <reg>,<mem>
mov <mem>,<reg>
mov <reg>,<con>
mov <mem>,<con>
例：
mov eax,ebx		;将ebx值复制到eax
mov byte ptr [var],5		;将5保存到var值指示的内存地址的一字节中
123456789
```

  push指令：
  push指令将操作数压入内存的栈，常用于函数调用。ESP是栈顶，压栈前先将ESP值减4（栈增长方向与内存地址增长方向相反），然后将操作数压入ESP指示的地址。

```c
语法：
push <reg32>
push <mem>
push <con32>
例：（栈中元素固定为32位）
push eax		;将eax值压栈
push [var]		;将var值指示的内存地址的4字节值压栈
1234567
```

  pop指令：
  出栈前先将ESP指示的地址中的内容出栈，然后将ESP值+4

```c
pop edi			;弹出栈顶元素送到edi
pop [ebx]		;弹出栈顶元素送到ebx值指示的内存地址的4字节中
12
```

  （2）算术与逻辑运算指令
  add/sub指令：
  add指令将两个操作数相加，相加的结果保存到第一个操作数中。sub指令用于两个操作数相减，相减的结果保存到第一个操作数中。

```c
语法：
add <reg>,<reg> / sub <reg>,<reg>
add <reg>,<mem> / sub <reg>,<mem>
add <mem>,<reg> / sub <mem>,<reg>
add <reg>,<con> / sub <reg>,<con>
add <mem>,<con> / sub <mem>,<con>
例：
sub eax,10		;eax<——eax-10
add byte ptr [var],10		;10与var值指示的内存地址的一字节值相加，并将
							结果保存在var值指示的内存地址的字节中
12345678910
```

  inc/dec指令
  inc/dec指令分别表示将操作数自加1、自减1

```c
语法：
inc <reg> / dec <reg>
inc <mem> / dec <mem>
例：
dec eax			;eax值自减1
inc dword ptr [var]			;var值指示的内存地址的4字节值自加1
123456
```

  imul指令
  带符号整数乘法指令，有两种格式：（1）两个操作数，将两个操作数相乘，结果保存在第一个操作数中，第一个操作数必须为寄存器；（2）三个操作数，将第二个和第三个操作数相乘，并将结果保存在第一个操作数中，第一个操作数必须为寄存器

```c
语法：
imul <reg32>,<reg32>
imul <reg32>,<mem>
imul <reg32>,<reg32>,<con>
imul <reg32>,<mem>,<con>
例：
imul eax,[var]				;eax<——eax*[var]
imul esi,edi,25				;esi<——edi*25
12345678
```

  乘法操作结果可能溢出，则编译器置溢出标志OF=1，以使CPU调出溢出异常处理程序；

  idiv指令：
  带符号整数除法指令，它只有一个操作数，即除数，而被除数则为edx:eax中的内容（64位整数），操作结果有两部分：商和余数，商送到eax，余数则送到edx。

```c
语法：
idiv <reg32>
idiv <mem>
例：
idiv ebx
idiv dword ptr [var]
123456
```

  and/or/xor指令
  逻辑与、逻辑或、逻辑异或操作指令，用于操作数的位操作，操作结果放在第一个操作数中

```c
语法：
and <reg>,<reg> / or <reg>,<reg> / xor <reg>,<reg> 
and <reg>,<mem> / or <reg>,<mem> / xor <reg>,<mem>
and <mem>,<reg> / or <mem>,<reg> / xor <mem>,<reg>
and <reg>,<con> / or <reg>,<con> / xor <reg>,<con>
and <mem>,<con> / or <mem>,<con> / xor <mem>,<con>
例：
and eax,0fH			;将eax中的前28位全部置0，最后4位保持不变
xor edx,edx			;置edx中的内容为0
123456789
```

  not指令
  取反

```c
语法：
not <reg>
not <mem>
例：
not byte ptr [var]		;将var值指示的内存地址的一字节的所有位翻转
12345
```

  neg指令
  取负

```c
语法：
neg <reg>
neg <mem>
例：
neg eax				;eax<——-eax
12345
```

  shl/shr指令
  逻辑移位指令，shl为逻辑左移，shr为逻辑右移，第一个操作数表示被操作数，第二个操作数指示移位的位数。

```c
语法：
shl <reg>,<con8> / shr <reg>,<con8>
shl <mem>,<con8> / shr <mem>,<con8>
shl <reg>,<cl> / shr <reg>,<cl>
shl <mem>,<cl> / shr <mem>,<cl>
例：
shl eax,1			;将eax值左移一位，相当于乘2
shr ebx,cl			;将ebx值右移n位（n为cl中的值），相当于除以2^n
12345678
```

  （3）控制流指令
  X86处理器维持着一个指示当前执行指令的指令指针IP。IP寄存器不能直接操作，但可用控制流指令更新。
  jmp指令：
  控制IP转移到label所指示的地址

```c
语法：
jmp <label>
例：
jmp begin
1234
```

  jcondition指令
  条件转移指令，它依据处理机状态字中的一系列条件状态转移。

```c
语法：
je <label> (jump when equal)
jne <label> (jump when not equal)
jz <label> (jump when last result was zero)
jg <label> (jump when greater than)
jge <label> (jump when greater than or equal to)
jl <label> (jump when less than)
jle <label> (jump when less than or equal to )
例：
cmp eax,ebx
jle done		;若eax的值小于ebx值，跳转到done指示的指令执行，否则执行
					下一条指令
123456789101112
```

  cmp指令
  比较两个操作数的值，并根据比较结果设置处理机状态字中的条件码，通常和jcondition指令搭配使用

```c
语法：
cmp <reg>,<reg>
cmp <reg>,<mem>
cmp <mem>,<reg>
cmp <reg>,<con>
例：
cmp dword ptr [var],10
jne loop 			;若var指示的内存地址的4字节内容=10，则继续执行下一条
					指令，否则跳转到loop指示的指令执行
123456789
```

  call/ret指令
  这两条指令实现子程序（过程、函数等）的调用及返回。call指令首先将当前执行指令地址入栈，然后无条件转移到由标签指示的指令。call指令保存调用之前的地址信息（当call指令结束后，返回调用之前的地址）。ret指令实现子程序的返回机制，ret指令弹出栈中保存的指令地址，然后无条件转移到保存的指令地址执行。

```c
call <label>
ret
12
```

------

  `例题`：指令系统中采用不同寻址方式的目的是（）
  A.提供扩展操作码的可能并降低指令译码难度
  B.可缩短指令字长，扩大寻址空间，提高编程的灵活性
  C.实现程序控制
  D.三者都正确

  答案：B;

  `例题`：为了缩短指令中某个地址段的位数，有效的方法是采取（）
  A.立即寻址  B.变址寻址  C.基址寻址  D.寄存器寻址

  答案：D；

  `例题`：相对寻址方式中，指令所提供的相对地址实质上是一种（）
  A.立即数  B.内存地址  C.以本条指令在内存中首地址为基准位置的偏移量  D.以下条指令在内存中首地址为基准位置的偏移量

  答案：D；

  `例题`：某计算机有16个通用寄存器，采用32位定长指令字，操作码字段（含寻址方式位）为8位，Store指令的源操作数和目的操作数分别采用寄存器直接寻址和基址寻址方式。若基址寄存器可使用任一通用寄存器，且偏移量用补码表示，则Store指令中偏移量的取值范围是（）
  A.-32768~+32767  B.-32767 ~+32768
  C.-65536~+65535  D.-65535 ~+65536

  答案：A；目的操作数采用基址寻址需指定寄存器，用4位，留给偏移地址16位

  `例题`：设相对寻址的转移指令占3B，第一字节为操作码，第二、三字节为相对转移量（补码表示），而且数据在存储器中采用以低字节为字地址的存放方式。每当CPU从存储器取出一字节时，即自动完成（PC）+1——>PC。若PC的当前值为240（10进制），要求转移到290（10进制），则转移指令的第二、三字节的机器代码是（）；若PC的当前值为240（10进制），要求转移到200（10进制），则转移指令的第二、三字节的机器代码是（）

  答案：2FH、00H;D5H、FFH；小端方式：低位存放在低地址，高位存放在高地址。低字节为字地址即小端方式。 大端方式：高位字节存放在低地址，低位字节存放在高地址，高位字节地址为字地址即大端方式。

  `例题`：某计算机指令系统采用定长操作码和变长指令码格式。
  （1）采用什么寻址方式时指令码长度最短？采用什么寻址方式时指令码长度最长？
  （2）采用什么寻址方式时执行速度最快？采用什么寻址方式时执行速度最慢？
  （3）若指令系统采用定长指令码格式，则采用什么寻址方式时执行速度最快

  答案：（1）寄存器寻址方式和寄存器间接寻址方式的指令码长度最短。立即寻址方式、直接寻址方式、间接寻址方式的指令码长度最长。若指令码长度太短，则无法表示范围较大的立即数和寻址到较大的内存地址空间
  （2）寄存器寻址方式执行速度最快（采用变长指令码格式，由于要表示一定范围内的立即数，包含立即数的指令通常需要较多的二进制位，取指令时，可能需要不止一次地读内存来完成取指令，因此寄存器寻址方式执行速度最快）；间接寻址方式执行速度最慢。
  （3）立即寻址方式执行速度最快（采用定长指令码格式时，所有指令所包含的二进制位相同）

  `例题`：![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389345065614.png)
![在这里插入图片描述](E:\Development\Typora\images\20200821152707754.png)
![在这里插入图片描述](E:\Development\Typora\images\20200821152720174.png)
  答案：（1）32；
  （2、3）寻址范围是一个数字范围，不带有单位。寻址范围的大小是一个数，指寻址区间的大小。注意变址寻址形式地址不变。
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389345065815.png)
  `例题`：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389345065816.png)
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389345065817.png)
  答案：（1）16,8，16,16；  （2）0000H~FFFFH；
  （3)2315H；自增操作在运算结束后进行，R5的内容由5678H变为5679H，存储单元5678H中的内容变为68ACH；

  `例题`：![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389345065818.png)

  答案：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389345065819.png)

  `例题`：![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389345065820.png)
![在这里插入图片描述](E:\Development\Typora\images\20200821161615986.png)
![在这里插入图片描述](E:\Development\Typora\images\20200821161654351.png)

![在这里插入图片描述](E:\Development\Typora\images\2020082116181522.png)

![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389345065921.png)
  答案：（1）按字节编址，最多后跳127条指令
  （2）1FD4H,200EH；
  （3）C=Z=1，N=0；CF在最高位有进、借位时置1，符号标志表示运算结果最高位（无符号数比较，若<=，运算结果最高位可能为1也可能为0，如10H-A0H=70H，最高位为0）
  （4)部件1为指令寄存器，用于存放当前指令；多路选择器左边线上的结果应为PC+2+2xOFFSET。部件2用于左移1位实现乘2，为移位寄存器。部件3用于PC+2和2xOFFSET相加，为加法器。

  `例题`：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389345065922.png)

![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389345065923.png)
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389345065924.png)

  答案：（1）128；  （2）0240H、0488H、06EAH；  （3）0，mov,mova,left,read,sub,mov,SRout  （4）4、2；读/写寄存器需1个时钟周期

  `例题`：
![在这里插入图片描述](E:\Development\Typora\images\2020082117154868.png)
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389345065925.png)
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389345065926.png)
![在这里插入图片描述](E:\Development\Typora\images\20200821171727713.png)

  答案：（1）M为CISC。M的指令长短不一，不符合RISC指令系统的特点。
  （2）96B；f1的第一条指令所在的虚拟地址为00401020H，最后一条指令的虚拟地址为0040107FH，f1的机器指令代码长度为60H=96B；
  （3）CF=1；执行第20条指令时，在补码加/减运算器中执行0减FFFF FFFFH操作，减法运算时的借位标志CF=1；
  （4）不能，shl指令把一个整数的所有有效数位整体左移，而对于float型变量，其机器数中包含阶码部分，将其作为一个整体左移时不能实现乘2的功能；

  `例题`：![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389345065927.png)
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389345065928.png)
![在这里插入图片描述](E:\Development\Typora\images\20200821201216995.png)

  答案：（1）10次；执行第16行的call指令时递归调用f1;
  （2）第12行的jle指令是条件转移指令；第16行的call指令、第20行的jmp指令、第30行的ret指令一定会使程序跳转执行；
  （3）0040102AH；偏移量为00401000H-0040102AH=FFFF FFD6H；小端方式；
  （4）f(13)超出了int型数据能表示的最大范围，因此返回的是一个发生了溢出的错误结果；可将函数f1的返回值改为long long
  （5）函数的返回值为int型，若乘积的高33位为非全0或非全1，则OF=1；应加一条溢出自陷指令，使得CPU自动查询溢出标志OF，当OF=1时调出溢出异常处理程序。

  46题答案：虚拟地址的高20位为页号，相同，在同一页中；高22位为标记，中间4位为组号，低6位为块内地址；虚拟地址和物理地址的最低12位相同，对应的组号为0；

------

### 4.3 CISC和RISC的基本概念

  指令系统朝两个截然不同的方向发展：

- 一是增强原有指令的功能，**设置更为复杂的新指令**实现软件功能的硬化，这类机器称为`复杂指令系统计算机（CISC）`。 典型的有采用X86架构的计算机；
- 二是**减少指令种类和简化指令功能**，提高指令的执行速度，这类机器称为`精简指令系统计算机（RISC）`， 典型的有ARM，MIPS架构的计算机。

####  4.3.1 复杂指令系统计算机（CISC）

  CISC的主要特点：
  （1）指令系统复杂庞大，指令数目一般为200条以上
  （2）指令的长度不固定， 指令格式多，寻址方式多
  （3）可以访存的指令不受限制
  （4）各种指令使用频度相差很大
  （5）各种指令执行时间相差很大，大多数指令需多个时钟周期才能完成
  （6）控制器大多数采用微程序控制。有些指令非常复杂，以至于无法采用硬连线控制
  （7）难以用优化编译生成高效的目标代码程序

####  4.3.2 精简指令系统计算机（RISC）

  精简指令系统计算机（RISC）的中心思想是要求指令系统简化，尽量使用寄存器-寄存器操作指令，指令格式力求一致。RISC的主要特点如下：
  （1）选取使用频率最高的一些简单指令，复杂指令的功能由简单指令的组合来实现
  （2）指令长度固定， 指令格式种类少，寻址方式种类少
  （3）只有Load/Store（取数/存数）指令访存，其余指令的操作都在寄存器之间进行
  （4）CPU中通用寄存器的数量相当多
  （5）RISC一定采用指令流水线技术， 大部分指令在一个时钟周期内完成
  （6）以硬布线控制为主，不用或少用微程序控制
  （7）特别重视编译优化工作，以减少程序执行时间
  从指令系统兼容性来看，CISC大多能实现软件兼容，即高档机包含了低档机的全部指令， 并可加以扩充。但RISC简化了指令系统，指令条数少，格式也不同于老机器，因此大多数RISC机不能与老机器兼容。

------

  为了规整指令格式，使指令具有相同的长度，规定只有Load/Store指令才能访存。而运算指令不能直接访存，只能从寄存器取数进行运算，运算的结果也只能送到寄存器。因为寄存器编号较短，而主存地址的位数较长，通过某种方式可使运算指令与访存指令的长度一致。
  由于只有Load/Store指令才能访问内存，程序中可能会包含许多装入指令和存储指令，与一般通用寄存器指令风格相比，其程序长度会更长。

------

####  4.3.3 CISC和RISC的比较

  和CISC比，RISC的优点主要体现在以下几点：
  （1）RISC更能充分利用VLSI芯片的面积。CISC的控制器大多采用微程序控制，其控制存储器在CPU芯片内所占的面积达50%以上，而RISC控制器采用组合逻辑控制，其硬布线逻辑只占CPU芯片面积的10%
  （2）RISC更能提高运算速度。 RISC的指令数、寻址方式和指令格式种类少，又设有多个通用寄存器，采用流水线技术，所以运算速度更快，大多数指令在一个时钟周期内完成
  （3）RISC便于设计，可降低成本，提高可靠性
  （4）RISC有利于编译程序代码优化。 RISC指令类型少，寻址方式少，使编译程序容易选择更有效的指令和寻址方式，并适当地调整指令顺序，使得代码执行更高效化
  CISC和RISC的对比见表：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389345065929.png)

------

  `例题`：下列指令系统的特点中，有利于实现指令流水线的是（）
  1.指令格式规整且长度一致  2.指令和数据按边界对齐存放  3.只有Load/Store指令才能对操作数进行存储访问
  A.1,2  B.2,3  C.1,3  D.1,2,3

  答案：D；指令长度一致、按边界对齐存放、仅Load/Store指令访存，这些都是RISC的特征，它们使取指令、取操作数的操作简化且时间长度固定，能有效地简化流水线的复杂度。





## 5.中央处理器 CPU

### 5.1 CPU的功能和基本结构

####  5.1.1 CPU的功能

  中央处理器（CPU）由**运算器**和**控制器** 组成。其中，控制器的功能是负责协调并控制计算机各部件执行程序的指令序列，包括取指令、分析指令和执行指令；运算器的功能是对数据进行加工。CPU的具体功能包括：
  （1）**指令控制**：完成取指令、分析指令和执行指令的操作，即程序的顺序控制
  （2）**操作控制**：一条指令的功能往往由若干操作信号的组合来实现。CPU管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作
  （3）**时间控制**：对各种操作加以时间上的控制。时间控制要为每条指令按时间顺序提供应有的控制信号
  （4）**数据加工**：对数据进行算术和逻辑运算
  （5）**中断处理**：对计算机运行过程中出现的异常情况和特殊请求进行处理

####  5.1.2 CPU的基本结构

  中央处理器主要由运算器和控制器两大部分组成

#####   1.运算器

  运算器接收从控制器送来的命令并执行相应的动作，对数据进行加工和处理。运算器是计算机对数据进行加工处理的中心，==它主要由算术逻辑单元（ALU）、暂存寄存器、累加寄存器（ACC）、通用寄存器组、程序状态字寄存器（PSW）、移位器、计数器（CT）等组成。==
  （1）**算术逻辑单元（ALU）**：主要功能是进行算术/逻辑运算
  （2）**暂存寄存器**：用于暂存从主存读来的数据，该数据不能放在通用寄存器中，否则会破坏其原有内容。 暂存寄存器对应用程序员是透明的。
  （3）**累加寄存器**（ACC）：它是一个通用寄存器，用于暂时存放ALU运算的结果信息，也可作为加法运算的一个输入端。
  （4）**通用寄存器组**：如AX（累加器）、BX（基址寄存器）、CX（计数寄存器）、DX（数据寄存器）、SP等，用于存放操作数（包括源操作数、目的操作数及中间结果）和各种地址信息等。SP是堆栈指针，用于指示栈顶的地址。
  （5）**程序状态字寄存器**：保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息，如溢出标志OF、符号标志SF、零标志ZF、进位标志CF等。PSW中的这些位参与并决定微操作的形成
  （6）**移位器**：对操作数或运算结果进行移位运算
  （7）**计数器**：控制乘除运算的操作步数

#####   2.控制器

  控制器是整个系统的指挥中枢，在控制器的控制下，运算器、存储器和输入/输出设备等功能部件构成一个有机的整体，根据指令的要求指挥全机的协调工作。控制器的基本功能是执行指令，每条指令的执行是由控制器发出的一组微操作实现的。
  控制器有**硬布线控制器**和**微程序控制器**两种类型。
  控制器由==程序计数器（PC）、指令寄存器（IR）、指令译码器、存储器地址寄存器MAR、存储器数据寄存器MDR、时序系统和微操作信号发生器等组成==
  （1）**程序计数器（PC）**：用于指出下一条指令在主存中的存放地址。CPU根据PC的内容去主存中取指令。因程序中指令通常是顺序执行的，所以PC有自增功能
  （2）**指令寄存器（IR）**：用于保存当前正在执行的那条指令。
  （3）**指令译码器**：仅对操作码字段进行译码，向控制器提供特定的操作信号。
  （4）**存储器地址寄存器MAR**：用于存放要访问的主存单元的地址
  （5）**存储器数据寄存器MDR**：用于存放向主存写入的信息或从主存读出的信息
  （6）**时序系统**：用于产生各种时序信号，它们都由统一时钟（CLOCK）分频得到
  （7）**微操作信号发生器**：根据IR的内容（指令），PSW的内容（状态信息）及时序信号，产生控制整个计算机系统所需的各种控制信号，其结构有组合逻辑型和存储逻辑型两种。

  控制器的工作原理是根据指令操作码、指令的执行步骤（微命令序列）和条件信号来形成当前计算机各部件要用到的控制信号。

------

>     CPU内部寄存器大致可分为两类：
>
>   ​		一类是用户可见的寄存器，可对这类寄存器编程，如通用寄存器组、程序状态字寄存器；
>
>   ​		另一类是用户不可见的寄存器，对用户是透明的，不可对这类寄存器编程，如存储器地址寄存器、存储器数据寄存器、指令寄存器。

------

------

  `例题`：条件转移指令执行时所依据的条件来自（）
  A.指令寄存器  B.标志寄存器
  C.程序计数器  D.地址寄存器

  答案：B；

  `例题`：在所谓的n位CPU中，n是指（）
  A.地址总线线数  B.数据总线线数
  C.控制总线线数  D.I/O线数

  答案：B；数据总线的位数与处理器的位数相同，它表示CPU一次能处理的数据的位数，即CPU的位数

  `例题`：下面有关程序计数器PC的叙述中，错误的是（）
  A.PC中总是存放指令地址
  B.PC的值由CPU在执行指令过程中进行修改
  C.转移指令时，PC的值总是修改位转移指令的目标地址
  D.PC的位数一般和存储器地址寄存器MAR的位数一样

  答案：C；

  `例题`：间址周期结束时，CPU内寄存器MDR中的内容为（）
  A.指令  B.操作数地址  C.操作数  D.无法确定

  答案：B；间址周期的作用是取操作数的有效地址，因此间址周期结束后，MDR中的内容为操作数地址

  `例题`：某计算机的主存空间为4GB，字长为32位，按字节编址，采用32位字长指令字格式。若指令按字边界对齐存放，则程序计数器PC和指令寄存器IR的位数至少分别是

  答案：30、32；

  `例题`：CPU中有哪些专用寄存器

  答案：PSW、PC、IR、MAR、MDR（注意ACC是通用寄存器）

### 5.2 指令执行过程

####  5.2.1 指令周期

  CPU从主存中`取出并执行`一条指令的时间称为**指令周期**， 不同指令的指令周期可能不同。指令周期常用若干机器周期来表示，一个**机器周期**又包含若干**时钟周期**（也称节拍或T周期，它是CPU操作的最基本单位）。

>  每个指令周期内的机器周期数可以不等，每个机器周期内的节拍数也可以不等。

![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638935115451.png)
  （a）为定长的机器周期，每个机器周期包含4个节拍（T)；

​	（b）为不定长的机器周期，每个机器周期包含的节拍数可以为4个，也可以为3个。

1. 对于无条件转移指令JMP X，在执行时不需要访问主存，只包含取指阶段（包括取指和分析）和执行阶段，所以其指令周期仅包含取指周期和执行周期。
2. 对于间接寻址的指令，为了取操作数，需要先访问一次主存，取出有效地址，然后访问主存，取出操作数，所以还需包括间址周期。间址周期介于取指周期和执行周期之间。

  当CPU采用中断方式实现主机和I/O设备的信息交换时，CPU在每条指令执行结束前，都要发中断查询信号，若有中断请求，则CPU进入中断响应阶段，又称中断周期。 ==一个完整的指令周期应包括取指、间址、执行和中断4个周期：==
![在这里插入图片描述](E:\Development\Typora\images\20200822102859331.png)
  

> 上述4个工作周期都有CPU访存操作，只是访存的目的不同。**取指周期是为了取指令，间址周期是为了取有效地址，执行周期是为了取操作数，中断周期是为了保存程序断点。**

  为了区别不同的工作周期，在CPU内设置4个标志触发器FE、IND、EX、INT，分别对应取指、间址、执行和中断周期，以1表示有效，分别由1——>FE、1——>IND、1——>EX、1——>INT这4个信号控制。

------

  中断周期中的进栈操作是将SP减1，这和传统意义上的进栈操作相反，==**原因是计算机的堆栈中都是向低地址增加，所以进栈操作是减1而不是加1**==

  机器周期可看作是所有指令执行过程中的一个基准时间，机器内的各种操作大致可归属为对CPU内部的操作和对主存的操作两大类，由于CPU内部的操作速度较快，CPU访存的操作时间较长，因此通常以访问一次存储器的时间定为基准时间较为合理，这个基准时间就是机器周期。 因此在存储字长等于指令字长的情况下，取指周期也可看作机器周期。

------

####  5.2.2 指令周期的数据流

  数据流是根据指令要求依次访问的数据序列。在指令执行的不同阶段，要求依次访问的数据序列是不同的。而且对于不同的指令，它们的数据流往往也是不同的。

#####   1.取指周期

> 取指周期的任务是根据PC中的内容从主存中取出指令代码并存放在IR中

  取指周期的数据流如图

![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638935115452.png)
  PC中存放的是指令的地址，根据此地址从内存单元中取出的是指令，并存放在指令寄存器IR中，取指令的同时，PC加1。
  取指周期的数据流向如下：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638935115453.png)

#####   2.间址周期

> 间址周期的任务是取操作数有效地址。

 		以一次间址为例，将指令中的地址码送到MAR并送至地址总线，此后CU向存储器发读命令，以获取有效地址并存至MDR

![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638935115454.png)
  间址周期的数据流向如下：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638935115455.png)

#####   3.执行周期

  执行周期的任务是根据IR中的指令字的操作码和操作数通过ALU操作产生执行结果。不同指令的执行周期操作不同，因此没有统一的数据流向。

#####   4.中断周期

> 中断周期的任务是处理中断请求。

​		假设程序断点存入堆栈中，并用SP指示栈顶地址，而且进栈操作是**先修改栈顶指针，后存入数据**，数据流如图：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638935115466.png)
  中断周期的数据流向如下：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638935115467.png)

####  5.2.3 指令执行方案

  一个指令周期通常要包括几个时间段（执行步骤），每个步骤完成指令的一部分功能，几个依次执行的步骤完成这条指令的全部功能。可选用3种不同方案来安排指令的执行步骤。

#####   1.单指令周期

  ==对所有指令都选用相同的执行时间来完成，称为单指令周期方案==。 此时每条指令都在固定的时钟周期内完成，指令之间串行执行，即下一条指令只能在前一条指令执行结束后才能启动。 因此，指令周期取决于执行时间最长的指令的执行时间。 对于那些本来可以在更短时间内完成的指令，要使用这个较长的周期来完成，会降低整个系统的运行速度。

#####   2.多指令周期

  ==对不同类型的指令选用不同的执行步骤来完成，称为多指令周期方案==。 指令之间串行执行，即下一条指令只能在前一条指令执行结束后才能启动。但可选用不同个数的时钟周期来完成不同指令的执行过程， 指令需要几个周期就为其分配几个周期，而不再要求所有指令占用相同的执行时间。

#####   3.流水线方案

  ==指令之间可以并行执行的方案，称为流水线方案==， 其追求的目标是力争在每个时钟脉冲周期完成一条指令的执行过程（只在理想情况下才能达到该效果）。这种方案通过在每个时钟周期启动一条指令，尽量让多条指令同时运行，但各自处在不同的执行步骤中。

------

  `例题`：指令（）从主存中读出
  A.总是根据PC
  B.有时根据PC，有时根据转移指令
  C.根据MAR
  D.有时根据PC，有时根据MAR

  答案：A；执行转移指令后也需将目标指令地址传到PC中。CPU根据PC中的内容去主存存取指令。

  `例题`：下列说法中，正确的是（）
  1.指令字长等于机器字长的前提下，取指周期等于机器周期
  2.指令字长等于存储字长的前提下，取指周期等于机器周期
  3.指令字长和机器字长的长度没有任何关系
  4.为了硬件设计方便，指令字长都和存储字长一样大

  答案：2,3

  `例题`：指令和数据都存于存储器中，CPU如何区分它们？

  答案：虽然指令和数据都是以[二进制](https://so.csdn.net/so/search?q=二进制&spm=1001.2101.3001.7020)代码形式存放在存储器中，但CPU可根据指令周期的不同阶段判断从存储器中取出的二进制代码是指令还是数据。在取指阶段通过访问存储器可将指令取出，在执行阶段通过访问存储器可将操作数取出。

------

### 5.3 数据通路的功能和基本结构

####  5.3.1 数据通路的功能

  **数据在功能部件间传送的路径称为数据通路**。 路径上的部件称为数据通路部件， 如ALU、通用寄存器、状态寄存器、异常和中断处理逻辑等。数据通路描述了信息从什么地方开始，中间经过哪个寄存器或多路开关，最后传送到哪个寄存器，这些都需要加以控制。

  数据通路中专门进行数据运算的部件称为执行部件或功能部件。数据通路由控制部件控制。数据通路的功能是实现CPU内部的运算器与寄存器及寄存器之间的数据交换。

####  5.3.2 数据通路的基本结构

  数据通路的基本结构主要有以下几种：

  （1）CPU内部单总线方式：将所有寄存器的输入端和输出端都连接到一条公共通路上。 这种结构较为简单，但数据传输存在较多的冲突现象，性能较低。连接各部件的总线只有一条时，称为单总线结构；

> CPU中有两条或更多的总线时，构成双总线结构或多总线结构。

 下图所示为CPU内部总线的数据通路和控制信号：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638935115468.png)
  

> 在图中，规定各部件用大写字母表示，字母加in表示该部件的允许输入控制信号；字母加out表示该部件的允许输出控制信号

  （2）CPU内部三总线方式：将所有寄存器的输入端和输出端都连接到多条公共通路上， 相比之下单总线中一个时钟周期内只允许传一个数据，因而指令执行效率很低，因此采用多总线方式，同时在多个总线上传送不同的数据，提高效率。

  （3)专用数据通路方式：根据指令执行过程中的数据和地址的流动方向安排连接线路，避免使用共享的总线，性能较高，但硬件量大。

------

> **内部总线是指同一部件，如CPU内部连接各寄存器及运算部件之间的总线；**
>
> 系统总线是指同一台计算机系统的各部件，如CPU、内存、通道和各类I/O接口间互相连接的总线。

------

#####   1.寄存器之间的数据传送

  ==寄存器之间的数据传送可通过CPU内部总线完成。==以PC为例，把PC内容送至MAR，实现传送操作的流程及控制信号为：
  PC——>Bus     PCout有效，PC内容送总线
  Bus——>MAR    MARin有效，总线内容送MAR

#####   2.主存与CPU之间的数据传送

  ==主存与CPU之间的数据传送也要借助CPU内部总线完成。==以CPU从主存读取指令为例，实现传送操作的流程及控制信号为：
  PC——>Bus——>MAR    PCout和MARin有效，现行指令地址——>MAR
  1——>R    CU发读命令
  MEM(MAR)——>MDR    MDRin有效
  MDR——>Bus——>IR    MDRout和IRin有效，现行指令——>IR

#####   3.执行算术或逻辑运算

  执行算术或逻辑操作时，由于ALU本身是没有内部存储功能的组合电路，因此如要执行加法运算，相加的两个数必须在ALU的两个输入端同时有效。 暂存器Y即用于该目的。先将一个操作数经CPU内部总线送入暂存器Y保存，Y的内容在ALU的左输入端始终有效，再将另一个操作数经总线直接送到ALU的右输入端。 这样两个操作数都送入了ALU，运算结果暂存在暂存器Z中。 （设置暂存器Z的原因是：ALU的输出不能直接与内部总线相连，因为其输出又会通过总线反馈到ALU的输入，影响运算的正确性）
  Ad（IR）——>Bus——>MAR    MDRout和MARin有效
  1——>R    CU发读命令
  MEM——>数据线——>MDR    操作数从存储器——>数据线——>MDR
  MDR——>Bus——>Y    MDRout和Yin有效，操作数——>Y
  （ACC）+（Y）——>Z    ACCout和ALUin有效，CU向ALU发加命令，结果——>Z
  Z——>ACC    Zout和ACCin有效，结果——>ACC

  数据通路结构直接影响CPU内各种信息的传送路径，数据通路不同，指令执行过程的微操作序列的安排也不同，它关系着微操作信号形成部件的设计

------

  `例题`：采用CPU内部总线的数据通路与不采用CPU内部总线的数据通路相比，（）
  A.前者性能较高  B.后者的数据冲突问题较严重
  C.前者的硬件量大，实现难度高  D.以上说法都不对

  答案：D；采用CPU内部总线方式的数据通路的特点：结构简单，实现容易，性能较低，存在较多的冲突现象；不采用CPU内部总线方式的数据通路的特点：结构复杂，硬件量大，不易实现，性能高，基本上不存在数据冲突现象

  `例题：`![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638935115469.png)
  答案：注意取指和译码阶段之后是执行阶段，时钟应该从C5开始

![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351154610.png)

  `例题：`
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351154611.png)

  答案：![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351154712.png)

  `例题：`![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351154713.png)

![在这里插入图片描述](E:\Development\Typora\images\2020082215440559.png)

  答案：![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351154714.png)

  `例题`：

![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351154715.png)

  答案：![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351154716.png)
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351154717.png)

  `例题`：下图是一个简化了的CPU与主存连接结构示意图（图中省略了所有的多路选择器）。其中有一个累加寄存器（ACC）、一个状态数据寄存器和其他4个寄存器：主存地址寄存器（MAR）、主存数据寄存器（MDR）、程序寄存器（PC）和指令寄存器（IR），各部件及其之间的连线表示数据通路，箭头表示信息传递方向。
要求：
（1）请写出图中a、b、c、d 4个寄存器的名称。
（2）简述图中取指令的数据通路。
（3）简述数据在运算器和主存之间进行存/取访问的数据通路。
（4）简述完成指令LDA X的数据通路（X为主存地址，LDA的功能为（X）→ACC）。
（5）简述完成指令ADD Y的数据通路（Y为主存地址，ADD的功能为（ACC）+（Y）→ACC）。
（6）简述完成指令STA Z的数据通路（Z为主存地址，STA的功能为（ACC）→Z）。
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351154718.png)

  答案：（1）MDR、IR、MAR、PC
  （2）PC——>MAR——>主存——>MDR——>IR
  （3）存储器读（读取的数据放在ACC中）：MAR（先置数据地址），M——>MDR——>ALU——>ACC
  存储器写（被写的数据在ACC）：MAR（先置数据地址），ACC——>MDR——>M
  （4）X——>MAR——>主存——>MDR——>ALU——>ACC
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351154719.png)

  `例题`：某机主要功能部件如图下图所示，其中Ｍ为主存，MDR为主存数据寄存器，MAR为主存地址寄存器，IR为指令寄存器，PC为程序计数器，Ｒ0——Ｒ3为通用寄存器，Ｃ,Ｄ为暂存器。 （1）请补充各部件之间的主要联结线，并注明数据流动方向 （2）画出“ＡＤＤ（Ｒ1），（Ｒ2）＋”指令周期流程图。该指令的含义是进行求和运算，源操作数地址在Ｒ1中，目标操作数寻址方式为自増型寄存器间接寻址方式（先取地址后加１），并将相加结果写回R2寄存器。
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351154820.png)

  答案：（1）
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351154821.png)
（2）（（R1））+（（R2））——>（R2），将源操作数和目的操作数相加送到MDR，随之送到以前目的操作数所在内存的地址。最后将寄存器R2的内容加1：（R2）+1——>R2
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351154822.png)

  `例题`：![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351154823.png)
  答案：![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351154824.png)

  `例题：`![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351154825.png)
  答案：（1）PC作为ALU的一个输入的同时作为MAR的输入。
  C1：（PC）——>MAR,（PC）——>R1
  C2：（PC）+1——>R2,M（MAR）——>MDR
  C3:（MDR）——>IR
  C4:  R2——>PC
  （2）Ad（IR）——>R1;
    （ACC）+（R1）——>R2
    （R2)——>ACC

  `例题：`
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351154826.png)
  答案：（1）R0~R3，PC。因为采用了单总线结构，因此若无暂存器T，则ALU的A、B端口会同时获得两个相同的数据，使数据通路不能正常工作
  （2）3,2；
  （3）信号SRout所控制的部件是一个三态门，用于控制移位器与总线之间数据通路的连接与断开
  （4）1,2,3,5，8
  （5）6——>9;7——>4
  （6）因为每条指令的长度为16位，按字节编址，所以每条指令占用2个内存单元，顺序执行时，下条指令地址为（PC）+2。MUX的一个输入端为2，可便于执行（PC)+2操作

------

  MUX为多路选择器，此题中为二路选择器，可实现（PC）+2功能；二路选择器选择控制端s为0时选择A，为1时选择B，PC送T，s为0，选2，实现（PC）+2；

------

------

### 5.4 控制器的功能和工作原理

####  5.4.1 控制器的结构和功能

  下图表示计算机硬件系统的五大功能部件及其连接关系。它们通过数据总线、地址总线和控制总线连接在一起。
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351154827.png)
  其主要连接关系为：
  （1）运算器部件通过数据总线与内存储器、输入设备和输出设备传送数据
  （2）输入设备和输出设备通过接口电路与总线相连接
  （3）内存储器、输入设备和输出设备从地址总线接收地址信息，从控制总线得到控制信号，通过数据总线与其他部件传送数据
  （4）控制器部件从数据总线接收指令信息，从运算器部件接收指令转移地址，送出指令地址到地址总线，还要向系统中的部件提供它们运行所需要的控制信号。
  控制器是计算机系统的指挥中心，控制器的主要功能有：
  （1）从主存中取出一条指令，并指出下一条指令在主存中的位置
  （2）对指令进行译码或测试，产生相应的操作控制信号，以便启动规定的动作
  （3)指挥并控制CPU、主存、输入和输出设备之间的数据流动方向
  根据控制器产生微操作控制信号的方式的不同，控制器可分为硬布线控制器和微程序控制器， 两类控制器中的PC和IR是相同的，但确定和表示指令执行步骤的办法以及给出控制各部件运行所需要的控制信号的方案是不同的。

####  5.4.2 硬布线控制器

  硬布线控制器的基本原理是根据指令的要求、当前的时序及外部和内部的状态，按时间的顺序发送一系列微操作控制信号。它由复杂的组合逻辑门电路和一些触发器构成，因此又称组合逻辑控制器。

#####   1.硬布线控制单元图

  指令的操作码是决定控制单元发出不同操作命令（控制信号）的关键。 为了简化控制单元CU的逻辑，将指令的操作码译码和节拍发生器从CU分离出来，便可得到简化的控制单元图：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351154928.png)
  CU的输入信号来源如下：
  （1）经指令译码器译码产生的指令信息。 现行指令的操作码决定了不同指令在执行周期所需完成的不同操作，因此指令的操作码字段是控制单元的输入信号，它与时钟配合产生不同的控制信号。
  （2）时序系统产生的机器周期信号和节拍信号。 为了使控制单元按一定的先后顺序、一定的节奏发出各个控制信号，控制单元必须受时钟控制，即一个时钟脉冲使控制单元发送一个操作命令，或发送一组需要同时执行的操作命令。
  （3)来自执行单元的反馈信息即标志。 控制单元有时需依赖CPU当前所处的状态产生控制信号，如BAN指令，控制单元要根据上条指令的结果是否为负来产生不同的控制信号。

  上图中，节拍发生器产生各机器周期中的节拍信号，使不同的微操作命令Ci（控制信号）按时间的先后发出。个别指令的操作不仅受操作码控制，还受状态标志控制，因此CU的输入来自操作码译码电路ID、节拍发生器及状态标志，其输出到CPU内部或外部控制总线上。

------

  控制单元还接收来自系统总线（控制总线）的控制信号，如中断请求、DMA请求。

------

#####   2.硬布线控制器的时序系统及微操作

  （1）时钟周期。
  用时钟信号控制节拍发生器，可以产生节拍，每个节拍的宽度正好对应一个时钟周期。在每个节拍内机器可完成一个或几个需同时执行的操作。
  （2）机器周期。
  机器周期可视为所有指令执行过程中的一个基准时间。 不同指令的操作不同，指令周期也不同。访问一次存储器的时间是固定的，因此通常以存取周期作为基准时间，即内存中读取一个指令字的最短时间作为机器周期。 在存储字长等于指令字长的前提下，取指周期也可视为机器周期。
  在一个机器周期里可完成若干微操作， 每个微操作都需一定的时间，可用时钟信号来控制产生每个微操作命令。
  （3）指令周期
  （4）微操作命令分析。
  控制单元具有发出各种操作命令（控制信号）序列的功能。这些命令与指令有关，而且必须按一定次序发出，才能使机器有序地工作。
  执行程序的过程中，对于不同的指令，控制单元需发出各种不同的微操作命令。一条指令分为3个工作周期：取指周期、间址周期和执行周期。 下面分析各个子周期的微操作命令。
  a.取指周期的微操作命令。无论是什么指令，取指周期都需有下列微操作命令：
  PC——>MAR    现行指令地址——>MAR
  1——>R    命令存储器读
  M（MAR）——>MDR    现行指令从存储器中读至MDR
  MDR——>IR    现行指令——>IR
  OP（IR）——>CU    指令的操作码——>CU译码
  （PC）+1——>PC    形成下一条指令的地址

  b.间址周期的微操作命令。间址周期完成取操作数地址的任务，具体微操作命令如下：
  Ad（IR）——>MAR  将指令字中的地址码（形式地址）——>MAR
  1——>R    命令存储器读
  M（MAR）——>MDR    将有效地址从存储器读至MDR

  c.执行周期的微操作命令。执行周期的微操作命令视不同指令而定。
  非访存指令：
  CLA  清ACC  0——>ACC
  COM  取反  A C C ‾ \overline{ACC}ACC——>ACC
  SHR  算术右移  L（ACC）——>R（ACC），ACC0——>ACC0
  CSL  循环左移  R（ACC）——>L（ACC），ACC0——>ACCn
  STP  停机指令  0——>G（停机标志位）

  访存指令
  ADD X  加法指令：
  Ad（IR）——>MAR
  1——>R
  M（MAR）——>MDR
  （ACC）+（MDR）——>ACC

  STA X  存数指令：
  Ad（IR）——>MAR
  1——>W
  ACC——>MDR
  MDR——>M（MAR）

  LDA X  取数指令：
  Ad（IR）——>MAR
  1——>R
  M（MAR）——>MDR
  MDR——>ACC

  转移指令：
  JMP X  无条件转移：
  Ad（IR）——>PC

  BAN X  条件转移（负则转）
  A0·Ad（IR）+A 0 ‾ \overline{A0}A0·（PC）——>PC

#####   3.CPU的控制方式

  控制单元控制一条指令执行的过程，实质上是依次执行一个确定的微操作序列的过程。 由于不同指令所对应的微操作数及复杂程度不同，因此每条指令和每个微操作所需的执行时间也不同。主要有以下3种控制方式：
  （1）同步控制方式：
  同步控制方式，指系统有一个统一的时钟，所有的控制信号均来自这个统一的时钟信号。 通常以最长的微操作序列和最烦琐的微操作作为标准，采取完全统一的、具有相同时间间隔和相同数目的节拍作为机器周期来运行不同的指令。 同步控制方式的优点是控制电路简单，缺点是运行速度慢。
  （2）异步控制方式：
  异步控制方式不存在基准时标信号，各部件按自身固有的速度工作，通过应答方式进行联络。 异步控制方式的优点是运行速度快，缺点是控制电路比较复杂。
  （3）联合控制方式：
  联合控制方式是介于同步、异步之间的一种折中。 这种方式对各种不同的指令的微操作实行大部分采用同步控制、小部分采用异步控制的办法。

#####   4.硬布线控制单元设计步骤

  硬布线控制单元设计步骤包括：
  （1）列出微操作命令的操作时间表。
  先根据微操作节拍安排，列出微操作命令的操作时间表。操作时间表中包括各个机器周期、节拍下的每条指令完成的微操作控制信号。
  下表中列出了CLA、COM、SHR等10条机器指令微操作命令的操作时间表：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351154929.png)
  I为间址标志，在取指周期的T2时刻，若测得I=1，则IND触发器置1，标志进入间址周期；若I=0，则EX触发器置1，标志进入执行周期。同理，在间址周期的T2时刻，若测得IND=0（表示一次间接寻址），则EX触发器置1，进入执行周期；若测得IND=1（表示多次间接寻址)，则继续间接寻址。在执行周期的T2时刻，CPU要向所有中断源发中断查询信号，若检测到有中断请求并满足响应条件，则INT触发器置1，标志进入中断周期。

  （2）进行微操作信号综合。
  在列出微操作时间表后，即可对它们进行综合分析、归类，根据微操作时间表可写出各微操作控制信号的逻辑表达式并进行适当简化。表达式一般包括下列因素：
  微操作控制信号=机器周期^节拍 ^脉冲 ^操作码 ^机器状态条件
  根据微操作时间表便可列出每个微操作命令的初始逻辑表达式，经化简、整理可获得能用现有门电路实现的微操作命令逻辑表达式
  例如，根据上表可写出M（MAR）——>MDR微操作命令的逻辑表达式：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351154930.png)

  （3）画出微操作命令的逻辑图。
  根据逻辑表达式可画出对应每个微操作信号的逻辑电路图，并用逻辑门电路实现。
  例如，M（MAR）——>MDR的逻辑表达式所对应的逻辑图如图：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351154931.png)

####  5.4.3 微程序控制器

  微程序控制器采用存储逻辑实现，即把微操作信号代码化，使每条机器指令转化成为一段微程序并存入一个专门的存储器（**控制存储器**）中，微操作信号由微指令产生。

#####   1.微程序控制的基本概念

  微程序设计思想就是将每条机器指令编写成一个微程序，每个微程序包含若干微指令，每条微指令对应一个或几个微操作命令。 这些微程序可以存到一个控制存储器中，用寻址用户程序机器指令的办法来寻址每个微程序中的微指令。目前，大多数计算机都采用微程序设计技术。
  微程序设计技术涉及的基本术语如下：
  （1）微命令与微操作
  一条机器指令可以分解成一个微操作序列，这些微操作是计算机中最基本的、不可再分解的操作。 在微程序控制的计算机中，将控制部件向执行部件发出的各种控制命令称为微命令，它是构成控制序列的最小单位。 例如，打开或关闭某个控制门的电位信号、某个寄存器的打入脉冲等。微命令和微操作是一一对应的。微命令是微操作的控制信号，微操作是微命令的执行过程。
  微命令有相容性和互斥性之分。 相容性微指令是指那些可以同时产生、共同完成某一些微操作的微命令；而互斥性微命令是指在机器中不允许同时出现的微命令。 相容和互斥都是相对的，一个微命令可以和一些微命令相容，和另一些微命令互斥。

------

  在组合逻辑控制器中也存在微命令和微操作这两个概念，它们并非只是微程序控制器的专有概念

------

  （2）微指令和微周期
  微指令是若干微命令的集合。存放微指令的控制存储器的单元地址称为微地址。 一条微指令通常至少包含两大部分信息：
  a.操作控制字段，又称微操作码字段，用于产生某一步操作所需的各种操作控制信号。
  b.顺序控制字段，又称微地址码字段，用于控制产生下一条要执行的微指令地址。
  微周期通常指从控制存储器中读取一条微指令并执行相应的微操作所需的时间。

  （3）主存储器与控制存储器
  主存储器用于存放程序和数据，在CPU外部，用RAM实现；控制存储器（CM）用于存放微程序，在CPU内部，用ROM实现。

  （4）程序与微程序
  程序是指令的有序集合，用于完成特定的功能；微程序是微指令的有序集合，一条指令的功能由一段微程序来实现。
  微程序和程序是两个不同的概念。微程序是由微指令组成的，用于描述机器指令。微程序实际上是机器指令的实时解释器，是由计算机设计者事先编制好并存放在控制存储器中的，一般不提供给用户。对于程序员来说，计算机系统中微程序的结构和功能是透明的。 而程序最终由机器指令组成，是由软件设计人员事先编制好并存放在主存或辅存中的。

  应注意区分以下寄存器：
  a.地址寄存器MAR：用于存放主存的读/写地址
  b.微地址寄存器CMAR：用于存放控制存储器CM的读/写微指令的地址
  c.指令寄存器IR：用于存放从主存中读出的指令
  d.微指令寄存器CMDR或μIR：用于存放从控制存储器中读出的微指令

#####   2.微程序控制器组成和工作过程

  （1）微程序控制器的基本组成
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351155032.png)

  上图所示为一个微程序控制器的基本结构，主要画出了微程序控制器比组合逻辑控制器多出的部件，包括：
  a.控制存储器
  它是微程序控制器的核心部件，用于存放各指令对应的微程序，控制存储器可用只读存储器ROM构成
  b.微指令寄存器CMDR
  用于存放从CM从取出的微指令，它的位数同微指令字长相等。
  c.微地址形成部件
  用于产生初始微地址和后继微地址，以保证微指令的连续执行
  d.微地址寄存器CMAR
  接收微地址形成部件送来的微地址，为在CM中读取微指令作准备。

  （2）微程序控制器的工作过程
  微程序控制器的工作过程实际上就是在微程序控制器的控制下计算机执行机器指令的过程，可描述如下：
  a.执行取微指令公共操作
  在机器开始运行时，自动将取指微程序的入口地址送入CMAR，并从CM中读出相应的微指令送入CMDR。取指微程序的入口地址一般为CM的0号单元。 当取指微程序执行完后，从主存中取出的机器指令就已存入指令寄存器IR中。
  b.由机器指令的操作码字段通过微地址形成部件产生该机器指令所对应的微程序的入口地址，并送入CMAR。
  c.从CM中逐条取出对应的微指令并执行
  d.执行完对应于一条机器指令的一个微程序后，又回到取指微程序的入口地址，继续a，以完成取下一条机器指令的公共操作。
  以上是一条机器指令的执行过程，如此周而复始，直到整个程序执行完毕。

  （3）微程序和机器指令
  通常，一条机器指令对应一个微程序。由于任一条机器指令的取指令操作都是相同的，因此可将取指令操作的微命令统一编成一个微程序，这个微程序只负责将指令从主存单元中取出并送至指令寄存器。
  此外，也可编出对应间址周期的微程序和中断周期的微程序。这样，控制存储器中的微程序个数应为机器指令数再加上对应取指、间址和中断周期等共用的微程序数。

------

  若指令系统中具有n种机器指令，则控制存储器中的微程序数至少是n+1（1为公共的取指微程序）

------

#####   3.微指令的编码方式

  微指令的编码方式又称微指令的控制方式，是指如何对微指令的控制字段进行编码，以形成控制信号。 编码的目标是在保证速度的情况下，尽量缩短微指令字长。
  （1）直接编码（直接控制）方式
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351155033.png)

  直接编码法无须进行译码，微指令的微命令字段中每个位都代表一个微命令。 设计微命令时，选用或不选用某个微命令，只要将表示该微命令的对应位设置成1或0即可。每个微命令对应并控制数据通路中的一个微操作。
  这种编码的优点是简单、直观，执行速度快，操作并行性好； 缺点是微指令字长过长，n个微命令就要求微指令的操作字段有n位，造成控制存储器容量极大。

  （2）字段直接编码方式
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351155034.png)
  将微指令的微命令字段分成若干小字段，把互斥性微命令组合在同一字段中，把相容性微命令组合在不同字段中，每个字段独立编码，每种编码代表一个微命令且各字段编码含义单独定义，与其他字段无关， 这就是字段直接编码方式。
  这种方式可缩短微指令字长，但因为要通过译码电路后再发出微命令，因此比直接编码方式慢。
  微命令字段分段的原则：
  a.互斥性微命令分在同一段内，相容性微命令分在不同段内
  b.每个小段中包含的信息位不能太多，否则将增加译码线路的复杂性和译码时间
  c.一般每个小段还要留出一个状态，表示本字段不发出任何微命令。 因此，当某字段的长度为3位时，最多只能表示7个互斥的微命令，通常用000表示不操作。

  （3）字段间接编码方式
  一个字段的某些微命令需由另一个字段中的某些微命令来解释，由于不是靠字段直接译码发出的微命令，因此称为字段间接编码，又称隐式编码。 这种方式可以进一步缩短微指令字长，但因削弱了微指令的并行控制能力，因此通常作为字段直接编码方式的一种辅助手段。

#####   4.微指令的地址形成方式

  后继微地址的形成主要有以下两大基本类型：
  （1）直接由微指令的下地址字段指出
  微指令格式中设置一个下地址字段，由微指令的下地址字段直接指出后继微指令的地址，这种方式又称断定方式。
  （2）根据机器指令的操作码形成
  机器指令取至指令寄存器后，微指令的地址由操作码经微地址形成部件形成。 （微地址形成部件实际上是一个编码器，其输入为指令操作码，输出就是对应该机器指令微程序的首地址）

  实际上，微指令序列地址的形成方式还有以下几种：
  a.增量计数器法，即（CMAR）+1——>CMAR，适用于后继微指令的地址连续的情况
  b.根据各种标志决定微指令分支转移的地址
  c.通过网络测试形成
  d.由硬件直接产生微程序入口地址
  电源加电后，第一条微指令的地址可由专门的硬件电路产生，也可由外部直接向CMAR输入微指令的地址，这个地址即为取指周期微程序的入口地址。

#####   5.微指令的格式

  微指令格式与微指令的编码方式有关，通常分为水平型微指令和垂直型微指令两种。
  （1）水平型微指令
  从编码方式看，直接编码、字段直接编码、字段间接编码和混合编码都属于水平型微指令。 水平型微指令的基本指令格式如图：
![在这里插入图片描述](E:\Development\Typora\images\2020082308551192.png)
  指令字中的一位对应一个控制信号，有输出时为1，否则为0。一条水平型微指令定义并执行几种并行的基本操作。
  水平型微指令的优点是微程序短， 执行速度快；缺点是微指令长，编写微程序较麻烦。
  （2）垂直型微指令
  垂直型微指令的特点是采用类似机器指令操作码的方式，在微指令中设置微操作码字段，采用微操作码编译法，由微操作码规定微指令的功能， 其基本的指令格式如图：
![在这里插入图片描述](E:\Development\Typora\images\20200823090251901.png)
  一条垂直型微指令只能定义并执行一种基本操作。
  垂直型微指令格式的优点是微指令短、简单、规整，便于编写微程序；缺点是微程序长， 执行速度慢，工作效率低。
  （3）混合型微指令
  在垂直型的基础上增加一些不太复杂的并行操作。 微指令较短，仍便于编写；微程序也不长，执行速度加快。
  （4)水平型微指令和垂直型微指令的比较如下：
  a.水平型微指令并行操作能力强、效率高、灵活性强；垂直型微指令则较差
  b.水平型微指令执行一条指令的时间短；垂直型微指令执行的时间长
  c.由水平型微指令解释指令的微程序，具有微指令字较长但微程序短的特点；垂直型微指令则相反，其微指令字较短而微程序长。
  d.水平型微指令用户难以掌握，而垂直型微指令与指令比较相似，相对容易掌握

#####   6.微程序控制单元的设计步骤

  微程序控制单元设计的主要任务是编写各条机器指令所对应的微程序。具体的设计步骤如下：
  （1）写出对应机器指令的微操作命令及节拍安排
  无论是组合逻辑设计还是微程序设计，对应相同的CPU结构，两种控制单元的微操作命令和节拍安排都是极相似的。如微程序控制单元在取指阶段发出的微操作命令及节拍安排如下：
  T0  PC——>MAR,1——>R
  T1  M（MAR）——>MDR,（PC）+1——>PC
  T2  MDR——>IR,OP（IR）——>微地址形成部件
  与硬布线控制单元相比，只在T2节拍内的微操作命令不同。微程序控制单元在T2节拍内要将指令的操作码送至微地址形成部件，即OP（IR）——>微地址形成部件，以形成该条机器指令的微程序首地址。 而硬布线控制单元在T2节拍内要将指令的操作码送至指令译码器，以控制CU发出相应的微命令，即OP（IR）——>ID
  若把一个节拍T内的微操作安排在一条微指令中完成，上述微操作对应3条微指令。但由于微程序控制的所有控制信号都来自微指令，而微指令又存在控制存储器中，因此欲完成上述这些微操作，必须先将微指令从控制存储器中读出，即必须先给出这些微指令的地址。在取指微程序中，除第一条微指令外，其余微指令的地址均由上一条微指令的下地址字段直接给出，因此上述每条微指令都需增加一个将微指令下地址字段送至CMAR的微操作，记为Ad（CMDR）——>CMAR。 取指微程序的最后一条微指令，其后继微指令的地址是由微地址形成部件形成的，即微地址形成部件——>CMAR。 为了反映该地址与操作码有关，因此记为OP（IR）——>微地址形成部件——>CMAR
  综上所述，考虑到需要形成后继微指令地址，上述分析的取指操作共需6条微指令完成：
  T0  PC——>MAR,1——>R
  T1  Ad（CMDR）——>CMAR
  T2  M（MAR）——>MDR,（PC）+1——>PC
  T3  Ad（CMDR）——>CMAR
  T4  MDR——>IR
  T5  OP（IR）——>微地址形成部件——>CMAR

  执行阶段的微操作命令及节拍安排，分配原则类似。与硬布线控制单元微操作命令的节拍安排相比，多了将下一条微指令地址送至CMAR的微操作命令，即Ad（CMDR）——>CMAR。其余的微操作命令与硬布线控制单元相同。

------

  造成上述结论的原因是：每执行完一条微指令后要得到下一条微指令的地址

------

  （2）确定微指令格式
  微指令格式包括微指令的编码方式、后继微指令地址的形成方式和微指令字长等。
  根据微操作个数决定采用何种编码方式，以确定微指令的操作控制字段的位数。由微指令数确定微指令的顺序控制字段的位数。最后按操作控制字段位数和顺序控制字段位数就可确定微指令字长。

  （3）编写微指令码点
  根据操作控制字段每位代表的微操作命令，编写每条微指令的码点

#####   7.动态微程序设计和毫微程序设计

  （1）动态微程序设计
  在一台微程序控制的计算机中，假如能根据用户的要求改变微程序，则这台机器就具有动态微程序设计功能。
  动态微程序的设计需要可写控制寄存器的支持，否则难以改变微程序的内容。实现动态微程序设计可采用可擦除可编程只读存储器EPROM
  （2）毫微程序设计
  微程序可看作是解释机器指令的，毫微程序可看作是解释微程序的，而组成毫微程序的毫微指令则是用来解释微指令的。
  在普通的微程序计算机中，从主存取出的每条指令是由放在控制存储器中的微程序来解释执行的，通过控制线对硬件进行直接控制。
  若硬件不由微程序直接控制，而是通过存放在第二级控制存储器中的毫微程序来解释的，这个第二级控制存储器就称为毫微存储器，直接控制硬件的是毫微微指令。
  毫微程序设计采用两级微程序的设计方法。第一级微程序为垂直型微指令，并行功能不强，但有严格的顺序结构，由它确定后续微指令的地址，当需要时可调用第二级。第二级微程序为水平型微指令，具有很强的并行操作能力，但不包含后续微指令的地址。第二级微程序执行完毕后又返回到第一级微程序。

#####   8.硬布线和微程序控制器的特点

  （1）硬布线控制器的特点：
  硬布线控制器的优点是由于控制器的速度取决于电路延迟，所以速度快；缺点是由于将控制部件视为专门产生固定时序控制信号的逻辑电路，所以把用最少元件和取得最高速度作为设计目标，一旦设计完成，就不可能通过其他额外修改添加新功能。
  （2）微程序控制器的特点
  微程序控制器的优点是同组合逻辑控制器相比，微程序控制器具有规整性、灵活性、可维护性等一系列优点；缺点是由于微程序控制器采用了存储程序原理，所以每条指令都要从控制存储器中取一次，影响速度。
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351155035.png)

------

  例题：在微程序控制器中，形成微程序入口地址的是（）
  A.机器指令的地址码字段  B.微指令的微地址码字段
  C.机器指令的操作码字段  D.微指令的微操作码字段

  答案：C；执行公用的取指微程序从主存中取出机器指令后，由机器指令的操作码字段指出各个微程序的入口地址（初始微地址）

  例题：某带中断的计算机指令系统共有101种操作，采用微程序控制方式时，控制存储器中相应最少有（）个微程序

  答案：103

  例题：通常情况下，一个微程序的周期对应一个（）
  A.指令周期  B.主频周期
  C.机器周期  D.工作周期

  答案：A；

  例题：下列部件属于控制部件的是（）
  1.指令寄存器  2.操作控制器  3.PC  4.状态条件寄存器

  答案：B；

  例题：若某机主频为200MHz，每个指令周期平均为2.5个CPU周期，每个CPU周期平均包括2个主频周期
  （1）该机平均指令执行速度为多少MIPS
  （2）若主频不变，但每条指令平均包括5个CPU周期，每个CPU周期又包含4个主频周期，平均指令执行速度又为多少MIPS
  （3）由此可得出什么结论

  答案：（1）40MIPS；（2）10MIPS；（3）指令的复杂程度会影响指令的平均执行速度

  例题：（1）若存储器容量为64K x 32位，指令字长、存储字长、机器字长相等，指出主机中各寄存器的位数
  （2）写出硬布线控制器完成STA X（X为主存地址）指令发出的全部微操作命令及节拍安排
  （3）若采用微程序控制，还需增加哪些微操作

  答案：（1）
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351155036.png)
  答案中出现了ALU，有的架构中ALU具有完整结构，包含寄存器且挂在内部总线上
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351155037.png)

  例题：假设某机器有80条指令，平均每条指令由4条微指令组成，其中有一条取指微指令是所有指令公用的。已知微指令长度为32位，请估算控制存储器CM容量

  答案：1KB；总的微指令条数为241条，存储单元的个数为2的n次幂，因此CM容量为256x32位

  例题：某机共有52个微操作控制信号，构成5个相斥类的微命令组，各组分别包含5、8、2、15、22个微命令。已知可判定的外部条件有两个，微指令字长28位
  （1）按水平型微指令格式设计微指令，要求微指令的下地址字段直接给出后继微指令地址
  （2）指出控制存储器的容量

  答案：（1）条件测试位取2位（判断测试字段属于顺序控制字段的一部分，用直接编码方式，2个外部条件需用2位表示）
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351155038.png)
  （2)控存的字长就是微指令字长，总容量2^8 x 28位

------

### 5.5 指令流水线

####  5.5.1 指令流水线的基本概念

  计算机的流水线把一个重复的过程分解为若干子过程，每个子过程与其他子过程并行执行。 由于采用流水线技术只需增加少量硬件就能把计算机的运算速度提高几倍，因此成为计算机中普遍采用的一种并行处理技术。

#####   1.指令流水的定义

  一条指令的执行过程可分成多个阶段（或过程），如：
![在这里插入图片描述](E:\Development\Typora\images\20200823113756234.png)
  取指：根据PC内容访问主存，取出一条指令送到IR中
  分析：对指令操作码进行译码，按照给定的寻址方式和地址字段中的内容形成操作数的有效地址EA，并从有效地址EA中取出操作数
  执行：根据操作码字段，完成指令规定的功能，即把运算结果写到通用寄存器或主存中
  当多条指令在处理器中执行时，可以采取以下三种方式：
  （1）顺序执行方式
  指令按顺序执行，前一条指令执行完后，才启动下一条指令。
![在这里插入图片描述](E:\Development\Typora\images\20200823142930857.png)
  设取指、分析、执行三个阶段的时间都相等，用t表示，顺序执行n条指令所用的时间T为：
  T=3nt
  传统冯诺依曼机采用顺序执行方式，又称串行执行方式。其优点是控制简单，硬件代价小；缺点是执行指令的速度较慢，在任何时刻，处理机中只有一条指令在执行， 各功能部件的利用率很低。例如取指时内存忙，而指令执行部件空闲。

  （2）一次重叠执行方式：
  这种方式同时进行第k条指令的执行阶段和第k+1条指令的取值阶段
![在这里插入图片描述](E:\Development\Typora\images\20200823143638219.png)
  采用此种方式时，执行n条指令所用的时间为：
  T=（1+2n)t
  采用一次重叠方式的优点是，程序的执行时间缩短了1/3，各功能部件的利用率明显提高。但为此需要付出硬件上较大开销的代价，控制过程也比顺序执行复杂

  （3）二次重叠执行方式
  为了进一步提高指令的执行速度，可把取k+1条指令提前到分析第k条指令的期间完成，而将分析第k+1条指令与执行第k条指令同时进行。
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351155139.png)
  执行n条指令所用的时间：
  T=（2+n)t
  与顺序执行方式相比，采用二次重叠执行方式能够使指令的执行时间缩短近2/3。这是一种理想的指令执行方式，在正常情况下，处理机中同时有3条指令在执行。
  若每条指令需通过4个或5个执行步骤完成，则可采取3次或4次重叠执行方式

#####   2.流水线的表示方法

  通常用时空图来描述流水线的工作过程，如：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351155140.png)
  在时空图中，横坐标表示时间，即输入流水线中的各个任务在流水线中所经过的时间。流水线中各个流水段的执行时间都相等时，横坐标就被分割成相等长度的时间段。纵坐标表示空间，即流水线的每个流水段（对应各执行部件)
  在上图中，第一条指令I1在时刻t0进入流水线，在时刻t4流出流水线。每经过一个△t时间，便有一条指令进入流水线，从时刻t4开始有一条指令流出流水线。

#####   3.流水线方式的特点

  （1）把一个任务（一条指令或一个操作）分解为几个有联系的子任务，每个子任务由一个专门的功能部件来执行，并依靠多个功能部件并行工作来缩短程序的执行时间
  （2）流水线每个功能段部件后面都要有一个缓冲存储器，或称锁存器，其作用是保存本流水段的执行结果，供给下一流水段使用。
  （3）流水线中各功能段的时间应尽量相等，否则将引起堵塞、断流
  （4）只有连续不断地提供同一种任务时才能发挥流水线的效率，所以在流水线中处理的必须是连续任务。在采用流水线方式工作的处理机中，要在软件和硬件设计等多方面尽量为流水线提供连续的任务。
  （5）流水线需要有装入时间与排空时间。装入时间是指第一个任务进入流水线到输出流水线的时间。排空时间是指最后一个任务进入流水线到输出流水线的时间

####  5.5.2 流水线的分类

  按照不同的分类标准，可以把流水线分成多种不同的种类。下面从几个不同的角度介绍流水线的基本分类方法：

#####   1.部件功能级、处理机级和处理机间级流水线

  根据流水线使用级别的不同，流水线可分为部件功能级流水线、处理机级流水线和处理机间流水线。
  部件功能级流水将复杂的算术逻辑运算组成流水线工作方式。 例如，可将浮点加法操作分为求阶差、对阶、尾数相加及结果规格化等4个子过程。
  处理机级流水把一条指令解释过程分为多个子过程， 如取指、译码、执行、访存、写回5个子过程。
  处理机间流水是一种宏流水，其中每个处理机完成某一专门任务，各个处理机得到的结果需存放在与下一个处理机共享的存储器中。

#####   2.单功能流水线和多功能流水线

  按可以完成的功能，流水线可分为单功能流水线和多功能流水线。
  单功能流水线是指只能实现一种固定的专门功能的流水线；多功能流水线是指通过各段间的不同连接方式可以同时或不同时地实现多种功能的流水线。

#####   3.动态流水线和静态流水线

  按同一时间内各段间的连接方式，流水线可分为静态流水线和动态流水线。
  静态流水线指在同一时间内，流水线的各段只能按同一种功能的连接方式工作。
  动态流水线指在同一时间内，当某些段正在实现某种运算时，另一些段却正在进行另一种运算。 这样对提高流水线效率有好处，但会使流水线控制变得很复杂。

#####   4.线性流水线和非线性流水线

  按流水段的各个功能段之间是否有反馈信号，流水线可分为线性流水线与非线性流水线。
  线性流水线中，从输入到输出，每个功能段只允许经过一次，不存在反馈回路。非线性流水线存在反馈回路，从输入到输出的过程中，某些功能段将数次通过流水线，这种流水线适合进行线性递归的运算。

  流水线的每个子过程由专用的功能段实现，各功能段所需的时间应尽量相等。否则，时间长的功能段将成为流水线的瓶颈

####  5.5.3 影响流水线的因素

  影响流水线性能的因素主要有两方面：资源冲突和相关问题
  由于多条指令在同一时刻争用同一资源而形成的冲突称为资源冲突， 有以下两种解决办法：
  （1）前一指令访存时，使后一条相关指令（以及其后续指令）暂停一个时钟周期
  （2）单独设置数据存储器和指令存储器，使两项操作各自在不同的存储器中进行。
  在此主要讨论相关问题，流水线中的相关问题是指相邻指令间存在某种关联，使指令流水线出现停顿，降低了流水线的效率。主要有数据相关和控制相关两类。

#####   1.数据冲突（数据冒险）

  在一个程序中，下一条指令会用到这一条指令计算出的结果，此时这两条指令即为数据冒险。 当多条指令重叠处理时就会发生冲突，解决的办法有：
  （1）把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期，直到数据相关问题消失后再继续执行，这种方法称为后推法， 可分为硬件阻塞（stall）和软件插入"NOP"指令两种方法
  （2）设置相关专用通路，即不等前一条指令把计算结果写回寄存器组，下一条指令也不再读寄存器组，而直接把前一条指令的ALU的计算结果作为自己的输入数据开始计算过程，使本来需要暂停的操作变得可以继续执行，这称为数据旁路技术
  （3）通过编译器对数据相关的指令编译优化的方法，调整指令顺序来解决数据相关。

#####   2.控制冲突（控制冒险）

  一条指令要确定下一条指令的位置，例如在执行转移、调用或返回等指令时会改变PC值，而造成断流，会引起控制冒险。控制相关主要是由转移指令引起的。 解决的办法有：
  （1）对转移指令进行分支预测，尽早生成转移目标地址。 分支预测分为简单（静态）预测和动态预测。 静态预测总是预测条件不满足，即继续执行分支指令的后续指令。动态预测根据程序执行的历史情况，进行动态预测调整，有较高的预测准确率
  （2）预取转移成功和不成功两个控制流方向上的目标指令。
  （3）加快和提前形成条件码
  （4）提高转移方向的猜准率

------

  Cache缺失的处理过程也会引起流水线阻塞

------

####  5.5.4 流水线的性能指标

  衡量流水线性能的主要指标有吞吐率、加速比和效率。以下以线性流水线为例分析流水线的主要性能指标，分析方法和公式也适用于非线性流水线

#####   1.流水线的吞吐率

  在指令级流水线中，吞吐率是指在单位时间内流水线所完成的任务数量，或输出结果的数量。
  TP=n/Tk
  TP为流水线吞吐率，n是任务数，Tk是处理完n个任务所用的时间
  下图所示为各段执行时间都相等的流水线时空图
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351155141.png)
  在输入流水线中的任务连续的理想情况下，一条k段线性流水线能在k+n-1个时钟周期内完成n个任务。
  流水线的实际吞吐率为：
![在这里插入图片描述](E:\Development\Typora\images\2020082316033034.png)
  连续输入的任务数n——>∞时，最大吞吐率为
![在这里插入图片描述](E:\Development\Typora\images\20200823160449896.png)

#####   2.流水线的加速比

  完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比，称为流水线的加速比
  设T0表示不使用流水线时的执行时间，即顺序执行所用的时间；Tk表示使用流水线时的执行时间，则计算流水线加速比（S）的基本公式为：
  S=T0/Tk
  若流水线各段执行的时间都相等，则对于一条k段流水线：
![在这里插入图片描述](E:\Development\Typora\images\202008231610139.png)
  连续输入的任务数n——>∞时，最大加速比为
![在这里插入图片描述](E:\Development\Typora\images\20200823161100509.png)

#####   3.流水线的效率

  流水线的设备利用率称为流水线的效率。在时空图上，流水线的效率定义为完成n个任务占用的时空区有效面积，与n个任务所用的时间及k个流水段所围成的时空区总面积之比。 因此，流水线的效率包含了时间和空间两个因素。
  n个任务占用的时空区有效面积就是顺序执行n个任务所使用的总时间T0，而n个任务所用的时间与k个流水段所围成的时空区总面积为kTk，其中Tk是流水线完成n个任务所使用的总时间，因此流水线效率E：
![在这里插入图片描述](E:\Development\Typora\images\20200823161857889.png)
  流水线的各段执行时间均相等，当连续输入的任务数n——>∞时，最大效率为Emax=1；

------

  流水段越多，指令执行不一定越快：
  流水段越多：
  （1）流水段缓冲之间的额外开销增大。每个流水段有一些额外开销用于缓冲间传送数据、进行各种准备和发送等功能，这些开销加长了一条指令的整个执行时间，当指令间逻辑上相互依赖时，开销更大
  （2）流水段间控制逻辑变多、变复杂。用于流水线优化和存储器（或寄存器）冲突处理的控制逻辑将随流水段的增加而大增，这可能导致用于流水线之间控制的逻辑比段本身的控制逻辑更为复杂

------

####  5.5.5 超标量流水线的基本概念

#####   1.超标量流水线技术

  每个时钟周期内可并发多条独立指令，即以并行操作方式将两条或多条指令编译并执行，为此需配置多个功能部件
  超标量计算机不能调整指令的执行顺序，因此通过编译优化技术，把可并行执行的指令搭配起来，挖掘更多的指令并行性
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351155142.png)

#####   2.超流水线技术

  在一个时钟周期内再分段，在一个时钟周期内一个功能部件使用多次。超流水线技术将一些流水线寄存器插入到流水线段中，好比将流水线再分段
  不能调整指令的执行顺序，靠编译程序解决优化问题。
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351155143.png)

#####   3.超长指令字

  由编译程序挖掘出指令间潜在的并行性，将多条能并行操作的指令组合成一条具有多个操作码字段的超长指令字，为此需要采用多个处理部件

------

  例题：下列关于流水CPU基本概念的描述中，正确的是（）
  A.流水CPU是以空间并行性为原理构造的处理器
  B.流水CPU一定是RISC机器
  C.流水CPU一定是多媒体CPU
  D.流水CPU是一种非常经济而实用的时间并行技术

  答案：D；空间并行即资源重复，主要指多个功能部件共同执行同一任务的不同部分，典型的如多处理机系统。时间并行即时间重叠，让多个功能部件在时间上相互错开，轮流重叠执行不同任务的相同部分

  例题：下列关于超标量流水线特性的叙述中，正确的是（）
  1.能缩短流水线功能段的处理时间  2.能在一个时钟周期内同时发射多条指令  3.能结合动态调度技术提高指令执行并行性

  答案：2,3；超标量是指在CPU中有一条以上的流水线，并且每个时钟周期内可以完成一条以上的指令，其实质是以空间换时间。 它不影响流水线功能段的处理时间。静态调度：依靠编译器对代码进行静态调度，以减少相关和冲突。它不是在程序执行的过程中，而是在编译期间进行代码调度和优化，对相关的处理方法在程序执行过程中始终不变。通过把相关的指令拉开距离来减少可能产生的停顿。动态调度：在程序的执行过程中，依靠专门硬件对代码进行调度。超标量机能同时对若干条指令进行译码，将可以并行执行的指令送往不同的执行部件，在程序运行期间，由硬件通常是状态记录部件和调度部件来完成指令调度。

  例题：下列关于指令流水线数据通路的叙述中，错误的是（）
  A.包含生成控制信号的控制部件
  B.包含算术逻辑运算部件ALU
  C.包含通用寄存器组和取指部件
  D.由组合逻辑电路和时序逻辑电路组合而成

  答案：A；五阶段流水线可分为取指IF、译码/取数ID、执行EXC、存储器读MEM、写回Write Back；数字系统中，各个子系统通过数据总线连接形成的数据传送路径称为数据通路，包括PC，ALU，通用寄存器组、取指部件等，不包括控制部件

  例题：关于流水线技术的说法中，错误的是（）
  A.超标量技术需要配置多个功能部件和指令译码电路等
  B.与超标量技术和超流水线技术相比，超长指令字技术对优化编译器要求更高，而无其他硬件要求
  C.流水线按序流动时，在RAW、WAR和WAW中，只可能出现RAW相关
  D.超流水线技术相当于将流水线再分段，从而提高每个周期内功能部件的使用次数

  答案：B；超长指令字技术对Cache的容量要求更大，因为需要执行的指令长度也许会很长。流水线按序流动，肯定不会出现先读后写WAR和写后写WAW相关，只可能出现没有等到上一条指令写入，当前指令就去读寄存器的错误（此时可采用旁路相关来解决）。指令取操作数的动作一定在写回结果之前，故在按序流动的普通流水线中，先进入流水线的指令的取操作数和写回结果的动作一定位于后续指令写回结果的动作之前，故不可能出现WAR、WAW相关。唯一可能的数据相关问题是后续指令在前一指令写回结果之前读相关的操作数，即RAW相关。 而在非按序流动的流水线中，允许后进入流水线的指令超过先进入流水线的指令而先流出流水线，故三种数据相关问题都有可能出现

  例题：现有四级流水线，分别完成取指令、指令译码并取数、运算、回写四步操作，假设完成各部操作的时间依次为100ns，100ns，80ns,50ns
  （1）流水线的操作周期应设置为多少
  （2）试给出相邻两条指令发生数据相关的例子（假设在硬件上不采取措施），试分析第二条指令要推迟多少时间进行才不会出错
  （3）若在硬件设计上加以改进，至少需推迟多少时间

  答案：（1）100ns;
  （2）两条指令发生数据相关冲突的例子如下：
  ADD R1,R2
  SUB R4,R1
  发生写后读RAW相关；SUB指令先读R1，ADD指令后写入R1，发生数据冲突。若不采取措施，需推迟200ns
  （3）100ns

------

  RAR：两条连续的指令读取相同的寄存器时，会产生读后读相关，这种相关不会影响流水线

  RAW：假设指令j是在指令i后面执行的指令，RAW表示指令i将数据写入寄存器后，指令j才能从这个寄存器中读取数据。若指令j在指令i写入寄存器前尝试读出该寄存器内容，将得到不正确的数据
  RAW为某条指令要读取上一条指令所写入的寄存器的情况，按序流动的流水线只可能出现这种相关

  WAR：假设指令j是在指令i后面执行的指令，WAR表示指令i读出数据后，指令j才能写这个寄存器，若指令j在指令i读出数据前就写该寄存器，将使指令i读出的数据不正确
  WAR为某条指令的上条指令要读该指令的输出寄存器的情况

  WAW：假设指令j是在指令i后面执行的指令，WAW表示指令i将数据写入寄存器后，指令j才能将数据写入该寄存器，若指令j在指令i写入数据之前写入该寄存器，将使该寄存器的值不是最新值
  WAW为某条指令的上条指令要写该指令的输出寄存器的情况

------

  例题：假设指令流水线分为取指IF、译码ID、执行EX、回写WB 4个过程，共有10条指令连续输入此流水线
  （1）画出指令周期流程图
  （2）画出非流水线时空图
  （3）画出流水线时空图
  （4）假设时钟周期为100ns，求流水线的实际吞吐量（单位时间执行完毕的指令数）

  答案：![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351155144.png)
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351155245.png)

  例题：![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351155246.png)

  答案：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351155247.png)

  例题：![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351155248.png)
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351155249.png)
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351155250.png)

  答案：（1）FEFFH；（2）8；
  （3）I3的ID段被阻塞的原因是：因为I3与I1和I2都存在数据相关，需等到I1和I2将结果写回寄存器后，I3才能读寄存器内容，所以I3的ID段被阻塞；I4的IF段被阻塞的原因是：因为I4的前一条指令I3在ID段被阻塞，所以I4的IF段被阻塞。 （要求“按序发射，按序完成”，因此下一条指令的IF必须和上一条指令的ID并行，以免上一条指令发生冲突而导致下一条指令先执行完）
  （4）![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351155251.png)

  例题：![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351155252.png)
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389351155253.png)
  答案：（1）按字节编址；（2）4B；
  （3）由表可知，bne指令的机器代码为1446FFFAH，OFFSET为FFFAH，为-6；计算公式为（PC）+4+OFFSET x 4；
  （4)2,3，4,6；6；当前循环的第5条指令与下次循环的第1条指令虽然有数据相关，但由于第6条指令后有三个时钟周期的阻塞，因而消除了此数据相关。

  例题：假设对于上题中的计算机M和程序P的机器代码，M采用页式虚拟存储管理；P开始执行时，（R1）=（R2）=0，（R6）=1000，其机器代码已调入主存但不在Cache中；数组A未调入主存，且所有数组元素在同一页，并存储在磁盘的同一个扇区。
  （1）P执行结束时，R2的内容是多少
  （2）M的指令Cache和数据Cache分离。若指令Cache共有16行，Cache和主存交换的块大小为32B，则其数据区的容量是多少？若仅考虑程序段P的执行，则指令Cache的命中率是多少
  （3）P在执行过程中，哪条指令的执行可能发生溢出异常？哪条指令的执行可能产生缺页异常？对于数组A的访问，需要读磁盘和TLB至少各几次

  答案：（1）1000；（2）512B；（1000x6-1）/(1000x6)=99.98%
  （4）指令4；指令3；1；1001（第一次访问A[0]时会先查一次TLB，然后产生缺页，处理完缺页中断后，会重新访问A[0]，此时又查TLB。缺页中断处理后，返回到产生缺页中断的指令处重新执行）







## 6.总线

### 6.1 总线概述

####  6.1.1 总线基本概念

#####   1.总线的定义

**定义：**总线是一组能为多个部件`分时共享`的公共信息传送线路。

**特点**：**分时和共享**是总线的两个特点。
  

> - 分时是指同一时刻只允许有一个部件向总线发送信息，若系统中有多个部件，则它们只能分时地向总线发送信息。
> - 共享是指总线上可以挂接多个部件，各个部件之间互相交换的信息都可通过这组线路分时共享。 在某一时刻只允许有一个部件向总线发送信息，但多个部件可同时从总线上接收相同的信息。

#####   2.总线设备

  总线上所连接的设备，按其对总线有无控制功能可分为主设备和从设备两种。
  主设备：总线的主设备是指获得总线控制权的设备
  从设备：总线的从设备是指被主设备访问的设备，它只能响应从主设备发来的各种总线命令。

#####   3.总线特性

  总线特性是指机械特性（尺寸、形状）、电气特性（传输方向和有效的电平范围）、功能特性（每根传输线的功能）和时间特性（信号和时序的关系）

#####   4.总线的猝发传输方式

  在一个总线周期内传输存储地址连续的多个数据字的总线传输方式，称为猝发传送。

####  6.1.2 总线的分类

计算机系统中的总线，按功能划分为以下3类

#####   1.片内总线

  片内总线是芯片内部的总线，它是CPU芯片内部寄存器与寄存器之间、寄存器与ALU之间的公共连接线。

#####   2.系统总线

  系统总线是计算机系统内各功能部件（CPU、主存、I/O接口）之间相互连接的总线。
  按系统总线传输信息内容的不同，又可分为三类：数据总线、地址总线、控制总线
  a.数据总线用来传输各功能部件之间的数据信息，它是双向传输总线，其位数与机器字长、存储字长有关。
  b.地址总线用来指出数据总线上的源数据或目的数据所在的主存单元或I/O端口的地址，它是单向传输总线，地址总线的位数与主存地址空间的大小有关
  c.控制总线传输的是控制信息，包括CPU送出的控制命令和主存（或外设）返回CPU的反馈信号
  注意区分数据通路和数据总线：各个功能部件通过数据总线连接形成的数据传输路径称为数据通路。数据通路表示的是数据流经的路径，而数据总线是承载的媒介。

#####   3.通信总线

  通信总线是在计算机系统之间或计算机系统与其他系统（如远程通信设备、测试设备）之间传送信息的总线，通信总线也称外部总线。

  

> 此外，按时序控制方式可将总线分为**同步和异步总线**，还可按数据传输格式将总线划分为**并行总线和串行总线**。

####  6.1.3 系统总线的结构

  总线结构通常分为单总线结构、双总线结构和三总线结构等。

#####   1.单总线结构

  单总线结构将CPU、主存、I/O设备（通过I/O接口）都挂在一组总线上，允许I/O设备之间、I/O设备与主存之间直接交换信息。CPU与主存、CPU与外设之间可直接进行信息交换，而无须经过中间设备的干预。

  单总线结构并不是指只有一根信号线，系统总线按传送信息的不同可细分为地址总线、数据总线和控制总线。
  单总线结构优点：结构简单，成本低，易于接入新的设备；缺点：带宽低、负载重，多个部件只能争用唯一的总线，且不支持并发传送操作。

#####   2.双总线结构

  双总线结构有两条总线：一条是主存总线，用于在CPU、主存和通道之间传送数据；另一条是I/O总线，用于在多个外部设备与通道之间传送数据。
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638935419511.png)
  双总线结构优点：将低速I/O设备从单总线上分离出来，实现了存储器总线和I/O总线分离。 缺点：需要增加通道等硬件设备。

#####   3.三总线结构

  三总线结构是在计算机系统各部件之间采用3条各自独立的总线来构成信息通路，这三条总线分别为主存总线、I/O总线和直接内存访问（DMA）总线
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638935419512.png)
  主存总线用于在CPU和内存之间传送地址、数据和控制信息。I/O总线用于在CPU和各类外设之间通信。DMA总线用于在内存和高速外设之间直接传送数据。 在三总线结构中，任一时刻只能使用一种总线。
  三总线结构优点：提高了I/O设备的性能，使其更快地响应命令，提高系统吞吐量。 缺点：系统工作效率较低。

####  6.1.4 总线的性能指标

  （1）总线的传输周期
  指一次总线操作所需的时间（**包括申请阶段、寻址阶段、传输阶段和结束阶段**），`简称总线周期`。总线传输周期通常由若干总线时钟周期构成。
  （2）总线时钟周期
  即机器的时钟周期。 计算机有一个统一的时钟，以控制整个计算机的各个部件，总线也要受此时钟的控制。
  （3）总线的工作频率
  总线上各种操作的频率，为总线周期的倒数。 实际上指1秒内传送几次数据。若总线周期=N个时钟周期，则总线的工作频率=时钟频率/N
  （4）总线的时钟频率
  即机器的时钟频率，它为时钟周期的倒数。
  （5）总线宽度
  又称总线位宽，它是总线上同时能够传输的数据位数，通常指数据总线的根数， 如32根称为32位总线
  （6）总线带宽
  可理解为总线的数据传输率，即单位时间内总线上可传输数据的位数，通常用每秒传送信息的字节数来衡量，单位可用字节/秒（B/s）表示。 总线带宽=总线工作频率 x （总线宽度/8）
  （7）总线复用
  总线复用是指一种信号线在不同的时间传输不同的信息，因此可以使用较少的线传输更多的信息， 从而节省空间和成本。
  （8）信号线数
  地址总线、数据总线和控制总线三种总线数的总和称为信号线数。 其中，总线的最主要性能指标为总线宽度、总线（工作）频率、总线带宽，总线带宽是指总线本身所能达到的最高传输速率，它是衡量总线性能的重要指标。
  总线带宽=总线宽度 x 总线频率

------

  `例题`：某同步总线的时钟频率为100MHz，宽度为32位，地址/数据线复用，每传输一个地址或数据占用一个时钟周期，若该总线支持突发
（猝发）传输方式，则一次“主存写”总线事务传输128位数据所需要的时间至少是

  答案：50ns；传送地址需10ns

  `例题`：计算机使用总线结构便于增减外设，同时（）
  A.减少信息传输量  B.提高信息的传输速度
  C.减少信息传输线的条数  D.提高信息传输的并行性

  答案：C；计算机使用总线结构便于增减外设，同时减少信息传输线的条数。但相对于专线结构，实际上降低了信息传输的并行性及信息的传输速度

  `例题`：单周期处理器中所有指令的指令周期为一个时钟周期。下列关于单周期处理器的叙述中，错误的是（）
  A.可以采用单总线结构数据通路  B.处理器时钟频率较低
  C.在指令执行过程中控制信号不变  D.每条指令的CPI为1

  答案：A；由于要考虑比较慢的指令，最慢的指令也是1个CLOCK完成，因此处理器的时钟频率较低；一个指令周期内包含传输指令与数据的过程，单总线结构数据通路上传输指令与数据各需一个时钟周期，共需两个时钟周期，单总线结构不支持并发传送操作；控制信号即PC中的内容，在指令执行过程中，控制信号不变。

  `例题`：在32位总线系统中，若时钟频率为500MHz，传送一个32位字需要5个时钟周期，则该总线的数据传输率是（）
  A.200MB/s  B.400MB/s
  C.600MB/s  D.800MB/s

  答案：B；

  `例题`：下列关于多总线结构的叙述中，错误的是（）
  A.靠近CPU的总线速度较快
  B.存储器总线可支持突发传送方式
  C.总线之间须通过桥接器相连
  D.PCI-Expressx16采用并行传输方式

  答案：D；多总线结构用速率高的总线连接高速设备，用速率低的总线连接低速设备；突发传送方式把多个数据单元作为一个独立传输处理，从而最大化设备的吞吐量。现实中一般用支持突发传送方式的总线来提高存储器的读写效率；各总线通过桥接器相连，后者起流量交换作用。PCI-Express总线都采用串行数据包传送数据。

  `例题`：假定一台计算机采用3通道存储器总线，配套的内存条型号为DDR3-1333，即内存条所插接的存储器总线的工作频率为1333MHz，总线宽度为64位，则存储器总线的总带宽大约是

  答案：32GB/s;注意计算机采用3通道存储器总线（并行通信通道）

  `例题`：某总线支持二级Cache块传输方式，若每块6个字，每个字长4字节，时钟频率为100MHz
  （1）读操作时，第一个时钟周期接收地址，第二、三个为延时周期，另用4个周期传送一个块。读操作的总线传输速率为多少
  （2）写操作时，第一个时钟周期接收地址，第二个为延时周期，另用4个周期传送一个块，写操作的总线传输速率是多少
  （3）设在全部的传输中，70%用于读，30%用于写，该总线在本次传输中的平均传输速率是多少

  答案：（1）343MB/s;（2）400MB/s;（3）358MB/s



### 6.3 总线操作和定时

  总线定时是指总线在双方交换数据的过程中需要时间上配合关系的控制，这种控制称为总线定时，其实质是一种协议或规则，主要有同步和异步两种基本定时方式。

####  6.3.1 总线传输的4个阶段

  一个总线周期通常可分为以下4个阶段：
  （1）**申请分配阶段：**
  由需要使用总线的主模块（或主设备）提出申请，经总线仲裁机构决定将下一传输周期的总线使用权授予某一申请者。 也可将此阶段细分为传输请求和总线仲裁两个阶段。
  （2）**寻址阶段：**
  取得使用权的主模块通过总线发出本次要访问的从模块（或从设备）的地址及相关命令，启动参与本次传输的从模块。
  （3）**传输阶段：**
  主模块和从模块进行数据交换，可单向或双向进行数据传送
  （4）**结束阶段：**
  主模块的相关信息均从系统总线上撤除，让出总线使用权

####  6.3.2 同步定时方式

  所谓同步定时方式，是指系统采用一个统一的时钟信号来协调发送和接收双方的传送定时关系。 时钟产生相等的时间间隔，每个间隔构成一个总线周期。在一个总线周期中，发送方和接收方可进行一次数据传送。因为采用统一的时钟，每个部件或设备发送或接收信息都在固定的总线传送周期中，一个总线的传送周期结束，下一个总线的传送周期开始。
  优点：传送速度快，具有较高的传输速率； 总线的控制逻辑简单。
  缺点：主从设备属于强制性同步；不能及时进行数据通信的有效性检验，可靠性较差。
  同步通信适用于总线长度较短及总线所接部件的存取时间比较接近的系统。

####  6.3.3 异步定时方式

  在异步定时方式中，没有统一的时钟，也没有固定的时间间隔，完全依靠传送双方相互制约的握手信号来实现定时控制。 通常，把交换信息的两个部件或设备分为主设备和从设备，主设备提出交换信息的请求信号，经接口传送到从设备；从设备接到主设备的请求后，通过接口向主设备发出回答信号。
  优点：总线周期长度可变，能保证两个工作速度相差很大的部件或设备之间可靠地进行信息交换，自动适应时间的配合。
  缺点：比同步控制方式复杂，速度比同步定时方式慢

  根据请求和回答信号的撤销是否互锁，异步定时方式可分为以下3种类型：
  （1）不互锁方式
  ![在这里插入图片描述](E:\Development\Typora\images\20200824110143636.png)
  主设备发出请求信号后，不必等到接到从设备的回答信号，而是经过一段时间便撤销请求信号。 而从设备在接到请求信号后，发出回答信号，并经过一段时间后自动撤销回答信号。 双方不存在互锁关系。

  （2）半互锁方式
![在这里插入图片描述](E:\Development\Typora\images\20200824110721576.png)
  主设备发出请求信号后，必须在接到从设备的回答信号后，才撤销请求信号， 有互锁的关系。而从设备在接到请求信号后，发出回答信号，但不必等待获知主设备的请求信号已经撤销，而是隔一段时间后自动撤销回答信号，不存在互锁关系。

  （3）全互锁方式
  ![在这里插入图片描述](E:\Development\Typora\images\20200824111103743.png)
  主设备发出请求信号后，必须在从设备回答后才撤销请求信号；从设备发出回答信号后，必须在获知主设备请求信号已撤销后，再撤销其回答信号。双方存在互锁关系。

------

  总线也能采用半同步方式进行通信。半同步通信增设了一条等待$\overline{WAIT}$响应信号线，采用插入时钟（等待）周期的措施协调通信双方的配合问题。半同步通信总线既保留了同步通信的特点，又能采用异步应答方式连接速度相差较大的设备。通过在异步总线中引入时钟信号，其就绪和应答信号都在时钟的上升沿或下降沿有效，而不受其他时间的信号干扰。
  例如，某个采用半同步方式的总线总是从某个时钟开始，在每个时钟到来时，采样Wait信号，若无效，则说明数据未准备好，下个时钟到来时，再采样Wait信号，直到检测到有效，再去数据线上取数据。PCI总线也是一种半同步总线，它的所有事件都在时钟下降沿同步，总线设备在时钟开始的上升沿采样总线信号。
  半同步通信适用于系统工作速度不高但又包含了由许多工作速度差异较大的各类设备组成的简单系统。
  此外还有一种通信方式为分离式通信，它将一个传输周期（或总线周期）分解为两个子周期。在第一个子周期中，主模块A在获得总线使用权后将命令、地址以及其他有关信息，包括该主模块编号发到系统总线上，经总线传输后，由有关的从模块B接收下来。主模块A向系统总线发布这些信息只占用总线很短的时间，一旦发送完，立即放弃总线使用权，以便其他模块使用。在第二个子周期中，当B模块收到A模块发来的有关命令信号后，经选择、译码、读取等一系列内部操作，将A模块所需的数据准备好，便由B模块申请总线使用权，一旦获准，B模块便将A模块的编号、B模块的地址、A模块所需的数据等一系列信息送到总线上，供A模块接收。上述两个传输子周期都只有单方向的信息流，每个模块都变成了主模块。

------

  例题：在手术过程中，医生将手伸出，等护士将手术刀递上，待医生握紧后，护士才松手。若把医生和护士视为两个通信模块，上述动作相当于（）
  A.同步通信  B.异步通信的全互锁方式
  C.异步通信的半互锁方式  D.异步通信的不互锁方式

  答案：B；

------

### 6.4 总线标准

  按总线标准设计的接口可视为通用接口，在接口的两端，任何一方只需根据总线标准的要求完成自身方面的功能要求，而无须了解对方接口的要求。

####  6.4.1 常见的总线标准

  目前，典型的总线标准有ISA、EISA、VESA、PCI、PCI-Express、AGP、RS-232C、USB等。 它们的主要区别是总线宽度、带宽、时钟频率、寻址能力、是否支持突发传送等。
  （1）ISA
  ISA（Industry Standard Architecture，工业标准体系结构）总线是最早出现的微型计算机的系统总线，应用在IBM的AT机上
  （2）EISA
  EISA（Extended Industry Standard Architecture，扩展的ISA）总线是为配合32位CPU而设计的扩展总线，EISA对ISA完全兼容。
  （3）VESA
  VESA（Video Electronics Standards Association，视频电子标准协会）总线是一个32位标准的计算机局部总线，是针对多媒体PC要求高速传送活动图像的大量数据应运而生的。
  （4）PCI
  PCI（Peripheral Component Interconnect，外部设备互连）总线是高性能的32位或64位总线，是专为高度集成的外围部件、扩充插板和处理器/存储器系统设计的互连机制。 目前常用的PCI适配器有显卡、声卡、网卡等。PCI总线支持即插即用。 PCI总线是一个与处理器时钟频率无关的高速外围总线，属于局部总线。 PCI总线可以通过桥连接实现多层PCI总线。
  （5）PCI-Express（PCI-E）
  PCI-Express是最新的总线和接口标准，它将全面取代现行的PCI和AGP，最终统一总线标准。
  （6）AGP
  AGP（Accelerated Graphics Port，加速图形接口）是一种视频接口标准，专用于连接主存和图形存储器，属于局部总线。AGP技术为传输视频和三维图形数据提供了解决方案。
  （7）RS-232C
  RS-232C（Recommended Standrad,RS）是由美国电子工业协会（EIA）推荐的一种串行通信总线，是应用于串行二进制交换的数据终端设备（DTE）和数据通信设备（DCE）之间的标准接口
  （8）USB
  USB（Universal Serial Bus，通用串行总线）是一种连接外部设备的I/O总线，属于设备总线。具有即插即用、热插拔等优点，有很强的连接能力。
  （9）PCMCIA
  PCMCIA（Personal Computer Memory Card International Association）是广泛应用于笔记本电脑的一种接口标准，是一个用于扩展功能的小型插槽。具有即插即用功能。
  （10）IDE
  IDE（Integrated Drive Electronics，集成设备电路），更准确地称为ATA，是一种IDE接口磁盘驱动器接口类型，硬盘和光驱通过IDE接口与主板连接。
  （11）SCSI
  SCSI（Small Computer System Interface，小型计算机系统接口）是一种用于计算机和智能设备之间（硬盘、软驱、光驱、打印机等）系统级接口的独立处理器标准。SCSI是一种智能的通用接口标准。
  （12）SATA
  SATA（Serial Advanced Technology Attachment，串行高级技术附件）是一种基于行业标准的串行硬件驱动器接口。

------

  例题：下列关于USB总线特性的描述中，错误的是（）
  A.可实现外设的即插即用和热插拔  B.可通过级联方式连接多台外设
  C.是一种通信总线，连接不同外设  D.可以同时传输2位数据，数据传输率高

  答案：D；USB是串行总线

  例题：下列选项中，用于设备和设备控制器（I/O接口）之间互连的接口标准是（）
  A.PCI  B.USB
  AGP  D.PCI-Express

  答案：B；USB是一种连接外部设备的I/O总线标准，属于设备总线，是设备和设备控制器之间的接口。而PCI、AGP、PCI-E作为计算机系统的局部总线标准，通常用来连接主存、网卡、视频卡等



## 7.输入/输出系统

### 7.1 I/O系统基本概念

####  7.1.1 输入/输出系统

  输入/输出是以主机为中心而言的，**将信息从外部设备传送到主机称为输入，反之称为输出**。 I/O系统解决的主要问题是对各种形式的信息进行输入和输出的控制。
  

I/O系统中的几个基本概念如下：
  （1）**外部设备**
  包括输入/输出设备及通过输入/输出接口才能访问的外存储设备。
  （2）**接口**
  在各个外设与主机之间传输数据时进行各种协调工作的`逻辑部件`。协调包括传输过程中速度的匹配、电平和格式转换等。
  （3）**输入设备**
  用于向计算机系统输入命令和文本、数据等信息的部件。 键盘和鼠标是最基本的输入设备。
  （4）**输出设备**
  用于将计算机系统中的信息输出到计算机外部进行显示、交换等的部件。 显示器和打印机是最基本的输出设备。
  （5）**外存设备**
  指除计算机内存及CPU缓存等外的存储器。 硬磁盘、光盘等是最基本的外存设备。

>     一般来说，I/O系统由I/O软件和I/O硬件两部分构成
>
>   （1）I/O软件
>     包括驱动程序、用户程序、管理程序、升级补丁等。通常采用I/O指令和通道指令实现CPU与I/O设备的信息交换。
>   （2）I/O硬件
>     包括外部设备、设备控制器和接口、I/O总线等。 通过`设备控制器`来控制I/O设备的具体动作；通过I/O接口与主机（总线）相连。

------

  I/O指令与通道指令：
  I/O指令：
  ![在这里插入图片描述](E:\Development\Typora\images\20200825215320121.png)
  操作码字段可作为I/O指令与其他指令（如访存指令、算逻指令、控制指令等)的判别代码；命令码体现I/O设备的具体操作；设备码是多台I/O设备的选择码。
  I/O指令的命令码一般可表述为如下几种情况：

- 将数据从I/O设备输入主机。例如，将某台设备接口电路的数据缓冲寄存器中的数据读入CPU的某个寄存器（如累加器ACC）
- 将数据从主机输出至I/O设备。例如，将CPU的某个寄存器（如ACC）中的数据写入某台设备接口电路的数据缓冲寄存器内
- 状态测试。利用命令码检测各个I/O设备所处的状态是忙还是准备就绪，以便决定下一步是否可进入主机与I/O设备交换信息的阶段
- 形成某些操作命令。不同I/O设备与主机交换信息时，需要完成不同的操作

  I/O指令的设备码相当于设备的地址。

  通道指令：
  通道指令是对具有通道的I/O系统专门设置的指令，这类指令一般用以指明参与传送（写入或读取）的数据组在主存中的首地址；指明需要传送的字节数或所传送数据组的末地址；指明所选设备的设备码及完成某种操作的命令码。
  通道指令又称通道控制字，它是通道用于执行I/O操作的指令，可以由管理程序存放在主存的任何地方，由通道从主存中取出并执行。通道程序即由通道指令组成，它完成某种外围设备与主存之间传送信息的操作。

------

####  7.1.2 I/O控制方式

  基本的控制方式主要有以下4种：
  （1）**程序查询方式**
  由CPU通过程序`不断`查询I/O设备是否已做好准备，从而控制I/O设备与主机交换信息

  （2）**程序中断方式**
  只在I/O设备准备就绪并向CPU发出中断请求时才予以响应

  （3）**DMA方式**
  主存和I/O设备间有一条直接数据通路，当主存和I/O设备交换信息时，无须调用中断服务程序。

  （4）**通道方式**
  通道是用来负责**管理I/O设备以及实现主存与I/O设备之间交换信息的`部件`**，可以视为一种具有特殊功能的**处理器**。通道有专用的通道指令，能独立地执行用通道指令所编写的输入输出程序，但不是一个完全独立的处理器。它依据CPU的I/O指令进行启动、停止或改变工作状态，`是从属于CPU的一个专用处理器`。 在系统中设有通道控制部件，每个通道都挂接若干外设，主机在执行I/O命令时，只需启动有关通道，通道将执行通道程序，从而完成I/O操作。

  ==其中，方式（1）、（2）主要用于数据传输率较低的外部设备，方式（3）、（4）主要用于数据传输率较高的设备==

------

> I/O处理机：
>
>   I/O处理机又称外围处理机，它基本独立于主机工作，既可完成I/O通道要完成的I/O控制，又可完成码制变换、格式处理、数据块检错、纠错等操作。
>
> ​		具有I/O处理机的输入输出系统与CPU工作的并行性更高。

------

------

  `例题`：在微型机系统中，I/O设备通过（）与主板的系统总线相连接
  A.DMA控制器  ==B.设备控制器==
  C.中断控制器  D.I/O端口

  答案：B；I/O设备与主机（CPU、内存）之间的通信不是直接的，而是通过设备控制器，设备控制器是I/O设备和主机之间的中介

------

### 7.2 外部设备

  外部设备也称外围设备，是除主机外的能直接或间接与计算机交换信息的装置。**最基本的外部设备主要有键盘、鼠标、显示器、打印机、磁盘存储器和光盘存储器等。**

####  7.2.1 输入设备

#####   1.键盘

  键盘通常以矩阵的形式排列按键，每个键相当于一个开关，按下键时，电信号连通；松开键时，弹簧弹起键，电信号断开。
  键盘输入信息可分为3个步骤：

（1）查出按下的是哪个键；（2）将该键翻译成能被主机接收的编码，如ASCII码；（3）将编码传送给主机

#####   2.鼠标

  鼠标是常用的定位输入设备，它把用户的操作与计算机屏幕上的位置信息相联系。常用的鼠标有光电式和机械式两种。
  工作原理：鼠标在平面上移动时，其底部传感器把运动的方向和距离检测出来，从而控制光标做相应的运动。

####  7.2.2 输出设备

#####   1.显示器

  按显示设备所用的显示器件分类，有阴极射线管（CRT）显示器、液晶显示器（LCD）、发光二极管（LED）显示器等。按所显示的信息内容分类，有字符显示器、图形显示器和图像显示器3大类。显示器属于用点阵方式运行的设备，有以下主要参数：
  屏幕大小：以对角线的长度表示
  分辨率：所能表示的像素个数，屏幕上的每个光点就是一个像素，以宽和高的像素数的乘积表示
  灰度级：灰度级是指黑白显示器中所显示的像素点的亮暗差别，在彩色显示器中则表现为颜色的不同，灰度级越多，图像层次越清楚、逼真。
  刷新：光点只能保持极短的时间便会消失，为此必须在光点消失之前再重新扫描显示一遍，这个过程称为刷新
  刷新频率：指单位时间内扫描整个屏幕内容的次数。
  显示存储器（VRAM）：也称刷新存储器，为了不断提高刷新图像的信号，必须把一帧图像信息存储在刷新存储器中。其存储容量由图像分辨率和灰度级决定，分辨率越高，灰度级越多，刷新存储器容量越大。
  VRAM容量=分辨率 x 灰度级位数
  VRAM带宽=分辨率 x 灰度级位数 x 帧频

  （1）阴极射线管（CRT）显示器
  按显示信息内容不同，可分为字符显示器、图形显示器和图像显示器；按扫描方式不同，可分为光栅扫描和随机扫描两种显示器。以下介绍字符显示器和图形显示器：
  a.字符显示器：
  显示字符的方法以点阵为基础。点阵的多少取决于显示字符的质量和字符窗口的大小。字符窗口是指每个字符在屏幕上所占的点数，它包括字符显示点阵和字符间隔。
  将点阵存入由ROM构成的字符发生器中，在CRT进行光栅扫描的过程中，从字符发生器中依次读出某个字符的点阵，按照点阵中0和1代码的不同控制扫描电子束的开或关，从而在屏幕上显示字符。对应于每个字符窗口，所需显示字符的ASCII码被存放在视频存储器VRAM中，以备刷新。
  b.图形显示器
  将所显示图形的一组坐标点和绘图命令组成显示文件存放在缓冲存储器中，缓存中的显示文件传送给矢量（线段）产生器，产生相应的模拟电压，直接控制电子束在屏幕上的移动。为在屏幕上保留持久稳定的图像，需按一定的频率对屏幕反复刷新。这种显示器的优点是分辨率高且显示的曲线平滑。目前高质量的图形显示器采用这种随机扫描方式。缺点是当显示复杂图形时，会有闪烁感。

  （2）液晶显示器（LCD）
  原理：利用液晶的电光效应，由图像信号电压直接控制薄膜晶体管，再间接控制液晶分子的光学特性来实现图像的显示。
  特点：体积小、重量轻、省电、无辐射、绿色环保、画面柔和、不伤眼等

  （3）LED（发光二极管）显示器
  原理：通过控制半导体发光二极管来显示文字、图形、图像等各种信息。
  LCD与LED是两种不同的显示技术。LCD是由液态晶体组成的显示屏，而LED则是由发光二极管组成的显示屏。与LCD相比，LED显示器在亮度、功耗、可视角度和刷新速率等方面都更具优势

#####   2.打印机

  按工作原理，打印机分为击打式和非击打式两大类；按工作方式，打印机分为点阵打印机、针式打印机、喷墨式打印机、激光打印机等
  （1）针式打印机
  原理:在联机状态下，主机发出打印命令，经接口、检测和控制电路，间歇驱动纵向送纸和打印头横向移动，同时驱动打印机间歇冲击色带，在纸上打印出所需的内容。
  特点：针式打印机擅长多层复写打印，实现各种票据或蜡纸等的打印。其工作原理简单，造价低廉，耗材便宜，但打印分辨率和打印速度不够高。
  （2）喷墨式打印机
  原理：带电的喷墨雾点经过电极偏转后，直接在纸上形成所需字形。彩色喷墨打印机基于三基色原理，即分别喷射3种颜色的墨滴，按一定的比例混合出所要求的颜色
  特点：打印噪声小，可实现高质量彩色打印，通常打印速度比针式打印机快；但防水性差，高质量打印机需专用打印纸。
  （3）激光打印机
  原理：计算机输出的二进制信息，经过调制后的激光束扫描，在感光鼓上形成潜像，再经过显影、转印和定影，在纸上得到所需的字符或图像。
  特点：打印质量高、速度快、噪声小、处理能力强；但耗材多、价格较贵、不能复写打印多份，且对纸张的要求高。
  激光打印机是将激光技术和电子显像技术相结合的产物。感光鼓（也称硒鼓）是激光打印机的核心部件。

####  7.2.3 外存储器

  **计算机的外存储器又称辅助存储器**，目前主要使用磁表面存储器

> 所谓磁表面存储，是指把某些磁性材料薄薄地涂在金属铝或塑料表面上作为磁载体来存储信息。磁盘存储器、磁带存储器和磁鼓存储器均属于磁表面存储器。

磁表面存储器的优点：

​	（1）存储容量大，位价格低；

​	（2）记录介质可重复使用；

​	（3）记录信息可长期保存而不丢失，甚至可以脱机存档；

​	（4）非破坏性读出，读出时不需要再生。

缺点：存取速度慢，机械结构复杂，对工作环境要求高

#####   1.磁盘存储器

  （1）磁盘设备的组成
  a.存储区域
  一块硬盘含有若干记录面，每个记录面划分为若干磁道，而每条磁道又划分为若干扇区，扇区（也称块）是磁盘读写的最小单位，即磁盘按块存取。

- 磁头数：即记录面数，表示硬盘共有多少个磁头，磁头用于读取/写入盘片上记录面的信息，一个记录面对应一个磁头
- 柱面数：表示硬盘每面盘片上有多少条磁道。 在一个盘组中，不同记录面的相同编号（位置）的诸磁道构成一个圆柱面。
- 扇区数：表示每条磁道上有多少个扇区。

  b.硬盘存储器的组成
  硬盘存储器由磁盘驱动器、磁盘控制器和盘片组成

- 磁盘驱动器：核心部件是磁头组件和盘片组件， 温彻斯特盘是一种可移动磁头固定盘片的硬盘存储器
- 磁盘控制器：磁盘存储器和主机的接口， 主流的标准有IDE、SCSI、SATA等

  （2）磁记录原理
  原理：磁头和磁性记录介质相对运动时，通过电磁转换完成读/写操作
  编码方法：按某种方案（规律），把一连串的二进制信息变换成存储介质磁层中一个磁化翻转状态的序列，并使读/写控制电路容易、可靠地实现转换。
  磁记录方式：通常采用调频制FM和改进型调频制MFM的记录方式

  （3）磁盘的性能指标
  a.磁盘的容量
  一个磁盘所能存储的字节总数称为磁盘容量， 磁盘容量有非格式化容量和格式化容量之分。 非格式化容量是指磁记录表面可以利用的磁化单元总数，格式化容量是指按照某种特定的记录格式所能存储信息的容量。
  b.记录密度
  记录密度是指盘片单位面积上记录的二进制信息量，通常以道密度、位密度和面密度表示。 道密度是沿磁盘半径方向单位长度上的磁道数，位密度是磁道单位长度上能记录的二进制代码位数，面密度是位密度和道密度的乘积。
  c.平均存取时间
  平均存取时间由寻道时间（磁头移动到目的磁道的时间）、旋转延迟时间（磁头定位到要读写扇区的时间，即旋转一周时间的一半）和传输时间（传输数据所花费的时间）三部分构成。 由于寻道和找扇区的距离远近不一，因此前两部分通常取平均值。
  d.数据传输率
  磁盘存储器在单位时间内向主机传送数据的字节数，称为数据传输率。 假设磁盘转速为r转/s，每条磁道容量为N字节，则数据传输率为
  Dr=rN

  （4）磁盘地址
  主机向磁盘控制器发送寻址信息， 磁盘的地址如图：
![在这里插入图片描述](E:\Development\Typora\images\20200824171254221.png)
  若系统中有4个驱动器，每个驱动器带一个磁盘，每个磁盘256个磁道、16个盘面，每个盘面划分为16个扇区，则每个扇区地址要18位二进制代码，格式如图：
![在这里插入图片描述](E:\Development\Typora\images\20200824171524930.png)

  （5）硬盘的工作过程
  硬盘的主要操作是寻址、读盘、写盘。每个操作都对应一个控制字，硬盘工作时，第一步是取控制字，第二步是执行控制字。
  硬盘属于机械式部件，其读写操作是串行的，不可能在同一时刻既读又写，也不可能在同一时刻读两组数据或写两组数据。

#####   2.磁盘阵列

  RAID（廉价冗余磁盘阵列）是指将多个独立的物理磁盘组成一个独立的逻辑盘，数据在多个物理盘上分割交叉存储、并行访问 ，具有更好的存储性能、可靠性和安全性。
  RAID的分级如下所示。在RAID1~RAID5几种方案中，无论何时有磁盘损坏，都可随时拔出受损的磁盘再插入好的磁盘，而数据不会损坏，提升了系统的可靠性。

- RAID0：无冗余和无校验的磁盘阵列
- RAID1：镜像磁盘阵列
- RAID2：采用纠错的海明码的磁盘阵列
- RAID3：位交叉奇偶校验的磁盘阵列
- RAID4：块交叉奇偶校验的磁盘阵列
- RAID5：无独立校验的奇偶校验磁盘阵列

  RAID0把连续多个数据块交替地存放在不同物理磁盘的扇区中，几个磁盘交叉并行读写，不仅扩大了存储容量，而且提高了磁盘数据存取速度，但RAID0没有容错能力。
  为了提高可靠性，RAID1使两个磁盘同时进行读写，互为备份，若一个磁盘出现故障，可从另一磁盘中读出数据。 两个磁盘当一个磁盘使用，意味着容量减少一半。
  RAID通过同时使用多个磁盘，提高了传输率；通过在多个磁盘上并行存取来大幅提高存储系统的数据吞吐量；通过镜像功能，提高安全可靠性；通过数据校验，提供容错能力。

#####   4.固态硬盘

  微小型高档笔记本计算机采用高性能Flash Memory作为硬盘来记录数据，这种“硬盘”称固态硬盘。固态硬盘除需要Flash Memory外，还需其他硬件和软件的支持。

------

  `例题`：下列关于磁盘的说法中，错误的是（）
  A.本质上，U盘（闪存）是一种只读存储器
  B.RAID技术可以提高磁盘的磁记录密度和磁盘利用率
  C.未格式化的硬盘容量要大于格式化后的硬盘容量
  D.计算磁盘的存取时间时，寻道时间和旋转等待时间常取其平均值

  答案：B；RAID将多个物理盘组合成逻辑盘，不会影响磁记录密度，也不会提高磁盘利用率

  `例题`：硬磁盘共有4个记录面，存储区域内半径为10cm,外半径为15.5cm，道密度为60道/cm，外层位密度为600bit/cm，转速为6000转/分
  （1）硬磁盘的磁道总数为多少
  （2）硬磁盘的容量为多少
  （3）将长度超过一个磁道容量的文件记录在同一个柱面上是否合理
  （4）采用定长数据块记录格式，直接寻址的最小单位是什么？寻址命令中磁盘地址如何表示？
  （5）假定每个扇区的容量为512B，每个磁道有12个扇区，寻道的平均等待时间为10.5ms，试计算磁盘平均存取时间

  答案：（1）1320；（2）9636000B；（3）合理，因为不需要重新寻找磁道，这样数据读/写速度快；
  （4）扇区；
  （5)16.33ms;

------

### 7.3 I/O接口

  I/O接口（I/O控制器）**是主机和外设之间的交接界面**，通过接口可以实现主机和外设之间的信息交换。 主机和外设具有各自的工作特点，它们在信息形式和工作速度上具有很大的差异，接口正是为了解决这些差异而设置的。

![image-20230216143640806](E:/Development/Typora/images/image-20230216143640806.png)

####  7.3.1 I/O接口的功能

  I/O接口的主要功能如下：
（1）实现主机和外设的通信联络控制。 解决主机与外设时序配合问题，协调不同工作速度的外设和主机之间交换信息，以保证整个计算机系统能统一、协调地工作。
（2）进行地址译码和设备选择。 CPU送来选择外设的地址码后，接口必须对地址进行译码以产生设备选择信息，使主机能和指定外设交换信息。
（3）进行数据缓冲。 CPU与外设之间的速度往往不匹配，为消除速度差异，接口必须设置数据缓冲寄存器，用于数据的暂存，以避免因速度不一致而丢失数据
（4）信号格式的转换。 外设与主机两者的电平、数据格式都可能存在差异，接口应提供计算机与外设的信号格式的转换功能，如电平转换、并/串或串/并转换、模/数或数/模转换等
（5）传送控制命令和状态信息。 CPU要启动某一外设时，通过接口中的命令寄存器向外设发出启动命令；外设准备就绪时，则将“准备好”状态信息送回接口中的状态寄存器，并反馈给CPU。外设向CPU提出中断请求时，CPU也应有相应的响应信号反馈给外设。

1. **寻址**
2. **数据缓冲**
3. **数据格式变换、电平转换**
4. **控制逻辑：传送控制命令与状态信息，实现I/O传送控制方式**

####  7.3.2 I/O接口的基本结构

![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638936062691.png)

  I/O接口在主机侧通过I/O总线与内存、CPU相连。通过数据总线，在数据缓冲寄存器与内存或CPU的寄存器之间进行数据传送。同时接口和设备的状态信息被记录在状态寄存器中，通过数据线将状态信息送到CPU。CPU对外设的控制命令也通过数据线传送，一般将其送到I/O接口的控制寄存器。 状态寄存器和控制寄存器在传送方向上是相反的。
  接口中的地址线用于给出要访问的I/O接口中的寄存器的地址，它和读/写控制信号一起被送到I/O接口的控制逻辑部件， 其中地址信号用以选择和主机交换信息的寄存器，通过控制线传送来的读/写信号确认是读寄存器还是写寄存器，此外控制线还会传送一些仲裁信号和握手信号。
  接口中的I/O控制逻辑还要能对控制寄存器中的命令字进行译码，并将译码得到的控制信号通过外设界面控制逻辑送到外设，同时将数据缓冲寄存器的数据发送到外设或从外设接收数据到数据缓冲寄存器。 另外，它还要具有收集外设状态到状态寄存器的功能，
  对数据缓冲寄存器、状态/控制寄存器的访问操作是通过相应的指令来完成的，通常称这类指令为I/O指令， I/O指令只能在OS内核的底层I/O软件中使用，它们是一种特权指令。

------

  注意接口和端口是两个不同的概念。端口是指接口电路中可以进行读/写的寄存器，若干端口加上相应的控制逻辑才可以组成接口。

------

####  7.3.3 I/O接口的类型

   （1）按数据传送方式可分为**并行接口** （一字节或一个字的所有位同时传送）和**串行接口** （一位一位地传送），接口要完成数据格式的转换。

> 此处的数据传送方式指的是外设和接口一侧的传送方式，而`在主机和接口一侧，数据总是并行传送的`

​		（2）按主机访问I/O设备的控制方式可分为**程序查询接口**、**中断接口**和**DMA接口**等。

​		（3）按功能选择的灵活性可分为**可编程接口** 和**不可编程接口**

####  7.3.4 I/O端口及其编址

  I/O端口是指接口电路中可被CPU直接访问的寄存器，主要有数据端口、状态端口和控制端口， 若干端口加上相应的控制逻辑电路组成接口。通常，CPU能对数据端口执行读写操作，但对状态端口只能执行读操作，对控制端口只能执行写操作。
  I/O端口要想能够被CPU访问，就必须要对各个端口进行编号，每个端口对应一个端口地址。而对I/O端口的编址方式有与存储器统一编址和独立编址两种。

  **（1）统一编址，又称存储器映射方式**

  统一编址是指把I/O端口当做存储器的单元进行地址分配，这种方式CPU不需要设置专门的I/O指令，用统一的访存指令就可以访问I/O端口。

> - 优点：不需要专门的输入/输出指令，可使CPU访问I/O的操作更灵活、更方便，还可使端口有较大的编址空间。
> - 缺点:端口占用存储器地址，使内存容量变小，而且利用存储器编址的I/O设备进行数据输入/输出操作，执行速度较慢。

  **（2）独立编址，又称I/O映射方式**

  I/O端口的地址空间与主存地址空间是两个独立的地址空间，因而无法从地址码的形式上区分，需要设置专门的I/O指令来访问I/O端口。

> - 优点：输入/输出指令与存储器指令有明显区别，程序编制清晰，便于理解。
> - 缺点：输入/输出指令少，一般只能对端口进行传送操作，尤其需要CPU提供存储器读/写、I/O设备读/写两组控制信号，增加了控制的复杂性。

------

  I/O指令与通道指令的区别：
  I/O指令是CPU指令系统的一部分，是CPU用来控制输入/输出操作的指令，由CPU译码后执行。在具有通道结构的机器中，I/O指令不实现I/O数据传送，主要完成启、停I/O设备，查询通道和I/O设备的状态，及控制通道进行其他一些操作等。具有通道指令的计算机，一旦CPU执行了启动I/O设备的指令，就由通道来代替CPU对I/O设备的管理
  通道指令是通道本身的指令，用来执行I/O操作，如读、写、磁带走带及磁盘找道等操作。

------

------

  例题：下列选项中，在I/O总线的数据线上传输的信息包括（）
  1.I/O接口中的命令字  2.I/O接口中的状态字
  3.中断类型号

  答案：1,2，3；中断类型号是系统为每一个中断源分配的代号，中断类型号指出了中断向量存放的地址。外设需向CPU发出中断请求信号

  例题：磁盘驱动器向盘片磁道记录数据时采用（）方式写入
  A.并行  B.串行
  C.并行-串行  D.串行-并行

  答案：B；

------

### 7.4 I/O方式

  常用的I/O方式有**程序查询、程序中断、DMA和通道**等，其中前两种方式更依赖于CPU中程序指令的执行

####  7.4.1 程序查询方式

  信息交换的控制**完全由主机执行程序实现**。

​		 程序查询方式接口中设置`一个数据缓冲寄存器`（**数据端口**）和`一个设备状态寄存器`（**状态端口**）。主机进行I/O操作时，先发出询问信号，读取设备的状态并根据设备状态决定下一步操作是进行数据传送还是等待

- 对输入而言，准备就绪意味着接口电路中的数据缓冲寄存器已装满欲传送的数据，称为输入缓冲满，CPU即可取走数据；
- 对输出而言，准备就绪意味着接口电路中的数据已被设备取走，故称为输出缓冲空，这样CPU可再次将数据送到接口，设备可再次从接口接收数据

当I/O设备较多时，CPU需按各个I/O设备在系统中的优先级别进行**逐级查询**。

程序查询方式的工作流程如下：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638936062702.png)
  （1）CPU执行初始化程序，并预置传送参数
  （2）向I/O接口发出命令字，启动I/O设备
  （3）从外设接口读取其状态信息
  （4）CPU**不断**查询I/O设备状态，直到外设准备就绪
  （5）传送一次数据
  （6）修改地址和计数器参数
  （7）判断传送是否结束，若未结束转（3)，直到计数器为0

> 在这种控制方式下，CPU一旦启动I/O，就必须停止现行程序的运行，并在现行程序中插入一段程序。程序查询方式的主要特点是CPU有踏步等待现象，CPU和I/O串行工作。这种方式的接口设计简单、设备量少，但CPU在信息传送过程中要花费很多时间来查询和等待，而且在一段时间内只能和一台外设交换信息，效率大大降低。

####  7.4.2 程序中断方式

  CPU中通常设有处理中断的机构——中断系统，以解决各种中断的共性问题。

#####   1.中断的基本概念

  程序中断是指在计算机执行现行程序的过程中，出现某些急需处理的异常情况或特殊请求，CPU暂时中止现行程序，而转去对这些异常情况或特殊请求进行处理，在处理完毕后CPU又自动返回到现行程序的断点处，继续执行原程序。

  程序中断的作用如下：
  （1）实现CPU与I/O设备的并行工作
  （2）处理硬件故障和软件错误
  （3）实现人机交互，用户干预机器需要用到中断系统
  （4）实现多道程序、分时操作， 多道程序的切换需借助于中断系统
  （5）实时处理需要借助中断系统来实现快速响应
  （6）实现应用程序和OS（管态程序）的切换，称为软中断
  （7）多处理器系统中各处理器之间的信息交流和任务切换

> 程序中断方式的思想：CPU在程序中安排好于某个时刻启动某台外设，然后CPU继续执行原来的程序，不需要像查询方式那样一直等待外设准备就绪。一旦外设完成数据传送的准备工作，就主动向CPU发出中断请求，请求CPU为自己服务。在可以响应中断的条件下，CPU暂时中止正在执行的程序，转去执行中断服务程序为外设服务，在中断服务程序中完成一次主机与外设之间的数据传送，传送完成后，CPU返回原来的程序。

![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638936062703.png)

![image-20230216145057059](E:/Development/Typora/images/image-20230216145057059.png)

------

  程序中断和调用子程序的区别：

  两者的根本区别主要表现在**服务时间和服务对象**上不一样

  （1）调用子程序过程发生的时间是已知的和固定的，即在主程序中的调用指令（CALL）执行时发生主程序调用子程序过程，调用指令所在的位置是已知的和固定的。而中断过程发生的时间一般是随机的，CPU在执行某个主程序时收到中断源提出的中断申请，就发生中断过程，而中断申请一般由硬件电路产生，申请提出时间是随机的。也可以说，调用子程序是程序设计者事先安排的，而执行中断服务程序是由系统工作环境随机决定的。
  （2）子程序完全为主程序服务，两者属于主从关系。主程序需要子程序时就去调用子程序，并把调用结果带回主程序继续执行。而中断服务程序与主程序二者一般是无关的，不存在谁为谁服务的问题，两者是平行关系
  （3）主程序调用子程序的过程完全属于软件处理过程，不需要专门的硬件电路；而中断处理系统是一个软/硬件结合的系统，需要专门的硬件电路才能完成中断处理的过程。
  （4）子程序嵌套可实现若干级，嵌套的最多级数受计算机内存开辟的堆栈大小限制；而中断嵌套级数主要由中断优先级来决定，一般优先级数不会很大。

  从宏观上来看，虽然程序中断方式克服了程序查询方式中的CPU踏步现象，实现了CPU与I/O并行工作，提高了CPU的资源利用率，但从微观操作分析，CPU在处理中断服务程序时，仍需暂停原程序的正常运行，尤其是当高速I/O设备或辅助存储器频繁地、成批的与主存交换信息时，需要不断打断CPU执行现行程序，而执行中断服务程序。

------

#####   2.程序中断方式工作流程

  一次中断处理过程可分为5个阶段：==中断请求、中断判优、中断响应、中断服务、中断返回==。

![image-20230216145708684](E:/Development/Typora/images/image-20230216145708684.png)

  （1）`中断请求`

  中断请求是指==中断源==向CPU发送中断请求信号
  *a.内中断和外中断*
  中断源是请求CPU中断的设备或事件，一台计算机允许有多个中断源。根据中断源的类别，可把中断源分为**内中断** 和 **外中断**两种。
  每个中断源向CPU发出中断请求的时间是随机的。为记录中断事件并区分不同的中断源，中断系统需对每个中断源设置中断请求标记触发器INTR，当其状态为1时，表示中断源有请求。这些触发器可组成中断请求标记寄存器，该寄存器可集中在CPU中，也可分散在各个中断源中。
  外中断是指来自处理器和内存以外的部件引起的中断，包括I/O设备发出的I/O中断、外部信号中断（如用户按Esc键），以及各种定时器引起的时钟中断等。

>  **外中断在狭义上一般称为中断**。
>
> 软件中断或异常中断通常称为异常(Exception

  内中断主要是指在处理器和内存内部产生的中断，包括程序运算引起的各种错误，如地址非法、校验错、页面失效、存取访问控制错、算术操作溢出、数据格式非法、除数为零、非法指令、用户程序执行特权指令、分时系统中的时间片中断及用户态到核心态的切换等。

  *b.硬件中断和软件中断*
  硬件中断：通过外部的硬件产生的中断。**硬件中断属于外中断**。
  软件中断：通过某条指令产生的中断，这种中断是可以编程实现的。**软件中断是内中断**。

  *c.非屏蔽中断和可屏蔽中断*
  非屏蔽中断：非屏蔽中断是一种硬件中断，此种中断通过不可屏蔽中断请求NMI控制，不受中断标志位IF的影响，即使在关中断 （IF = 0）的情况下也会被响应。
  可屏蔽中断：可屏蔽中断也是一种硬件中断，此种中断通过中断请求标记触发器INTR控制，且受中断标志位IF的影响，在关中断情况下不接受中断请求。
  可屏蔽中断和非屏蔽中断均是外中断。

  （2）`中断判优`
  中断系统在任一瞬间只能响应一个中断源的请求。由于许多中断源提出中断请求的时间都是随机的，因此当多个中断源同时提出请求时，需通过中断判优逻辑确定响应哪个中断源的请求。例如故障中断的优先级别较高，然后是I/O中断。
  中断判优**既可以用硬件实现，又可用软件实现**。硬件实现是通过==硬件排队器==实现的，它既可以设置在CPU中，又可以分散在各个中断源中，软件实现是**通过查询程序实现的**。

>  一般来说，硬件故障中断属于最高级，其次是软件中断，非屏蔽中断优于可屏蔽中断，DMA请求优于I/O设备传送的中断请求，高速设备优于低速设备，输入设备优于输出设备，实时设备优于普通设备等。

  （3）`CPU响应中断的条件`
  CPU响应中断必须满足以下3个条件：
  a.中断源有中断请求
  b.CPU允许中断且开中断
  c.一条指令执行完毕，且没有更紧迫的任务

------

  I/O设备的就绪时间是随机的，而CPU在统一的时刻即每条指令执行阶段结束前向接口发出中断查询信号，以获取I/O的中断请求，即CPU响应中断的时间是在每条指令执行阶段的结束时刻。 这里说的中断仅指外中断，内中断不属于此类情况。

------

  （4）`中断隐指令`
  CPU响应中断后，经过**某些操作**，转去执行中断服务程序。**这些操作**是由硬件直接实现的，称为==中断隐指令==。 中断隐指令并不是指令系统中的一条真正的指令， 它没有操作码，所以中断隐指令是一种不允许也不可能为用户使用的特殊指令。它所完成的操作如下：
  a.`关中断`
  在中断服务程序中，为了保护中断现场（即CPU主要寄存器中的内容）期间不被新的中断所打断，必须关中断，从而保证被中断的程序在中断服务程序执行完毕后能接着正确地执行。
  b.`保存断点`
  为保证在中断服务程序执行完毕后能正确地返回到原来的程序，必须将原来程序的断点（即PC的内容）保存起来
  c.`引出中断服务程序`
  引出中断服务程序的实质是，取出中断服务程序的入口地址并传送给PC。

  （5）`中断向量`
  不同的设备有不同的中断服务程序，每个中断服务程序都有一个入口地址，CPU必须找到这个入口地址，即中断向量，把系统中的全部中断向量集中存放到存储器的某个区域内，这个存放中断向量的存储区就称为中断向量表，即中断服务程序的入口地址表。
  CPU响应中断后，中断硬件会自动将中断向量地址传送到CPU，由CPU实现程序的切换，这种方法称为中断向量法，采用中断向量法的中断称为向量中断。

------

>   中断向量是中断服务程序的入口地址，中断向量地址是指中断服务程序的入口地址的地址。

  向量中断、中断向量、向量地址：
  **中断向量**：每个中断源都有对应的处理程序，这个处理程序称为中断服务程序，其入口地址称为中断向量。所有中断的中断服务程序入口地址构成一个表，称为中断向量表；也有的机器把中断服务程序入口的跳转指令构成一张表，称为中断向量跳转表
  **向量地址**：中断向量表或中断向量跳转表中每个表项所在的内存地址或表项的索引值，称为向量地址或中断类型号。
  **向量中断**：指一种识别中断源的技术或方式。识别中断源的目的是找到中断源对应的中断服务程序的入口地址的地址，即获得向量地址。

------

  （6）`中断处理过程`
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638936062704.png)

  a.**关中断**
  处理器响应中断后，首先要保护程序的现场状态，**在保护现场的过程中，CPU不应响应`更高级`中断的请求。**否则，若现场保存不完整，在中断服务程序结束后，也就不能正确地恢复并继续执行现行程序。

  b.**保存断点**
  为保证中断服务程序执行完毕后，能正确地返回到原来的程序，必须将原来的程序的断点保存起来。断点可以压入堆栈，也可以存入主存的特定单元中。
  c.**引出中断服务程序**
  引出中断服务程序的实质是，取出中断服务程序的入口地址送入PC
  通常有两种方法寻址中断服务程序的入口地址：硬件向量法和软件查询法。
  硬件向量法通过硬件产生中断向量地址，再由中断向量地址找到中断服务程序的入口地址。软件查询法用软件编程的办法寻找入口地址。

------

  硬件产生的实际上是中断类型号，而中断类型号指出了中断向量存放的地址，因此能产生中断向量地址。

------

  d**保存现场和屏蔽字**
  进入中断服务程序后首先要保存现场，现场信息一般是指程序状态字、中断屏蔽寄存器和CPU中某些寄存器的内容

  e.**开中断**
  允许更高级中断请求得到响应，实现中断嵌套

  f.**执行中断服务程序**
  这是中断请求的目的

  g.**关中断**
  保证在恢复现场和屏蔽字时不被中断

  h.**恢复现场和屏蔽字**
  将现场和屏蔽字恢复到原来的状态

  i.**开中断、中断返回**
  中断服务程序的最后一条指令通常是一条中断返回指令，使其返回到原程序的断点处，以便继续执行原程

> 其中，a,b,c在CPU进入中断周期后，由中断隐指令（硬件自动）完成；
>
> 其余由中断服务程序完成，中断服务程序的流程分为四大部分：保护现场、中断服务、恢复现场、中断返回

------

  恢复现场是指在中断返回前，必须将寄存器的内容恢复到中断处理前的状态，这部分工作由中断服务程序完成。中断返回由中断服务程序的最后一条中断返回指令完成。

------

#####   3.多重中断和中断屏蔽技术

  若CPU在执行中断服务程序的过程中，又出现了新的更高优先级的中断请求，而CPU对新的中断请求不予响应，则这种中断称为单重中断。 若CPU暂停现行的中断服务程序，转去处理新的中断请求，则这种中断称为多重中断，又称中断嵌套。
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638936062705.png)
  中断屏蔽技术主要用于多重中断。CPU要具备多重中断的功能，必须满足下列条件
  （1）在中断服务程序中提前设置开中断指令
  （2)优先级别高的中断源有权中断优先级别低的中断源
  每个中断源都有一个屏蔽触发器，1表示屏蔽该中断源的请求，0表示可以正常申请，所有屏蔽触发器组合在一起便构成一个屏蔽字寄存器，屏蔽字寄存器的内容称为屏蔽字。

  例：设某机有4个中断源A、B、C、D，其硬件排队优先次序为A>B>C>D，现要求将中断处理次序改为D>A>C>B
  （1）写出每个中断源对应的屏蔽字
  （2）按图所示的时间轴给出的4个中断源的请求时刻，画出CPU执行程序的轨迹。设每个中断源的中断服务程序时间均为20μs
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638936062706.png)
  答案：（1）D具有最高优先级，可以屏蔽其他所有中断，且不能中断自身，因此D对应的屏蔽字为1111；A只能被D中断，因此A对应的屏蔽字为1110，以此类推
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638936062707.png)

  （2）![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638936062708.png)

------

  中断响应优先级与中断处理优先级：
  中断响应优先级是由硬件排队线路或中断查询程序的查询顺序决定的，不可动态地改变；而中断处理优先级可以由中断屏蔽字来改变， 反映的是正在处理的中断是否比新发生的中断的处理优先级低（屏蔽位为0，对新中断开放），若是，则中止正在处理的中断，转到新中断去处理，处理完后再回到刚才被中止的中断继续处理。

------

####  7.4.3 DMA方式

  DMA方式是一种**完全由硬件**进行成组信息传送的控制方式，它具有程序中断方式的特点，即在数据准备阶段，CPU与外设并行工作。DMA方式在外设和内存之间开辟一条直接数据通道，信息传送不再经过CPU，降低了CPU在传送数据时的开销，因此称为**直接存储器存取方式**。 由于数据传送不经过CPU，也就不需要保护、恢复CPU现场等烦琐的操作。
  这种方式适用于磁盘机、磁带机等高速设备大批量数据的传送，它的硬件开销比较大。在DMA方式中，中断的作用仅限于故障和正常传送结束时的处理。

#####   1.DMA方式的特点

  主存和DMA接口之间有一条直接数据通路。由于DMA方式传送数据不需经过CPU，因此不必中断现行程序，I/O与主机并行工作，程序和传送并行工作。
  DMA方式具有以下特点：
  （1）它使主存与CPU的固定联系脱钩，主存既可被CPU访问，又可被外设访问。
  （2）在数据块传送时，主存地址的确定、传送数据的计数等都由硬件电路直接实现。
  （3）主存中要开辟专用缓冲区，及时供给和接收外设的数据。
  （4）DMA传送速度快，CPU和外设并行工作，提高了系统效率。
  （5）DMA在传送开始前要通过程序进行预处理，结束后要通过中断方式进行后处理。

#####   2.DMA控制器的组成

  在DMA方式中，对数据传送过程进行控制的硬件称为DMA控制器（DMA接口）。 当I/O设备需要进行数据传送时，通过DMA控制器向CPU提出DMA传送请求，CPU响应之后将让出系统总线，由DMA控制器接管总线进行数据传送。 其主要功能如下：
  （1）接受外设发出的DMA请求，并向CPU发出总线请求
  （2）CPU响应此总线请求，发出总线响应信号，接管总线控制权，进入DMA操作周期
  （3）确定传送数据的主存单元地址及长度，并自动修改主存地址计数和传送长度计数
  （4）规定数据在主存和外设间的传送方向，发出读写等控制信号，执行数据传送操作
  （5）向CPU报告DMA操作的结束

  下图给出了一个简单的DMA控制器
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638936062709.png)

- 主存地址计数器（主存地址寄存器AR）：存放要交换数据的主存地址
- 传送长度计数器（字计数器WC）：记录传送数据的长度，计数溢出时，数据即传送完毕，自动发中断请求信号。
- 数据缓冲寄存器BR：暂存每次传送的数据
- DMA请求触发器：每当I/O设备准备好数据后，给出一个控制信号，使DMA请求触发器置位。
- 控制/状态逻辑：由控制和时序电路及状态标志组成，用于指定传送方向，修改传送参数，并对DMA请求信号和CPU响应信号进行协调和同步。
- 中断机构：当一个数据块传送完毕后触发中断机构，向CPU提出中断请求。

  在DMA传送过程中，DMA控制器将接管CPU的地址总线、数据总线和控制总线， CPU的主存控制信号被禁止使用。 而当DMA传送结束后，将恢复CPU的一切权利并开始执行其操作。由此可见，DMA控制器必须具有控制系统总线的能力。

#####   3.DMA的传送方式

  主存和DMA控制器之间有一条数据通路，由此主存和I/O设备之间交换信息时，不通过CPU。但当I/O设备和CPU同时访问主存时，可能发生冲突，为了有效地使用主存，DMA控制器与CPU通常采用以下3种方式使用主存：
  （1）停止CPU访问主存：
  这种方式是当外设需要传送成组数据时，由DMA接口向CPU发送一个信号，要求CPU放弃地址线、数据线和有关控制线的使用权，DMA接口获得总线控制权后，开始进行数据传送。数据传送结束后，DMA接口通知CPU可以使用主存，并把总线控制权交还给CPU。在这种传送过程中，CPU基本处于不工作状态或保持原始状态。

  （2）DMA与CPU交替访存：
  这种方式适用于CPU的工作周期比主存存取周期长的情况。 例如，若CPU的工作周期是1.2μs，主存的存取周期小于0.6μs，则可将一个CPU周期分为C1和C2两个周期，其中C1专供DMA访存，C2专供CPU访存。这种方式不需要总线使用权的申请、建立和归还过程，总线使用权是通过C1和C2分时控制的。

  （3）周期挪用（或周期窃取）
  这种方式是前两种方式的折中。当I/O设备没有DMA请求时，CPU按程序的要求访问主存，一旦I/O设备有了DMA请求，就会遇到3种情况：a.此时CPU不在访存（如CPU正在执行乘法指令），因此I/O的访存请求与CPU未发生冲突；b.CPU正在访存，此时必须待存取周期结束后，CPU再将总线占有权让出；c.I/O和CPU同时请求访存，出现访存冲突，此时CPU要暂时放弃总线占有权，由I/O设备挪用一个或几个存取周期。

#####   4.DMA的传送过程

  DMA的数据传送过程分为预处理、数据传送和后处理3个阶段
  （1）预处理
  由CPU完成一些必要的准备工作。 首先，CPU执行几条I/O指令，用以测试I/O设备状态，向DMA控制器的有关寄存器置初值、设置传送方向、启动该设备等。然后，CPU继续执行原来的程序，直到I/O设备准备好发送的数据（输入情况）或接收的数据（输出情况）时，I/O设备向DMA控制器发送DMA请求，再由DMA控制器向CPU发送总线请求（有时将这两个过程统称为DMA请求），用以传输数据。
  （2）数据传送
  DMA的数据传输可以以单字节（或字）为基本单位，也可以以数据块为基本单位。 对于以数据块为单位的传送（如硬盘），DMA占用总线后的数据输入和输出操作都是通过循环来实现的。这一循环也是由DMA控制器（而非通过CPU执行程序）实现的，即数据传送阶段完全由DMA（硬件）控制
  （3）后处理
  DMA控制器向CPU发送中断请求，CPU执行中断服务程序做DMA结束处理，包括校验送入主存的数据是否正确、测试传送过程中是否出错（错误则转入诊断程序）及决定是否继续使用DMA传送其他数据块等。

![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389360627110.png)

#####   5.DMA方式和中断方式的区别

  （1）中断方式是程序的切换，需要保护和恢复现场；而DMA方式除了预处理和后处理，其他时候不占用CPU的任何资源
  （2）对中断请求的响应只能发生在每条指令执行完毕时（即指令的执行周期后）；而对DMA请求的响应可以发生在每个机器周期结束时（在取指周期、间址周期、执行周期后均可），只要CPU不占用总线就可被响应。
  （3）中断传送过程需要CPU的干预；而DMA传送过程不需要CPU的干预，因此数据传输率非常高，适合于高速外设的成组数据传送
  （4）DMA请求的优先级高于中断请求
  （5）中断方式具有对异常事件的处理能力，而DMA方式仅局限于传送数据块的I/O操作
  （6）从数据传送来看，中断方式靠程序传送，DMA方式靠硬件传送

------

  例题：![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389360627111.png)
  答案：D；屏蔽自身和L3

  例题：若某设备中断请求的响应和处理时间为100ns,每400ns发出一次中断请求，中断响应所允许的最长延迟时间为50ns，则在该设备持续工作过程中，CPU用于该设备的I/O时间占整个CPU时间的百分比至少是（）
  答案：25%；每400ns发出一次中断请求，而响应和处理时间为100ns，其中容许的延迟为题目干扰信息，因为在50ns内，无论怎么延迟，每400ns仍要花费100ns处理中断

  例题：当有中断源发出请求时，CPU可执行相应的中断服务程序，可以提出中断的有
  1.外部事件  2.Cache  3.浮点数运算下溢  4.浮点数运算上溢

  答案：1,4;Cache属于存储设备，不能提出中断，缺页中断是由CPU的内存管理单元发出的；浮点数运算下溢可当做机器零处理，不需要中断来处理。

  例题：中断响应由高到低的优先次序宜用（）
  A.访管——>程序性——>机器故障  B.访管——>程序性——>重新启动
  C.外部——>访管——>程序性  D.程序性——>I/O——>访管

  答案：B；重新启动应当等待其他任务完成后再进行，优先级最低。 访管指令优先级要高于外部中断。 IBM370中机器校验安排为第一级，程序性和管理程序调用为第二级，外部为第三级，I/O为第四级，重新启动为最低级（紧急机器校验>管理程序调用>程序性中断>外部中断>I/O中断>重新启动）

  例题：主存故障引起的中断是
  A.I/O中断  B.程序性中断
  C.机器校验中断  D.外中断

  答案：C；主存故障引起的中断是机器校验中断，属于内中断，而外中断一般指主存和CPU外的中断，如外设引起的中断等。

  例题：在配有通道的计算机系统中，用户程序需要输入/输出时，引起的中断是
  A.访管中断  B.I/O中断
  C.程序性中断  D.外中断

  答案：A；用户程序需要输入/输出时，需要调用OS提供的接口（请求OS服务），此时会引起访管中断，系统由用户态转为核心态

  例题：在中断响应周期中，CPU主要完成的工作是（）
  A.关中断，保护断点，发中断响应信号并形成向量地址
  B.开中断，保护断点，发中断响应信号并形成向量地址
  C.关中断，执行中断服务程序
  D.开中断，执行中断服务程序

  答案：A；中断隐指令由CPU在中断响应周期自动完成。 在中断响应周期，CPU主要完成关中断、保护断点、发中断响应信号并形成中断向量地址的工作，即执行中断隐指令。

  例题：在中断周期中，由（）将允许中断触发器置0
  A.关中断指令  B.中断隐指令
  C.开中断指令  D.中断服务程序

  答案：在中断周期中，允许中断触发器置0是由中断隐指令完成的，为硬件关中断。在中断周期中需完成的操作即为中断隐指令的过程。

  例题：设置中断屏蔽标志可以改变
  A.多个中断源的中断请求优先级
  B.CPU对多个中断请求响应的优先次序
  C.多个中断服务程序开始执行的顺序
  D.多个中断服务程序执行完的次序

  答案：D；优先级包含响应优先级和处理优先级。响应优先级是指CPU响应各中断源请求的优先次序（即题中的中断请求优先级），这种次序往往是硬件线路已设置好的，不便于改动。处理优先级是指CPU实际对各中断源请求的处理优先次序。采用了屏蔽技术后，可以改变CPU处理各中断源的优先等级，从而改变CPU执行程序的轨迹。 中断屏蔽字的一种作用是实现中断升级，即改变中断处理的次序（注意区分中断响应次序和中断处理次序，中断响应次序是由硬件排队电路决定），因此其可以改变多个中断服务程序执行完的次序

  例题：在主机和外设的信息传送中，（）不是一种程序控制方式
  A.直接程序传送  B.程序中断
  C.直接存储器存取（DMA）  D.通道控制

  答案：C；

  例题：在采用中断I/O方式控制打印输出的情况下，CPU和打印控制接口中的I/O端口之间交换的信息不可能是
  A.打印字符  B.主存地址
  C.设备状态  D.控制命令

  答案：B；在程序中断I/O方式中，CPU和打印机直接交换，打印字符直接传输到打印机的I/O端口，不会涉及主存地址。而CPU和打印机通过I/O端口中的状态口和控制口来实现交互

  例题：下列关于外部I/O中断的叙述中，正确的是（）
  A.中断控制器按所接收中断请求的先后次序进行中断优先级排队
  B.CPU响应中断时，通过执行中断隐指令完成通用寄存器的保护
  C.CPU只有在处于中断允许状态时，才能响应外部设备的中断请求
  D.有中断请求时，CPU立即暂停当前指令执行，转去执行中断服务程序

  答案：C；

  例题：在DMA方式下，主存和I/O设备之间有一条物理通路相连吗

  答案：没有。通常所说的DMA方式在主存和I/O设备之间建立一条“直接的数据通路”，使得数据在主存和I/O设备之间直接进行传送，其含义并不是在主存和I/O之间建立一条物理直接通路，而是主存和I/O设备通过I/O设备接口、系统总线及总线桥接部件等相连，建立一个信息可以相互通达的通路，这在逻辑上可视为直接相连的。 其“直接”是相对于要通过CPU才能和主存相连这种方式而言的

  例题：（1）一个完整的指令周期包含哪些CPU工作周期
  （2）中断周期前和中断周期后各是CPU的什么工作周期
  （3）DMA周期前和DMA周期后各是CPU的什么工作周期

  答案：（1）取指周期、间址周期、执行周期、中断周期
  （2）执行周期；下一条指令的取指周期；
  （3）可以是取指、间址、执行或中断周期；即DMA周期前后都是机器周期

  例题：假定某I/O设备向CPU传送信息的最高频率为4万次/s，而相应中断处理程序的执行时间为40μs，则该I/O设备是否可采用中断方式工作？为什么？

  答案：否；I/O设备传送一个数据的时间为25μs，所以请求中断的周期为25μs，而中断处理程序的执行时间为40μs，大于请求中断的周期，会丢失数据

  例题：在程序查询方式的输入/输出系统中，假设不考虑处理时间，每个查询操作需要100个时钟周期，CPU的时钟频率为50MHz。现有鼠标和硬盘两个设备，而且CPU必须每秒对鼠标进行30次查询，硬盘以32位字长为单位传输数据，即每32位被CPU查询一次，传输率为2x220B/s。求CPU对这两个设备查询所花费的时间比率，由此可得出什么结论

  答案：（1）鼠标：0.006%；可见对鼠标的查询基本不影响CPU的性能（2）硬盘：105%；可见即使CPU将全部时间都用于对硬盘的查询，也不能满足磁盘传输的要求，由此CPU一般不采用程序查询方式与磁盘交换信息。

  例题:假定某计算机的CPU主频为80MHz，CPI为4，平均每条指令访存1.5次，主存与Cache之间交换的块大小为16B，Cache的命中率为99%，存储器总线宽带为32位。
  （1）该计算机的MIPS是多少？平均每秒Cache缺失的次数是多少？在不考虑DMA传送的情况下，主存带宽至少达到多少才能满足CPU的访存要求？
  （2）假定在Cache缺失的情况下访问主存时，存在0.0005%的缺页率，则CPU平均每秒产生多少次缺页异常？若页面大小为4KB，每次缺页都需要访问磁盘，访问磁盘时DMA传送采用周期挪用方式，磁盘I/O接口的数据缓冲寄存器为32位，则磁盘I/O接口平均每秒发出的DMA请求次数至少是多少？
  （3）CPU和DMA控制器同时要求使用存储器总线时，哪个优先级最高？为什么？
  （4）为了提高性能，主存采用4体低位交叉存储模式，工作时每1/4个存储周期启动一个体。若每个体的存储周期为50ns，则该主存能提供的最大带宽是多少？

  答案：（1）20；300k;4.8MB/s；（2）1.5；1536；（3）DMA；因为DMA请求若得不到及时响应，I/O传输数据可能会丢失；
  （4）320MB/s

  例题：![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389360627112.png)
  答案：（1）包含1位起始位，10；2000；
  （2)一个字符传送时间包括：设备D将字符送I/O端口的时间、中断响应时间和中断服务程序前15条指令的执行时间；25070000个CLOCK；90000；在中断响应阶段，CPU主要进行以下操作：关中断、保护断点和程序状态、识别中断源

  例题：![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389360627113.png)
  答案：（1）3——>1——>4——>2
  （2）![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389360627114.png)

  例题：一个DMA接口可采用周期窃取方式把字符传送到存储器，它支持的最大批量为400B。若存取周期为0.2μs，每处理一次中断需5μs，现有的字符设备的传输率为9600b/s。假设字符之间的传输是无间隙的，试问DMA方式每秒因数据传输占用处理器多少时间？若完全采用中断方式，又需占处理器多少时间（忽略预处理所需时间）

  答案：（1）255μs；传输1200个字符共需1200个存取周期
  （2）5 x 1200=6000μs;采用中断方式不访问主存

  假定计算机的主频为500MHz，CPI为4。现有设备A和B，其数据传输率分别为2MB/s和40MB/s，对应I/O接口中各有一个32位数据缓冲寄存器。
  （1）若设备A采用定时查询I/O方式，每次输入/输出都至少执行10条指令。设备A最多间隔多长时间查询一次才能不丢失数据？CPU用于设备A输入/输出的时间占CPU总时间的百分比至少是多少？
  （2）在中断I/O方式下，若每次中断响应和中断处理的总时钟周期数至少为400，则设备B能否采用中断I/O方式？为什么？
  （3）若设备B采用DMA方式，每次DMA传送的数据块大小为1000B，CPU用于DMA预处理和后处理的总时钟周期数为500，则CPU用于设备B输入/输出的时间占CPU总时间的百分比最多是多少

  答案：（1）程序定时向缓存端口查询数据，必须在传输完端口大小的数据时访问端口，以防止部分数据未被及时读取而丢失。设备A准备32位数据所用的时间为2μs，所以最多每隔2μs必须查询一次；4%
  （2）否，准备数据的时间小于中断响应和中断处理的时间，数据会被刷新，造成丢失
  （3）4%## 用来连接主存、网卡、视频卡等





