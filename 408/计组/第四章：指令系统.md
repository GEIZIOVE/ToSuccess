## 4.指令系统

### 4.1 指令格式

  `指令`（又称机器指令）是指示计算机执行某种操作的命令，是计算机运行的最小功能单位。**一台计算机的所有指令的集合构成该机的指令系统，也称指令集**。 指令系统是计算机的主要属性，位于硬件和软件的交界面上。

####  4.1.1 指令的基本格式

  一条指令就是机器语言的一个语句，它是一组有意义的[二进制](https://so.csdn.net/so/search?q=二进制&spm=1001.2101.3001.7020)代码。一条指令通常包括`操作码字段和地址码`字段两部分：
![在这里插入图片描述](E:\Development\Typora\images\20200820210026453.png)
  

- **操作码指出指令中该指令应该执行什么性质的操作和具有何种功能**。

  - 操作码是识别指令、了解指令功能及区分操作数地址内容的组成和使用方法等的关键信息。
  - 例如，指出是**算术加运算**还是**算术减运算**，是**程序转移**还是**返回操作**。

- **地址码给出被操作的信息（指令或数据）的地址**

  - （这里的“地址”可以是主存地址，也可以是寄存器的地址，甚至可以是I/O设备的地址)，包括参加运算的一个或多个操作数所在的地址、运算结果的保存地址、程序的转移地址、被调用的子程序的入口地址等。

- **指令的长度是指一条指令中所包含的二进制代码的位数**。

  - 指令字长取决于操作码的长度、操作数地址码的长度和操作数地址的个数。指令长度与机器字长没有固定的关系，它可以等于机器字长，也可以大于或小于机器字长。
  -  通常，**把指令长度等于机器字长的指令称为单字长指令，指令长度等于半个机器字长的指令称为半字长指令，指令长度等于两个机器字长的指令称为双字长指令**。

- 在一个指令系统中，若所有指令的长度都是相等的，则称为`定长指令字结构`。若各种指令的长度随指令功能而异，则称为`变长指令字结构`。 因为主存一般是按字节编址的，所以指令字长多为字节的整数倍。

  

  ![image-20220930083954685](E:/Development/Typora/images/image-20220930083954685.png)

  ​	`显地址`：如果在指令代码中明显地给出地址，如在指令中写明主存储器单元地址或者寄存器号，则这种地址称为显地址。
  
  ​	隐地址：如果地址是以隐含方式约定的，指令中并不出现该地址，则称为隐地址。如事先约定操作数是在某个寄存器中等
  
  一条指令中给出几个显地址，就称为几地址指令
  
  
  
  根据指令中操作数地址码的数目的不同，可将指令分成以下几种格式：

#####   1.零地址指令

![在这里插入图片描述](E:\Development\Typora\images\20200820211452346.png)
  **只给出操作码OP，没有显式地址。**这种指令有两种可能：
  （1）不需要操作数的指令，如空操作指令、停机指令、关中断指令等
  （2)**零地址的运算类指令仅用在堆栈计算机中**。通常参与运算的两个操作数隐含地从栈顶和次栈顶弹出，送到运算器进行运算，运算结果再隐含地压入堆栈。

#####   2.一地址指令

![在这里插入图片描述](E:\Development\Typora\images\20200820211843139.png)
  根据操作码的含义不同，有两种常见形态：
  （1）只有目的操作数的单操作数指令，<u>按A1地址读取操作数，进行OP操作后</u>，**结果存回原地址**。指令含义：`OP（A1）——>A1`；
  **如操作码含义是加1、减1、求反、求补等**
  （2）隐含约定目的地址的双操作数指令，按指令地址A1可读取源操作数，指令可隐含约定另一个操作数由**ACC**提供，运算结果也将存放在ACC中。指令含义：（ACC）OP（A1)——>ACC；
  若指令字长为32位，操作码占8位，1个地址码字段占24位，则指令操作数的直接寻址范围为2^24=16M；

#####   3.二地址指令

![在这里插入图片描述](E:\Development\Typora\images\20200820212636437.png)

  指令含义：`（A1）OP（A2）——>A1`；
  对于常用的算术和逻辑运算指令，往往要求使用两个操作数，需分别给出目的操作数和源操作数的地址，其中**目的操作数地址还用于保存本次的运算结果**。
  若指令字长为32位，操作码占8位，两个地址码字段各占12位，则指令操作数的直接寻址范围为2^12=4K

#####   4.三地址指令

![在这里插入图片描述](E:\Development\Typora\images\20200820213105887.png)

  指令含义：`（A1）OP（A2）——>A3`

​		(PC)+n->PC(隐含)

  若指令字长为32位，操作码占8位，3个地址码字段各占8位，则指令操作数的直接寻址范围为2^8=256。若地址字段均为主存地址，则完成一条三地址需要4次访问存储器（取指令1次，取两个操作数2次，存放结果1次）

#####   5.四地址指令

![在这里插入图片描述](E:\Development\Typora\images\20200820213514710.png)
  指令含义：`（A1）OP（A2)——>A3，A4=下一条将要执行指令的地址`

​			（A4）→PC

  若指令字长为32位，操作码占8位，4个地址码字段各占6位，则指令操作数的直接寻址范围为$2^6$=64

##### 总结：

1.显地址数多，指令长，所需存储空间大，读取时间长

2.显地址数少，地址选择受限制



####  4.1.2 定长操作码指令格式

  定长操作码指令**在指令字的最高位部分分配固定的若干位（定长）表示操作码。**

​			一般n位操作码字段的指令系统最大能够表示$2^n条$指令。

####  4.1.3 扩展操作码指令格式

  为了在指令字长有限的前提下仍保持比较丰富的指令种类，可采取可变长度操作码，即**全部指令的操作码字段的尾数不固定，且分散地放在指令字的不同位置上**。
  最常见的变长操作码方法是`扩展操作码`，它**使操作码的长度随地址码的减少而增加**，不同地址数的指令可具有不同长度的操作码， 从而在满足需要的前提下，有效地缩短指令字长。下图为一种扩展操作码的安排方式：
  在图中，指令字长为16位，其中4位为基本操作码字段OP，另有3个4位长的地址字段A1、A2、A3。图中所示的三地址指令为15条，1111留作扩展操作码之用；二地址指令15条，1111 1111留作扩展操作码之用；一地址指令为15条，1111 1111 1111留作扩展操作码之用；零地址指令为16条。
  除这种安排外，还有其他多种扩展方法，如形成15条三地址指令、12条二地址指令、63（3x16+15）条一地址指令和16条零地址指令。
  在设计扩展操作码指令格式时，须注意：
  （1）不允许短码是长码的前缀，即短操作码不能与长操作码的前面部分的代码相同
  （2)各指令的操作码不能重复
  通常情况下，对使用频率较高的指令分配较短的操作码，对使用频率较低的指令分配较长的操作码。

------

  例题：一个计算机系统采用32位单字长指令，地址码为12位，若定义了250条二地址指令，则还可以有（）条单地址指令

  答案：24K；

  例题：一处理器中共有32个寄存器，使用16位立即数，其指令系统结构中共有142条指令。在某个给定的程序中，20%的指令带有一个输入寄存器和一个输出寄存器；30%的指令带有两个输入寄存器和一个输出寄存器；25%的指令带有一个输入寄存器、一个输出寄存器、一个立即数寄存器；其余25%的指令带有一个立即数输入寄存器和一个输出寄存器。
  （1）对于以上4种指令类型中的任意一种指令类型来说，共需多少位？假定指令系统结构要求所有指令长度必须是8的整数倍
  （2）与使用定长指令集编码相比，当采用变长指令集编码时，该程序能够少占用多少存储器空间？

  答案：（1）由于有142条指令，因此至少需要8位才能确定各条指令的操作码。20%的一个输入寄存器和一个输出寄存器指令需要18位，对齐到24位；30%的两个输入寄存器和一个输出寄存器需要23位，对齐到24位；25%的一个输入寄存器、一个输出寄存器、一个立即数寄存器指令需要34位，对齐到40位；25%的一个立即数输入寄存器和一个输出寄存器需要29位，对齐到32位；
  （2）由于变长指令最长的长度为40位，所以定长指令编码每条指令的长度均为40位。而采用变长编码，平均长度为30位。能少占用25%的存储空间。

  例题：假设指令字长为16位，操作数的地址码为6位，指令有零地址、一地址、二地址三种格式。
  （1）设操作码固定，若零地址指令有M种，一地址指令有N种，则二地址指令最多有几种
  （2）采用扩展操作码技术，二地址指令最多有几种
  （3）采用扩展操作码技术，若二地址指令有P条，零地址指令有Q条，则一地址指令最多有几种

  答案：（1）16-M-N；（2）15种；（3）（16-P）x 2^6-Q x 2 ^(-6);二地址指令操作码每减少一个，可多构成2 ^6条一地址指令操作码；一地址指令操作码每减少一个，可多构成2 ^6条零地址指令操作码；

  例题：在一个36位长的指令系统中，设计一个扩展操作码，使之能表示下列指令：
  （1）7条具有两个15位地址和一个3位地址的指令
  （2）500条具有一个15位地址和一个3位地址的指令
  （3）50条无地址指令

  答案：![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638934506541.png)
  例题：某模型机共有64种操作码，位数固定，且具有以下特点：
  （1）采用一地址或二地址格式
  （2）有寄存器寻址、直接寻址和相对寻址（位移量为-128~+127）3种寻址方式
  （3）有16个通用寄存器，算术运算和逻辑运算的操作数均在寄存器中，结果也在寄存器中
  （4）取数/存数指令在通用寄存器和存储器之间传送数据
  （5)存储器容量为1MB，按字节编址
  要求设计算术逻辑指令，取数/存数指令和相对转移指令的格式，并简述理由

  答案：应有寻址特征位；
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638934506542.png)
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638934506543.png)

------

### 4.2 指令的寻址方式

  寻址方式是指寻找指令或操作数有效地址的方式，即确定本条指令的数据地址及下一条待执行指令的地址的方法。寻址方式分为指令寻址和数据寻址两大类。
  指令中的地址码字段并不代表操作数的真实地址，这种地址称为形式地址A。形式地址结合寻址方式，可计算出操作数在存储器中的真实地址，这种地址称为有效地址EA。

####  4.2.1 指令寻址和数据寻址

  寻找下一条将要执行的指令地址称为指令寻址； 寻找操作数的地址称为数据寻址。

#####   1.指令寻址

  指令寻址方式有两种：顺序寻址方式与跳跃寻址方式。
  （1）顺序寻址可通过PC+1（1个指令字长），自动形成下一条指令的地址
  （2）跳跃寻址通过转移类指令实现。所谓跳跃，是指下一条指令的地址码不由程序计数器给出，而由本条指令给出下条指令地址的计算方式。 是否跳跃可能受状态寄存器和操作数的控制，而跳跃到的地址分为绝对地址（由标记符直接得到）和相对地址（相对于当前指令地址的偏移量），跳跃的结果是当前指令修改PC值，所以下一条指令仍然通过PC给出。

#####   2.数据寻址

  为区别数据寻址的不同方式，通常在指令字中设一个字段，用来指明属于哪种寻址方式。
![在这里插入图片描述](E:\Development\Typora\images\20200821090108981.png)

####  4.2.2 常见的数据寻址方式

#####   1.隐含寻址

  这种类型的指令不明显地给出操作数的地址，而在指令中隐含操作数的地址。 例如，单地址的指令格式就不明显地在地址字段中指出第二操作数的地址，而规定累加器ACC作为第二操作数地址，指令格式明显指出的仅是第一操作数的地址。因此，累加器ACC对单地址指令格式来说是隐含寻址。
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638934506554.png)
  隐含寻址的优点是有利于缩短指令字长；缺点是需增加存储操作数或隐含地址的硬件。

#####   2.立即（数）寻址

  这种类型的指令的地址字段指出的不是操作数的地址，而是操作数本身，又称立即数。 数据采用补码形式存放。
![在这里插入图片描述](E:\Development\Typora\images\20200821091229524.png)
  #表示立即寻址特征，A就是操作数本身
  立即寻址的优点是指令在执行阶段不访问主存，指令执行时间最短； 缺点是A的位数限制了立即数的范围。

#####   3.直接寻址

  指令字中的形式地址A是操作数的真实地址EA，即EA=A
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638934506555.png)
  直接寻址的优点是简单，指令在执行阶段仅访问一次主存，不需要专门计算操作数的地址；缺点是A的位数决定了该指令操作数的寻址范围，操作数的地址不易修改。

#####   4.间接寻址

  指令的地址字段给出的形式地址不是操作数的真实地址，而是操作数有效地址所在的存储单元的地址，也就是操作数地址的地址，即EA=（A）。间接寻址可以是一次间接寻址，也可是多次间接寻址。
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638934506556.png)
  在图中两次间接寻址中，主存字第一位为1时，表示取出的仍不是操作数的地址，即多次间址；主存字第一位为0时，表示取得的是操作数的地址。 （当多次间接寻址时，可用存储字的首位来标志间接寻址是否结束，存储字的首位不能作为EA的组成部分）
  间接寻址的优点是可扩大寻址范围（有效地址EA的位数大于形式地址A的位数）， 便于编制程序（用间接寻址可方便地完成子程序返回）；缺点是指令在执行阶段要多次访存（一次间接寻址需2次访存，多次间接寻址需根据存储字的最高位确定访存次数)。 由于访问速度过慢，这种寻址方式并不常用。一般问到扩大寻址范围时，通常指的是寄存器间接寻址。

#####   5.寄存器寻址

  寄存器寻址是指在指令字中直接给出操作数所在的寄存器的编号，即EA=Ri，其操作数在由Ri所指的寄存器内。![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638934506557.png)
  寄存器寻址的优点是指令在执行阶段不访问主存，只访问寄存器， 因寄存器数量较少，对应地址码长度较小，使得指令字短且因不用访存，所以执行速度快，支持向量/矩阵运算；缺点是寄存器价格昂贵，计算机中的寄存器数量有限。

#####   6.寄存器间接寻址

  寄存器间接寻址是指在寄存器Ri中给出的不是一个操作数，而是操作数所在主存单元的地址，即EA=（Ri）。
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638934506558.png)
  寄存器间接寻址的特点是，与一般间接寻址相比速度更快，但指令的执行阶段需要访问主存（因为操作数在主存中)。

#####   7.相对寻址

  相对寻址是把PC的内容加上指令格式中的形式地址A而形成操作数的有效地址，即EA=（PC）+A，其中A是相对于当前指令地址的位移量，可正可负，补码表示。
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-16638934506559.png)
  A的位数决定操作数的寻址范围。
  相对寻址的优点是操作数的地址不是固定的，它随PC值的变化而变化，且与指令地址之间总是相差一个固定值，因此便于程序浮动。 相对寻址广泛用于转移指令。

  对于转移指令JMP A，当CPU从存储器中取出一字节时，会自动执行（PC）+1——>PC。 若转移指令的地址为X，占2B，则在取出该指令后，PC的值会增2，即（PC）=X+2， 这样在执行完该指令后，会自动跳转到X+2+A的地址继续执行。

#####   8.基址寻址

  基址寻址是指将CPU中基址寄存器（BR）的内容加上指令格式中的形式地址A而形成操作数的有效地址，即EA=（BR）+A。 其中基址寄存器既可采用专用寄存器，又可采用通用寄存器。（基址寄存器可采用隐式的和显式的两种。所谓隐式，是在计算机内专门设有一个基址寄存器BR，使用时用户不必明显指出该基址寄存器，只需由指令的寻址特征位反映出基址寻址即可。显式是在一组通用寄存器里，由用户明确指出哪个寄存器作为基址寄存器）
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389345065610.png)
  基址寄存器是面向OS的，其内容由OS或管理程序确定，主要用于解决程序逻辑空间与存储器物理空间的无关性。 在程序执行过程中，基址寄存器的内容不变（作为基地址），形式地址可变（作为偏移量)。 采用通用寄存器作为基址寄存器时，可由用户决定哪个寄存器作为基址寄存器，但其内容仍由OS确定。

  基址寻址的优点是可扩大寻址范围（基址寄存器的位数大于形式地址A的位数）；用户不必考虑自己的程序存于主存的哪个空间区域，因此有利于多道程序设计，并可用于编制浮动程序，但偏移量（形式地址A）的位数较短。

------

  基址寻址在多道程序中极为有用。用户可不必考虑自己的程序存于主存的哪一空间区域，完全可由OS或管理程序根据主存的使用情况，赋予基址寄存器内一个初始值（即基地址），便可将用户程序的逻辑地址转化为主存的物理地址（实际地址），把用户程序安置于主存的某一空间区域

------

#####   9.变址寻址

  变址寻址是指有效地址EA等于指令字中的形式地址A与变址寄存器IX的内容之和，即EA=（IX）+A， 其中IX为变址寄存器（专用），也可用通用寄存器作为变址寄存器。
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389345065611.png)
  变址寄存器是面向用户的，在程序执行过程中，变址寄存器的内容可由用户改变（作为偏移量），形式地址A不变（作为基地址）。
  变址寻址的优点是可扩大寻址范围（变址寄存器的位数大于形式地址A的位数）；在数组处理过程中，可设定A为数组的首地址，不断改变变址寄存器IX的内容，便可很容易形成数组中任一数据的地址，特别适合编制循环程序。 偏移量（变址寄存器IX)的位数足以表示整个存储空间。
  变址寻址与基址寻址的有效地址形成过程极为相似。但从本质上来讲，两者有较大区别。基址寻址面向系统，主要用于为多道程序或数据分配存储空间，因此基址寄存器的内容通常由OS或管理程序确定，在程序的执行过程中其值不可变，而指令字中的A是可变的；变址寻址立足于用户，主要用于处理数组问题，在变址寻址中，变址寄存器的内容由用户设定，在程序执行过程中其值可变，而指令字中的A是不可变的。

#####   10.堆栈寻址

  堆栈是存储器（或专用寄存器组）中一块特定的、按后进先出原则管理的存储区，该存储区中读/写单元的地址是用一个特定的寄存器给出的，该寄存器称为堆栈指针（SP）。堆栈可分为硬堆栈与软堆栈两种。
  寄存器堆栈又称硬堆栈。寄存器堆栈的成本高，不适合做大容量的堆栈；而从主存中划出的一段区域来做堆栈是最常用的方法，这种堆栈称软堆栈。
  在采用堆栈结构的计算机系统中，大部分指令表面上都表现为无操作数指令的形式，因为操作数地址都隐含使用了SP。通常，在读/写堆栈中的一个单元的前后都伴有自动完成对SP内容的增量或减量操作

------

  寻址方式、有效地址、访存次数（不包含为取本条指令而做的访存）的总结：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389345065612.png)

  各常见指令寻址方式的特点和适用情况：
  立即寻址操作数获取便捷，通常用于给寄存器赋初值
  直接寻址相对于立即寻址，缩短了指令长度
  间接寻址扩大了寻址范围，便于编制程序，易于完成子程序返回
  寄存器寻址的指令字较短，指令执行速度较快
  寄存器间接寻址扩大了寻址范围
  基址寻址扩大了操作数寻址范围，适用于多道程序设计，常用于为程序或数据分配存储空间
  变址寻址主要用于处理数组问题，适合编制循环程序
  相对寻址用于控制程序的执行顺序、转移等

------

####  4.2.3 X86汇编指令入门

#####   1.相关寄存器

  X86处理器中有8个32位的通用寄存器，各寄存器及说明如图：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389345065613.png)
  为了向后兼容，EAX、EBX、ECX、EDX的高2位字节和低2位字节可独立使用，E为Extended，表示32位的寄存器。例如，EAX的低两位字节称为AX，而AX的高低字节又可分别作为两个8位寄存器，分别称为AH和AL。寄存器的名称大小写均可。

#####   2.寻址模式和内存分配

  （1）寻址模式
  以mov指令为例，mov用于在内存和寄存器之间移动数据，它有两个参数：第一个是目的地址，第二个是源地址。

```c
mov eax,[ebx]				;将ebx值指示的内存地址中的4字节传送到eax
mov [var],ebx				;将ebx值传送到var的值指示的内存地址中
mov eax,[esi-4]				;将esi-4值指示的内存地址中的4字节传送到eax
mov [esi+eax],cl			;将cl值传送到esi+eax值指示的内存地址中
mov edx,[esi+4*ebx]			;将esi+4*ebx值指示的内存中的4字节传送到edx
12345
```

  （2）数据类型长度规定
  在汇编语言中声明内存大小时，一般显式地使用DB（D表示Data，B表示Byte）、DW（W表示Word,2Bytes）和DD（Double Word,4Bytes）。X86提供了三个指示规则标记，分别为BYTE PTR、WORD PTR和DWORD PTR，如：

```c
mov byte ptr [ebx],2		;将2以单字节形式传送到ebx值指示的内存地址中
mov word ptr [ebx],2		;将2以双字节形式传送到ebx值指示的内存地址中
mov dword ptr [ebx],2		;将2以四字节形式传送到ebx值指示的内存地址中
123
```

#####   3.常用指令

  汇编指令通常可分为数据传送指令、逻辑计算指令和控制流指令。以下用于操作数的标记分别表示寄存器、内存和常数：
  < reg >:表示任意寄存器，若其后带有数字，则指定其位数，如< reg32 >表示32位寄存器（EAX、EBX、ECX、EDX、ESI、EDI、ESP或EBP）；< reg16 >表示16位寄存器（AX、BX、CX或DX）；< reg8 >表示8位寄存器（AH、AL、BH、BL、CH、CL、DH、DL）
  < mem >：表示内存地址（如[eax]、[var+4]或dword ptr[eax+ebx]）
  < con >:表示8位、16位或32位常数。如< con8 >表示8位常数;
  X86中的指令机器码长度为1字节，对同一指令的不同用途有多种编码方式，如：

```c
mov ax,<con16>			;机器码为B8H
mov al,<con8>			;机器码为B0H
mov <reg16>/<mem16>,<reg16>			;机器码为89H
mov <reg8>,<reg8>/<mem8>			;机器码为8AH
mov <reg16>,<reg16>/<mem16>			;机器码为8BH
12345
```

  （1）数据传送指令
  mov指令：
  mov指令将第二个操作数（寄存器的内容、内存中的内容或常数值）复制到第一个操作数（寄存器或内存）。但不能用于直接从内存复制到内存。

```c
语法：
mov <reg>,<reg>
mov <reg>,<mem>
mov <mem>,<reg>
mov <reg>,<con>
mov <mem>,<con>
例：
mov eax,ebx		;将ebx值复制到eax
mov byte ptr [var],5		;将5保存到var值指示的内存地址的一字节中
123456789
```

  push指令：
  push指令将操作数压入内存的栈，常用于函数调用。ESP是栈顶，压栈前先将ESP值减4（栈增长方向与内存地址增长方向相反），然后将操作数压入ESP指示的地址。

```c
语法：
push <reg32>
push <mem>
push <con32>
例：（栈中元素固定为32位）
push eax		;将eax值压栈
push [var]		;将var值指示的内存地址的4字节值压栈
1234567
```

  pop指令：
  出栈前先将ESP指示的地址中的内容出栈，然后将ESP值+4

```c
pop edi			;弹出栈顶元素送到edi
pop [ebx]		;弹出栈顶元素送到ebx值指示的内存地址的4字节中
12
```

  （2）算术与逻辑运算指令
  add/sub指令：
  add指令将两个操作数相加，相加的结果保存到第一个操作数中。sub指令用于两个操作数相减，相减的结果保存到第一个操作数中。

```c
语法：
add <reg>,<reg> / sub <reg>,<reg>
add <reg>,<mem> / sub <reg>,<mem>
add <mem>,<reg> / sub <mem>,<reg>
add <reg>,<con> / sub <reg>,<con>
add <mem>,<con> / sub <mem>,<con>
例：
sub eax,10		;eax<——eax-10
add byte ptr [var],10		;10与var值指示的内存地址的一字节值相加，并将
							结果保存在var值指示的内存地址的字节中
12345678910
```

  inc/dec指令
  inc/dec指令分别表示将操作数自加1、自减1

```c
语法：
inc <reg> / dec <reg>
inc <mem> / dec <mem>
例：
dec eax			;eax值自减1
inc dword ptr [var]			;var值指示的内存地址的4字节值自加1
123456
```

  imul指令
  带符号整数乘法指令，有两种格式：（1）两个操作数，将两个操作数相乘，结果保存在第一个操作数中，第一个操作数必须为寄存器；（2）三个操作数，将第二个和第三个操作数相乘，并将结果保存在第一个操作数中，第一个操作数必须为寄存器

```c
语法：
imul <reg32>,<reg32>
imul <reg32>,<mem>
imul <reg32>,<reg32>,<con>
imul <reg32>,<mem>,<con>
例：
imul eax,[var]				;eax<——eax*[var]
imul esi,edi,25				;esi<——edi*25
12345678
```

  乘法操作结果可能溢出，则编译器置溢出标志OF=1，以使CPU调出溢出异常处理程序；

  idiv指令：
  带符号整数除法指令，它只有一个操作数，即除数，而被除数则为edx:eax中的内容（64位整数），操作结果有两部分：商和余数，商送到eax，余数则送到edx。

```c
语法：
idiv <reg32>
idiv <mem>
例：
idiv ebx
idiv dword ptr [var]
123456
```

  and/or/xor指令
  逻辑与、逻辑或、逻辑异或操作指令，用于操作数的位操作，操作结果放在第一个操作数中

```c
语法：
and <reg>,<reg> / or <reg>,<reg> / xor <reg>,<reg> 
and <reg>,<mem> / or <reg>,<mem> / xor <reg>,<mem>
and <mem>,<reg> / or <mem>,<reg> / xor <mem>,<reg>
and <reg>,<con> / or <reg>,<con> / xor <reg>,<con>
and <mem>,<con> / or <mem>,<con> / xor <mem>,<con>
例：
and eax,0fH			;将eax中的前28位全部置0，最后4位保持不变
xor edx,edx			;置edx中的内容为0
123456789
```

  not指令
  取反

```c
语法：
not <reg>
not <mem>
例：
not byte ptr [var]		;将var值指示的内存地址的一字节的所有位翻转
12345
```

  neg指令
  取负

```c
语法：
neg <reg>
neg <mem>
例：
neg eax				;eax<——-eax
12345
```

  shl/shr指令
  逻辑移位指令，shl为逻辑左移，shr为逻辑右移，第一个操作数表示被操作数，第二个操作数指示移位的位数。

```c
语法：
shl <reg>,<con8> / shr <reg>,<con8>
shl <mem>,<con8> / shr <mem>,<con8>
shl <reg>,<cl> / shr <reg>,<cl>
shl <mem>,<cl> / shr <mem>,<cl>
例：
shl eax,1			;将eax值左移一位，相当于乘2
shr ebx,cl			;将ebx值右移n位（n为cl中的值），相当于除以2^n
12345678
```

  （3）控制流指令
  X86处理器维持着一个指示当前执行指令的指令指针IP。IP寄存器不能直接操作，但可用控制流指令更新。
  jmp指令：
  控制IP转移到label所指示的地址

```c
语法：
jmp <label>
例：
jmp begin
1234
```

  jcondition指令
  条件转移指令，它依据处理机状态字中的一系列条件状态转移。

```c
语法：
je <label> (jump when equal)
jne <label> (jump when not equal)
jz <label> (jump when last result was zero)
jg <label> (jump when greater than)
jge <label> (jump when greater than or equal to)
jl <label> (jump when less than)
jle <label> (jump when less than or equal to )
例：
cmp eax,ebx
jle done		;若eax的值小于ebx值，跳转到done指示的指令执行，否则执行
					下一条指令
123456789101112
```

  cmp指令
  比较两个操作数的值，并根据比较结果设置处理机状态字中的条件码，通常和jcondition指令搭配使用

```c
语法：
cmp <reg>,<reg>
cmp <reg>,<mem>
cmp <mem>,<reg>
cmp <reg>,<con>
例：
cmp dword ptr [var],10
jne loop 			;若var指示的内存地址的4字节内容=10，则继续执行下一条
					指令，否则跳转到loop指示的指令执行
123456789
```

  call/ret指令
  这两条指令实现子程序（过程、函数等）的调用及返回。call指令首先将当前执行指令地址入栈，然后无条件转移到由标签指示的指令。call指令保存调用之前的地址信息（当call指令结束后，返回调用之前的地址）。ret指令实现子程序的返回机制，ret指令弹出栈中保存的指令地址，然后无条件转移到保存的指令地址执行。

```c
call <label>
ret
12
```

------

  例题：指令系统中采用不同寻址方式的目的是（）
  A.提供扩展操作码的可能并降低指令译码难度
  B.可缩短指令字长，扩大寻址空间，提高编程的灵活性
  C.实现程序控制
  D.三者都正确

  答案：B;

  例题：为了缩短指令中某个地址段的位数，有效的方法是采取（）
  A.立即寻址  B.变址寻址  C.基址寻址  D.寄存器寻址

  答案：D；

  例题：相对寻址方式中，指令所提供的相对地址实质上是一种（）
  A.立即数  B.内存地址  C.以本条指令在内存中首地址为基准位置的偏移量  D.以下条指令在内存中首地址为基准位置的偏移量

  答案：D；

  例题：某计算机有16个通用寄存器，采用32位定长指令字，操作码字段（含寻址方式位）为8位，Store指令的源操作数和目的操作数分别采用寄存器直接寻址和基址寻址方式。若基址寄存器可使用任一通用寄存器，且偏移量用补码表示，则Store指令中偏移量的取值范围是（）
  A.-32768~+32767  B.-32767 ~+32768
  C.-65536~+65535  D.-65535 ~+65536

  答案：A；目的操作数采用基址寻址需指定寄存器，用4位，留给偏移地址16位

  例题：设相对寻址的转移指令占3B，第一字节为操作码，第二、三字节为相对转移量（补码表示），而且数据在存储器中采用以低字节为字地址的存放方式。每当CPU从存储器取出一字节时，即自动完成（PC）+1——>PC。若PC的当前值为240（10进制），要求转移到290（10进制），则转移指令的第二、三字节的机器代码是（）；若PC的当前值为240（10进制），要求转移到200（10进制），则转移指令的第二、三字节的机器代码是（）

  答案：2FH、00H;D5H、FFH；小端方式：低位存放在低地址，高位存放在高地址。低字节为字地址即小端方式。 大端方式：高位字节存放在低地址，低位字节存放在高地址，高位字节地址为字地址即大端方式。

  例题：某计算机指令系统采用定长操作码和变长指令码格式。
  （1）采用什么寻址方式时指令码长度最短？采用什么寻址方式时指令码长度最长？
  （2）采用什么寻址方式时执行速度最快？采用什么寻址方式时执行速度最慢？
  （3）若指令系统采用定长指令码格式，则采用什么寻址方式时执行速度最快

  答案：（1）寄存器寻址方式和寄存器间接寻址方式的指令码长度最短。立即寻址方式、直接寻址方式、间接寻址方式的指令码长度最长。若指令码长度太短，则无法表示范围较大的立即数和寻址到较大的内存地址空间
  （2）寄存器寻址方式执行速度最快（采用变长指令码格式，由于要表示一定范围内的立即数，包含立即数的指令通常需要较多的二进制位，取指令时，可能需要不止一次地读内存来完成取指令，因此寄存器寻址方式执行速度最快）；间接寻址方式执行速度最慢。
  （3）立即寻址方式执行速度最快（采用定长指令码格式时，所有指令所包含的二进制位相同）

  例题：![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389345065614.png)
![在这里插入图片描述](E:\Development\Typora\images\20200821152707754.png)
![在这里插入图片描述](E:\Development\Typora\images\20200821152720174.png)
  答案：（1）32；
  （2、3）寻址范围是一个数字范围，不带有单位。寻址范围的大小是一个数，指寻址区间的大小。注意变址寻址形式地址不变。
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389345065815.png)
  例题：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389345065816.png)
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389345065817.png)
  答案：（1）16,8，16,16；  （2）0000H~FFFFH；
  （3)2315H；自增操作在运算结束后进行，R5的内容由5678H变为5679H，存储单元5678H中的内容变为68ACH；

  例题：![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389345065818.png)

  答案：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389345065819.png)

  例题：![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389345065820.png)
![在这里插入图片描述](E:\Development\Typora\images\20200821161615986.png)
![在这里插入图片描述](E:\Development\Typora\images\20200821161654351.png)

![在这里插入图片描述](E:\Development\Typora\images\2020082116181522.png)

![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389345065921.png)
  答案：（1）按字节编址，最多后跳127条指令
  （2）1FD4H,200EH；
  （3）C=Z=1，N=0；CF在最高位有进、借位时置1，符号标志表示运算结果最高位（无符号数比较，若<=，运算结果最高位可能为1也可能为0，如10H-A0H=70H，最高位为0）
  （4)部件1为指令寄存器，用于存放当前指令；多路选择器左边线上的结果应为PC+2+2xOFFSET。部件2用于左移1位实现乘2，为移位寄存器。部件3用于PC+2和2xOFFSET相加，为加法器。

  例题：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389345065922.png)

![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389345065923.png)
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389345065924.png)

  答案：（1）128；  （2）0240H、0488H、06EAH；  （3）0，mov,mova,left,read,sub,mov,SRout  （4）4、2；读/写寄存器需1个时钟周期

  例题：
![在这里插入图片描述](E:\Development\Typora\images\2020082117154868.png)
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389345065925.png)
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389345065926.png)
![在这里插入图片描述](E:\Development\Typora\images\20200821171727713.png)

  答案：（1）M为CISC。M的指令长短不一，不符合RISC指令系统的特点。
  （2）96B；f1的第一条指令所在的虚拟地址为00401020H，最后一条指令的虚拟地址为0040107FH，f1的机器指令代码长度为60H=96B；
  （3）CF=1；执行第20条指令时，在补码加/减运算器中执行0减FFFF FFFFH操作，减法运算时的借位标志CF=1；
  （4）不能，shl指令把一个整数的所有有效数位整体左移，而对于float型变量，其机器数中包含阶码部分，将其作为一个整体左移时不能实现乘2的功能；

  例题：![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389345065927.png)
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389345065928.png)
![在这里插入图片描述](E:\Development\Typora\images\20200821201216995.png)

  答案：（1）10次；执行第16行的call指令时递归调用f1;
  （2）第12行的jle指令是条件转移指令；第16行的call指令、第20行的jmp指令、第30行的ret指令一定会使程序跳转执行；
  （3）0040102AH；偏移量为00401000H-0040102AH=FFFF FFD6H；小端方式；
  （4）f(13)超出了int型数据能表示的最大范围，因此返回的是一个发生了溢出的错误结果；可将函数f1的返回值改为long long
  （5）函数的返回值为int型，若乘积的高33位为非全0或非全1，则OF=1；应加一条溢出自陷指令，使得CPU自动查询溢出标志OF，当OF=1时调出溢出异常处理程序。

  46题答案：虚拟地址的高20位为页号，相同，在同一页中；高22位为标记，中间4位为组号，低6位为块内地址；虚拟地址和物理地址的最低12位相同，对应的组号为0；

------

### 4.3 CISC和RISC的基本概念

  指令系统朝两个截然不同的方向发展：一是增强原有指令的功能，设置更为复杂的新指令实现软件功能的硬化，这类机器称为复杂指令系统计算机（CISC）。 典型的有采用X86架构的计算机；二是减少指令种类和简化指令功能，提高指令的执行速度，这类机器称为精简指令系统计算机（RISC）， 典型的有ARM，MIPS架构的计算机。

####  4.3.1 复杂指令系统计算机（CISC）

  CISC的主要特点：
  （1）指令系统复杂庞大，指令数目一般为200条以上
  （2）指令的长度不固定， 指令格式多，寻址方式多
  （3）可以访存的指令不受限制
  （4）各种指令使用频度相差很大
  （5）各种指令执行时间相差很大，大多数指令需多个时钟周期才能完成
  （6）控制器大多数采用微程序控制。有些指令非常复杂，以至于无法采用硬连线控制
  （7）难以用优化编译生成高效的目标代码程序

####  4.3.2 精简指令系统计算机（RISC）

  精简指令系统计算机（RISC）的中心思想是要求指令系统简化，尽量使用寄存器-寄存器操作指令，指令格式力求一致。RISC的主要特点如下：
  （1）选取使用频率最高的一些简单指令，复杂指令的功能由简单指令的组合来实现
  （2）指令长度固定， 指令格式种类少，寻址方式种类少
  （3）只有Load/Store（取数/存数）指令访存，其余指令的操作都在寄存器之间进行
  （4）CPU中通用寄存器的数量相当多
  （5）RISC一定采用指令流水线技术， 大部分指令在一个时钟周期内完成
  （6）以硬布线控制为主，不用或少用微程序控制
  （7）特别重视编译优化工作，以减少程序执行时间
  从指令系统兼容性来看，CISC大多能实现软件兼容，即高档机包含了低档机的全部指令， 并可加以扩充。但RISC简化了指令系统，指令条数少，格式也不同于老机器，因此大多数RISC机不能与老机器兼容。

------

  为了规整指令格式，使指令具有相同的长度，规定只有Load/Store指令才能访存。而运算指令不能直接访存，只能从寄存器取数进行运算，运算的结果也只能送到寄存器。因为寄存器编号较短，而主存地址的位数较长，通过某种方式可使运算指令与访存指令的长度一致。
  由于只有Load/Store指令才能访问内存，程序中可能会包含许多装入指令和存储指令，与一般通用寄存器指令风格相比，其程序长度会更长。

------

####  4.3.3 CISC和RISC的比较

  和CISC比，RISC的优点主要体现在以下几点：
  （1）RISC更能充分利用VLSI芯片的面积。CISC的控制器大多采用微程序控制，其控制存储器在CPU芯片内所占的面积达50%以上，而RISC控制器采用组合逻辑控制，其硬布线逻辑只占CPU芯片面积的10%
  （2）RISC更能提高运算速度。 RISC的指令数、寻址方式和指令格式种类少，又设有多个通用寄存器，采用流水线技术，所以运算速度更快，大多数指令在一个时钟周期内完成
  （3）RISC便于设计，可降低成本，提高可靠性
  （4）RISC有利于编译程序代码优化。 RISC指令类型少，寻址方式少，使编译程序容易选择更有效的指令和寻址方式，并适当地调整指令顺序，使得代码执行更高效化
  CISC和RISC的对比见表：
![在这里插入图片描述](E:\Development\Typora\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzA5OTkw,size_16,color_FFFFFF,t_70-166389345065929.png)

------

  例题：下列指令系统的特点中，有利于实现指令流水线的是（）
  1.指令格式规整且长度一致  2.指令和数据按边界对齐存放  3.只有Load/Store指令才能对操作数进行存储访问
  A.1,2  B.2,3  C.1,3  D.1,2,3

  答案：D；指令长度一致、按边界对齐存放、仅Load/Store指令访存，这些都是RISC的特征，它们使取指令、取操作数的操作简化且时间长度固定，能有效地简化流水线的复杂度。